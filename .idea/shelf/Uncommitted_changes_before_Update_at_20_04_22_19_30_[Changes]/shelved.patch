Index: Munchkin/bin/players/playermodel.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nClass to build model players and assign new attributes associated with cards through gameplay.\r\n\r\nConsider what the player class is responsible for...\r\n\r\nConsiderations:\r\n    Player model\r\n    player setup name & gender\r\n    Death and reset\r\n    accessing player and changing player resources\r\n    save -- most likely shelve objects\r\n    stats access\r\n\r\n\"\"\"\r\n\r\n\r\nfrom Munchkin.bin.all_cards.table import Table # most likely not used here (pos for cross talk bypassing circular\r\n# import but may require for adding to player inventory and stats (note same card in engine will return here)\r\nfrom Munchkin.bin.all_cards.treasure_cards.treasurecards import Treasure\r\n\r\nfrom Munchkin.bin.players.playersetup import P_tools # OF LITTLE USE. Methods name/gender moved to this script.\r\nimport bin.GUI.gui_variables as gameVar\r\nfrom bin.all_cards.table import cards\r\nfrom bin.all_cards.door_cards.doorcards import MonTools\r\nfrom bin.all_cards.treasure_cards.treasurecards import T_tools\r\nfrom itertools import cycle\r\n\r\n\"\"\"This is the player class. It will have all setting to configure players and modify attributes that are set to that\r\nplayer. It will inherit from moncurse and treasure so that a player can add items to their attributes and modify\r\nattributes based on action outcomes.\"\"\"\r\n\r\n#####################################################################\r\n# MAIN PLAYER CLASS\r\n#####################################################################\r\n\r\nclass Player(MonTools, T_tools):\r\n    \"\"\"Main player class, inherits off card methods making changes to the player.\"\"\"\r\n\r\n    def __init__(self, ref):\r\n        self.ref = ref # simple form to keep track of players\r\n        self.name = \"\"\r\n        self.gender = \"male\" # default required..dont think it works like this...\r\n        self.level = 1 # win lvl 10, make changeable so edit score to win\r\n        self.bonus = 0\r\n        self.wallet = 0\r\n        self.race = \"human\" # string eval to True so will show\r\n        self.race2 = \"\"\r\n        self.race_unlock = False # DEFAULT = False method by halfbread triggers this a True state (method to be added)\r\n        self.klass = \"No class\"\r\n        self.klass2 = \"\"\r\n        self.klass_unlock = False # method by supermunchkin triggers this a True state\r\n        self.big = \"\" # can carry only 1 big item\r\n        self.big2 = []\r\n        self.big_unlock = False\r\n        self.weapons = {\"L_hand\": \"\", \"R_hand\": \"\", \"two_hand\": \"\"} # values will be cards\r\n        self.weapon_count = 2  # 1 per hand, can add to with cheat. adding +=, removal -=.\r\n        self.armor = {\"headgear\": \"\", \"armor\": \"\", \"knees\": \"\", \"footgear\": \"\",\r\n                      \"necklace\": \"\", \"ring\": \"\", \"ring2\": \"\"}\r\n        self.sack = [] # 5 max, editable in options\r\n        self.hireling = []\r\n        # self.unsorted = [] # Old! list of all cards that are used to by sorting\r\n        self.alive = True\r\n        self.longevity = 0 # counts cycles alive, if 0 player misses go\r\n        self.cheat = 0 # set to false\r\n        self.cheat_card = 0 # card the player is cheating with\r\n        self.enhancer_cards = []  # cards that elicit an effect ie supermunch/class card, ect. card lexical must be added to enhancer lexical\r\n        self.enhancers_lexical = set() # all positive effects strings for comparative evaluation. only added when card installed on player.\r\n        self.active_curses = []  # place to store all curse cards effecting player. card remove meth should reverse player change\r\n        self.negative_lexical = set() # all negative effects strings for comparative evaluation. only added when card installed on player.\r\n        self.run = 4 # ability to run, manipulable. note elf must change this. !!! use as bool and escape value!\r\n        self.run_away = True # locks ability toi run or not dependent on some monsters\r\n\r\n    def __repr__(self):\r\n        \"\"\"developer aid\"\"\"\r\n        return f\"\\nPLAYER REF:{self.ref}\\nName:{self.name}\\ngender:{self.gender}\\nLevel:{self.level}\" \\\r\n               f\"\\nBonus:{self.bonus}\\nSack:{self.wallet}\\n\"\r\n\r\n    # def __str__(self):\r\n    #     \"\"\"developer aid\"\"\"\r\n    #     return f\"\\nPLAYER INFO:\\nName:{self.name}\\ngender:{self.gender}\\nLevel:{self.level}\" \\\r\n    #            f\"\\nBonus:{self.bonus}\\n\"\r\n\r\n    @classmethod\r\n    def gender(cls):\r\n        \"\"\"Sets gender\"\"\"\r\n        x = gameVar.PlayerAtribs.player_gender # grabs string stored in in game var\r\n        return x\r\n\r\n    @classmethod\r\n    def name(cls):\r\n        \"\"\"Sets name\"\"\"\r\n        x = gameVar.PlayerAtribs.player_name\r\n        if x == \"rory\":  # ......................................................................... dev mode\r\n            y = \"The_Creator\"\r\n            return y\r\n        return x\r\n\r\n    def update_bindings(self, carried):\r\n        \"\"\"just gets whats attached to the player\"\"\"\r\n        category = [self.weapons, self.armor]  # locations to search\r\n        for sub_cat in category:  # is the dict as a whole\r\n            for key in sub_cat:\r\n                if isinstance(sub_cat[key], dict) and key == carried:\r\n                    # gameVar.GameObjects.message = f'{sub_cat.get(key).get(\"name\")} has been bound to {key}'\r\n                    return sub_cat.get(key).get(\"name\")\r\n\r\n    def char_setup(self):\r\n        # complete, prints to be removed\r\n        \"\"\"sets up name and gender in gameVar and player instance when called\"\"\"\r\n        na = Player.name() # method to set name\r\n        self.name = na  # makes change to player\r\n        xy = Player.gender()\r\n        self.gender = xy\r\n\r\n        if self.name == \"The_Creator\": # ................................................................... dev mode\r\n            self.gender = \"bob\"\r\n            self.bonus = 200\r\n            self.wallet = 20000\r\n            gameVar.PlayerAtribs.player_gender = self.gender\r\n            gameVar.GameObjects.message2 = f\"{self.name} is in play, a god among mer mortals!\"\r\n\r\n        #~~~~~~~~~~~~ info\r\n        print(f\"The player {self.name.title()} with the gender {self.gender.title()} has been created.\")\r\n        # ~~~~~~~~~~~~\r\n\r\n    def inventory(self, key, cardtype): # called from GUI on button press\r\n        \"\"\"Returns list of dict from player sack cards that have a specific key and specific value.\r\n        (ie sub_type == armour). returns all sub_types with the val of armor\"\"\"\r\n        gameVar.GameObjects.selected_items = [obj for obj in self.sack if obj[key] == cardtype]\r\n\r\n    def item_by_key(self, key):# generalised meth for key search\r\n        \"\"\"Returns list of cards form player sack list that contain the key x. (ie \"sell\").\r\n        This is generalised meth for key search \"\"\"\r\n        gameVar.GameObjects.selected_items = [obj for obj in self.sack if obj.get(key)]\r\n\r\n    def sell_item(self, card): # called by player.sell_item so self bound to player\r\n        \"\"\"Call from zipper to sell items, remove cards, reset gameVars and call to add to burn pile\"\"\"\r\n        self.wallet += card[\"sell\"] #adds worth of card to player\r\n        gameVar.GameObjects.message = f\"Selling sack {card['name']}, Card added to burn pile. Depth: {len(cards.burn_pile)}\"\r\n        x = self.sack.pop(self.sack.index(card)) # removes card from player sack deck\r\n        cards.add_to_burn(x)# adds card to burn pile on table\r\n        gameVar.GameObjects.message = f\"Selling sack {card['name']}, \" \\\r\n                                      f\"\\nCard added to burn pile. Depth: {len(cards.burn_pile)}\"\r\n        # print(\"tup list: \", gameVar.GameObjects.zipped_tup)\r\n\r\n    def sum_of_bonuses(self): # pos multi usage and use as player item searcher. limited by equipped_items as caller\r\n        \"\"\" Adds up all bonuses and bind to player in weapons and armour\"\"\"\r\n        tot_bonus = 0\r\n        locations = [self.weapons, self.armor] #locations to search\r\n        for obj in locations: # looks at each object in list\r\n            for sub_menu in obj:\r\n                if isinstance(obj[sub_menu], dict): #checks submenu for card attachment in the form of a dict\r\n                    # print(obj.get(sub_menu, \"No sub menu\").get(\"bonus\", \"No bonus found\"))\r\n                    tot_bonus += obj.get(sub_menu, \"\").get(\"bonus\", \"Problem getting bonus\")\r\n                    continue\r\n        if self.name == \"The_Creator\":\r\n            tot_bonus = 200 + tot_bonus\r\n        self.bonus = tot_bonus\r\n\r\n    def equipped_items(self, action, my_cards=None, card_id=None): # in use by gui list_equipped meth\r\n        \"\"\"Shows all items that have been equipped to the player. If remove, Sorts through equipped items,\r\n        removing items that have been selected\"\"\"\r\n        locations = [self.weapons, self.armor]  # locations to search\r\n        for obj in locations:  # looks at each object in list. obj is the dict of all the poss locations as seen in player attrbs\r\n            for sub_menu in obj:  # sub_menu is the keys which link to the card is placed in: armor = {}\r\n                if isinstance(obj[sub_menu], dict):  # checks submenu for card attachment in the form of a dict\r\n                    card = obj.get(sub_menu) # x is the card object\r\n                    if action == \"list_equipped\":\r\n                        gameVar.GameObjects.selected_items.append(card) #adds cards to selected_items list in gameVar\r\n                        continue\r\n                    elif action == \"removal\":\r\n                        if card[\"id\"] == my_cards[\"id\"]:\r\n                            self.sack.append(card) # adds card back to player inventory\r\n                            obj[sub_menu] = \"\" # resets player atrib location\r\n                            self.sum_of_bonuses() # recalculates bonuses\r\n                            self.weapon_count += card.get(\"hold_weight\", 0) # adds the cards carry_weight for available hands, if available.\r\n                            continue\r\n                    elif action == \"curse\": # not tested\r\n                        print(\"In equipped items remove cursed item\")\r\n                        pass\r\n\r\n    def equip_armor(self, card):\r\n        \"\"\" Equips armor to the player\"\"\"\r\n        location = self.armor\r\n        print(\"in armor\")\r\n        for sub_type in location.keys():\r\n            if card[\"sub_type\"] == sub_type:  # matches card[\"sub_type] to list\r\n                occupied = isinstance(self.armor[sub_type], dict)\r\n                if not occupied:\r\n                    x = self.sack.pop(self.sack.index(card))  # removes cards from sack list\r\n                    self.armor[sub_type] = x  # adds to player's attribs\r\n                    break\r\n                elif occupied:\r\n                    card_removed = self.armor.pop(sub_type)  # removing card from player's attrib\r\n                    self.sack.append(card_removed)\r\n                    x = self.sack.pop(self.sack.index(card))  # removes cards from sack list\r\n                    self.armor[sub_type] = x  # binds now card to player attribute\r\n                    break\r\n        gameVar.GameObjects.message = f\"Equipping {card['name']}\"\r\n        self.sum_of_bonuses()\r\n\r\n    def equip_weapon(self, card):\r\n        \"\"\"New simplified model. Checks L/R hands to see if full, equipping if not.\r\n        Two hand items will not work when other hands full. \"\"\"\r\n        if self.weapon_count > 0:\r\n            if card[\"sub_type\"] == \"1hand\" and not isinstance(self.weapons[\"L_hand\"], dict): # if 1handed weap and no card in players left hand...\r\n                added_card = self.sack.pop(self.sack.index(card)) # gets list index for pop by calling index() on object thus returning index\r\n                self.weapons[\"L_hand\"] = added_card\r\n                self.weapon_count -= card.get(\"hold_weight\")\r\n                gameVar.GameObjects.message = f\"Equipping {card['name']} to left hand\"\r\n            elif card[\"sub_type\"] == \"1hand\" and not isinstance(self.weapons[\"R_hand\"], dict): # not equipped\r\n                gameVar.GameObjects.message = f\"Equipping {card['name']} to right hand\"\r\n                added_card = self.sack.pop(self.sack.index(card))\r\n                self.weapons[\"R_hand\"] = added_card\r\n                self.weapon_count -= card.get(\"hold_weight\")\r\n            elif card[\"sub_type\"] == \"2hand\" and not isinstance(self.weapons[\"two_hand\"], dict):\r\n                if isinstance(self.weapons[\"L_hand\"], dict) or isinstance(self.weapons[\"R_hand\"], dict):\r\n                    gameVar.GameObjects.message = \"You can not equip this item while you have items in your other hands\"\r\n                elif not isinstance(self.weapons[\"L_hand\"], dict) and not isinstance(self.weapons[\"R_hand\"], dict):\r\n                    gameVar.GameObjects.message = f\"Equipping {card['name']} to both hands\"\r\n                    added_card = self.sack.pop(self.sack.index(card))\r\n                    self.weapons[\"two_hand\"] = added_card\r\n                    self.weapon_count -= card.get(\"hold_weight\")\r\n            else: # cheat card section/ big item\r\n                pass\r\n        else:\r\n            gameVar.GameObjects.message = \"You are at max capacity. Remove some weapons to attach others!\"\r\n        print(\"capacity count\", self.weapon_count)\r\n        self.sum_of_bonuses()\r\n\r\n    def card_meths(self, card, calltype=None, action=None, *args, **kwargs): # calltype = method or static, action on or off.\r\n        \"\"\"link to card methods for active effect on player action =add, conditions or remove\"\"\"\r\n        print(f\"In player card_meth. Calltype: {calltype}, Action: {action}\") # info on meth used and status\r\n        \"\"\"will use add/remove suited to door cards, loose cases and curse canceling\"\"\"\r\n        for key, val in MonTools.method_types.items(): # look up methods associated to all cards in doorcards.py\r\n            if key == card.get(calltype): # tests all keys agains all methods/static in a card.ie key = \"loose_footgear\", if the key matches the value of the cards 'method' or 'static': \"loose_footgear\" this method is called\r\n                print(f\"the key is {key}\")\r\n                val(self, action, args, kwargs) # take the value of the key and calls the method associated to it with the given parameters; action is on or off. Simple on/off switch for the card to make changes to the player (self arg).\r\n\r\n\r\n\"\"\"\r\ncard meth to handle curse, monsters ect. must handle both a static action and methods associated to add and remove.\r\ncalls required from; player select card, door kick for static ie no run, and loose scenario  \r\n\r\n\r\n\"\"\"\r\n\r\n\r\np1 = Player(1) #passes reference (ref)\r\np2 = Player(2)\r\np3 = Player(3)\r\np4 = Player(4)\r\np5 = Player(5)\r\np6 = Player(6)\r\np7 = Player(7)\r\np8 = Player(8)\r\np9 = Player(9)\r\np10 = Player(10)\r\n# p1.get_treasure()\r\n\r\n\r\n\r\nif __name__ == '__main__':\r\n    p1 = Player(1)\r\n    print(p1)\r\n    # p1.get_treasure() # duplicate val is print state from Handler class method (note is same: GOOD)\r\n    # p1.char_setup() # calls player name/gender setup, to be called after player number select\r\n    # p1.inventory() # shows inventory of new built char\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/players/playermodel.py b/Munchkin/bin/players/playermodel.py
--- a/Munchkin/bin/players/playermodel.py	
+++ b/Munchkin/bin/players/playermodel.py	
@@ -33,11 +33,12 @@
 # MAIN PLAYER CLASS
 #####################################################################
 
+
 class Player(MonTools, T_tools):
     """Main player class, inherits off card methods making changes to the player."""
 
-    def __init__(self, ref):
-        self.ref = ref # simple form to keep track of players
+    def __init__(self, ref=None): # removed ref for player factory. not in use, old idea
+        # self.ref = ref # simple form to keep track of players
         self.name = ""
         self.gender = "male" # default required..dont think it works like this...
         self.level = 1 # win lvl 10, make changeable so edit score to win
@@ -238,6 +239,10 @@
                 val(self, action, args, kwargs) # take the value of the key and calls the method associated to it with the given parameters; action is on or off. Simple on/off switch for the card to make changes to the player (self arg).
 
 
+
+
+
+
 """
 card meth to handle curse, monsters ect. must handle both a static action and methods associated to add and remove.
 calls required from; player select card, door kick for static ie no run, and loose scenario  
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"e89d33e8-f65b-4c0f-9d3f-1de9856c0ba0\" name=\"Changes\" comment=\"lol for first monster trial 1. BEFORE CHANGE!\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Munchkin/Tests/general_tests.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Munchkin/Tests/general_tests.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Munchkin/bin/GUI/controller.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Munchkin/bin/GUI/controller.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Munchkin/bin/GUI/gui_variables.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Munchkin/bin/GUI/gui_variables.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards/doorcards.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards/doorcards.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Munchkin/bin/all_cards/table.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Munchkin/bin/all_cards/table.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Munchkin/bin/engine/game_loop_v3.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Munchkin/bin/engine/game_loop_v3.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Munchkin/bin/players/playermodel.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Munchkin/bin/players/playermodel.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"228V1szxqWwIqe83W3F9S3jTuGo\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\">\r\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\r\n  </component>\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"ASKED_ADD_EXTERNAL_FILES\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\r\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\r\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$/../Learning_files\" />\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Python.controller\">\r\n    <configuration name=\"controller\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"MyPackages\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/bin/GUI/controller.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"doorcards\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"MyPackages\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards/doorcards.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"funct_trial\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"MyPackages\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/funct_trial.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"game_loop_v3\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"MyPackages\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/bin/engine\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/bin/engine/game_loop_v3.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"general_tests\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"MyPackages\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/Tests\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/Tests/general_tests.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"Python.game_loop_v3\" />\r\n      <item itemvalue=\"Python.general_tests\" />\r\n      <item itemvalue=\"Python.controller\" />\r\n      <item itemvalue=\"Python.funct_trial\" />\r\n      <item itemvalue=\"Python.doorcards\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.controller\" />\r\n        <item itemvalue=\"Python.general_tests\" />\r\n        <item itemvalue=\"Python.game_loop_v3\" />\r\n        <item itemvalue=\"Python.doorcards\" />\r\n        <item itemvalue=\"Python.funct_trial\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"e89d33e8-f65b-4c0f-9d3f-1de9856c0ba0\" name=\"Changes\" comment=\"\" />\r\n      <created>1639218994311</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1639218994311</updated>\r\n      <workItem from=\"1639218997657\" duration=\"35269000\" />\r\n      <workItem from=\"1639735508330\" duration=\"18975000\" />\r\n      <workItem from=\"1640013914970\" duration=\"13331000\" />\r\n      <workItem from=\"1640513559951\" duration=\"433000\" />\r\n      <workItem from=\"1640952454199\" duration=\"648000\" />\r\n      <workItem from=\"1649103067776\" duration=\"360000\" />\r\n      <workItem from=\"1649237457571\" duration=\"2195000\" />\r\n      <workItem from=\"1649273824130\" duration=\"6052000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"update to card date structure\">\r\n      <created>1639844962852</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1639844962852</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"changes image recall file structure to handle different os with pathlib module\">\r\n      <created>1649255260546</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1649255260546</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"changes image recall file structure to handle different os with pathlib module\">\r\n      <created>1649273835279</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1649273835279</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"docs\">\r\n      <created>1649280322103</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1649280322103</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"lol for first monster trial 1. BEFORE CHANGE!\">\r\n      <created>1649621708324</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1649621708324</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"6\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <option name=\"ADD_EXTERNAL_FILES_SILENTLY\" value=\"true\" />\r\n    <MESSAGE value=\"update to card date structure\" />\r\n    <MESSAGE value=\"changes image recall file structure to handle different os with pathlib module\" />\r\n    <MESSAGE value=\"docs\" />\r\n    <MESSAGE value=\"lol for first monster trial 1. BEFORE CHANGE!\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"lol for first monster trial 1. BEFORE CHANGE!\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/Munchkin/bin/engine/game_loop_v3.py</url>\r\n          <line>214</line>\r\n          <option name=\"timeStamp\" value=\"37\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\r\n    <SUITE FILE_PATH=\"coverage/gui_v3_py$controller.coverage\" NAME=\"controller Coverage Results\" MODIFIED=\"1616616433552\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\r\n    <SUITE FILE_PATH=\"coverage/Working_git_projects$server.coverage\" NAME=\"server Coverage Results\" MODIFIED=\"1607734550477\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/../PycharmProjects/2-Modules/Networking/basics\" />\r\n    <SUITE FILE_PATH=\"coverage/gui_v3_py$doorcards.coverage\" NAME=\"doorcards Coverage Results\" MODIFIED=\"1617305583240\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards\" />\r\n    <SUITE FILE_PATH=\"coverage/MyPackages$funct_trial.coverage\" NAME=\"funct_trial Coverage Results\" MODIFIED=\"1640967852670\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Working_git_projects$cascading_frames.coverage\" NAME=\"cascading_frames Coverage Results\" MODIFIED=\"1606569227994\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/../PycharmProjects/2-Modules/TK_GUI/methods\" />\r\n    <SUITE FILE_PATH=\"coverage/MyPackages$controller.coverage\" NAME=\"controller Coverage Results\" MODIFIED=\"1640976909484\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\r\n    <SUITE FILE_PATH=\"coverage/gui_v3_py$test_engine.coverage\" NAME=\"test_engine Coverage Results\" MODIFIED=\"1614457569538\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/Tests/testengine\" />\r\n    <SUITE FILE_PATH=\"coverage/gui_v3_py$game_loop_v3.coverage\" NAME=\"game_loop_v3 Coverage Results\" MODIFIED=\"1615720610908\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/engine\" />\r\n    <SUITE FILE_PATH=\"coverage/Working_git_projects$game_loop_v3.coverage\" NAME=\"game_loop_v3 Coverage Results\" MODIFIED=\"1649621688034\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/engine\" />\r\n    <SUITE FILE_PATH=\"coverage/Working_git_projects$components.coverage\" NAME=\"components Coverage Results\" MODIFIED=\"1606571460461\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/../PycharmProjects/2-Modules/TK_GUI/methods\" />\r\n    <SUITE FILE_PATH=\"coverage/Munch$general_tests.coverage\" NAME=\"general_tests Coverage Results\" MODIFIED=\"1649253557839\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/Tests\" />\r\n    <SUITE FILE_PATH=\"coverage/gui_v3_py$game_loop_v2.coverage\" NAME=\"game_loop_v2 Coverage Results\" MODIFIED=\"1614508656597\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/engine\" />\r\n    <SUITE FILE_PATH=\"coverage/Working_git_projects$general_tests.coverage\" NAME=\"general_tests Coverage Results\" MODIFIED=\"1649624272820\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/Tests\" />\r\n    <SUITE FILE_PATH=\"coverage/Working_git_projects$controller.coverage\" NAME=\"controller Coverage Results\" MODIFIED=\"1649624614204\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\r\n    <SUITE FILE_PATH=\"coverage/gui_v3_py$run.coverage\" NAME=\"run Coverage Results\" MODIFIED=\"1617043566223\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Working_git_projects$gui_v3.coverage\" NAME=\"gui_v3 Coverage Results\" MODIFIED=\"1606573299996\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\r\n    <SUITE FILE_PATH=\"coverage/gui_v3_py$gui_variables.coverage\" NAME=\"gui_variables Coverage Results\" MODIFIED=\"1616964872872\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\r\n    <SUITE FILE_PATH=\"coverage/gui_v3_py$gui_v3.coverage\" NAME=\"gui_v3 Coverage Results\" MODIFIED=\"1612123491582\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\r\n    <SUITE FILE_PATH=\"coverage/Working_git_projects$doorcards.coverage\" NAME=\"doorcards Coverage Results\" MODIFIED=\"1649275056101\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards\" />\r\n    <SUITE FILE_PATH=\"coverage/Working_git_projects$client.coverage\" NAME=\"client Coverage Results\" MODIFIED=\"1607734581411\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/../PycharmProjects/2-Modules/Networking/basics\" />\r\n    <SUITE FILE_PATH=\"coverage/gui_v3_py$controler.coverage\" NAME=\"controler Coverage Results\" MODIFIED=\"1614511168277\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\r\n    <SUITE FILE_PATH=\"coverage/gui_v3_py$pic_test.coverage\" NAME=\"pic_test Coverage Results\" MODIFIED=\"1616512660881\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/../PycharmProjects/2-Modules/TK_GUI/Tool_box\" />\r\n    <SUITE FILE_PATH=\"coverage/gui_v3_py$controller__1_.coverage\" NAME=\"controller (1) Coverage Results\" MODIFIED=\"1639218287704\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\r\n    <SUITE FILE_PATH=\"coverage/MyPackages$doorcards.coverage\" NAME=\"doorcards Coverage Results\" MODIFIED=\"1639811290752\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards\" />\r\n    <SUITE FILE_PATH=\"coverage/Munch$controller.coverage\" NAME=\"controller Coverage Results\" MODIFIED=\"1649254694799\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\r\n    <SUITE FILE_PATH=\"coverage/Munch$doorcards.coverage\" NAME=\"doorcards Coverage Results\" MODIFIED=\"1649279228321\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards\" />\r\n    <SUITE FILE_PATH=\"coverage/Working_git_projects$funct_trial.coverage\" NAME=\"funct_trial Coverage Results\" MODIFIED=\"1640985624373\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Munch$game_loop_v3.coverage\" NAME=\"game_loop_v3 Coverage Results\" MODIFIED=\"1649605889035\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/engine\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	
+++ b/.idea/workspace.xml	
@@ -1,13 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ChangeListManager">
-    <list default="true" id="e89d33e8-f65b-4c0f-9d3f-1de9856c0ba0" name="Changes" comment="lol for first monster trial 1. BEFORE CHANGE!">
+    <list default="true" id="e89d33e8-f65b-4c0f-9d3f-1de9856c0ba0" name="Changes" comment="gui to gameloop for updating table lol not complete. &#10;args and kwargs added to player for card meths simplicity">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Munchkin/Tests/general_tests.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/Tests/general_tests.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Munchkin/bin/GUI/controller.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/GUI/controller.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Munchkin/bin/GUI/gui_variables.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/GUI/gui_variables.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards/doorcards.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards/doorcards.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Munchkin/bin/all_cards/table.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/all_cards/table.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/Munchkin/bin/engine/game_loop_v3.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/engine/game_loop_v3.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/Munchkin/bin/players/playermodel.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/players/playermodel.py" afterDir="false" />
     </list>
@@ -25,6 +20,9 @@
   </component>
   <component name="Git.Settings">
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
+  </component>
+  <component name="MarkdownSettingsMigration">
+    <option name="stateVersion" value="1" />
   </component>
   <component name="ProjectId" id="228V1szxqWwIqe83W3F9S3jTuGo" />
   <component name="ProjectLevelVcsManager" settingsEditedManually="true">
@@ -185,6 +183,8 @@
       <workItem from="1649103067776" duration="360000" />
       <workItem from="1649237457571" duration="2195000" />
       <workItem from="1649273824130" duration="6052000" />
+      <workItem from="1649968605323" duration="2111000" />
+      <workItem from="1649977782031" duration="547000" />
     </task>
     <task id="LOCAL-00001" summary="update to card date structure">
       <created>1639844962852</created>
@@ -221,7 +221,14 @@
       <option name="project" value="LOCAL" />
       <updated>1649621708324</updated>
     </task>
-    <option name="localTasksCounter" value="6" />
+    <task id="LOCAL-00006" summary="gui to gameloop for updating table lol not complete. &#10;args and kwargs added to player for card meths simplicity">
+      <created>1649625279925</created>
+      <option name="number" value="00006" />
+      <option name="presentableId" value="LOCAL-00006" />
+      <option name="project" value="LOCAL" />
+      <updated>1649625279925</updated>
+    </task>
+    <option name="localTasksCounter" value="7" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -244,14 +251,15 @@
     <MESSAGE value="changes image recall file structure to handle different os with pathlib module" />
     <MESSAGE value="docs" />
     <MESSAGE value="lol for first monster trial 1. BEFORE CHANGE!" />
-    <option name="LAST_COMMIT_MESSAGE" value="lol for first monster trial 1. BEFORE CHANGE!" />
+    <MESSAGE value="gui to gameloop for updating table lol not complete. &#10;args and kwargs added to player for card meths simplicity" />
+    <option name="LAST_COMMIT_MESSAGE" value="gui to gameloop for updating table lol not complete. &#10;args and kwargs added to player for card meths simplicity" />
   </component>
   <component name="XDebuggerManager">
     <breakpoint-manager>
       <breakpoints>
         <line-breakpoint enabled="true" suspend="THREAD" type="python-line">
           <url>file://$PROJECT_DIR$/Munchkin/bin/engine/game_loop_v3.py</url>
-          <line>214</line>
+          <line>211</line>
           <option name="timeStamp" value="37" />
         </line-breakpoint>
       </breakpoints>
@@ -271,7 +279,7 @@
     <SUITE FILE_PATH="coverage/Munch$general_tests.coverage" NAME="general_tests Coverage Results" MODIFIED="1649253557839" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/Tests" />
     <SUITE FILE_PATH="coverage/gui_v3_py$game_loop_v2.coverage" NAME="game_loop_v2 Coverage Results" MODIFIED="1614508656597" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/bin/engine" />
     <SUITE FILE_PATH="coverage/Working_git_projects$general_tests.coverage" NAME="general_tests Coverage Results" MODIFIED="1649624272820" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/Tests" />
-    <SUITE FILE_PATH="coverage/Working_git_projects$controller.coverage" NAME="controller Coverage Results" MODIFIED="1649624614204" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/bin/GUI" />
+    <SUITE FILE_PATH="coverage/Working_git_projects$controller.coverage" NAME="controller Coverage Results" MODIFIED="1649971184886" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/bin/GUI" />
     <SUITE FILE_PATH="coverage/gui_v3_py$run.coverage" NAME="run Coverage Results" MODIFIED="1617043566223" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/Working_git_projects$gui_v3.coverage" NAME="gui_v3 Coverage Results" MODIFIED="1606573299996" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/bin/GUI" />
     <SUITE FILE_PATH="coverage/gui_v3_py$gui_variables.coverage" NAME="gui_variables Coverage Results" MODIFIED="1616964872872" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/bin/GUI" />
Index: Munchkin/bin/engine/game_loop_v3.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"Initiates player personalisation and runs game cycle for each player fetching cards and initiation\r\neach scene of play\r\n\r\nContents functions:\r\n    rand * picks single player from list of players\r\n    varbinding * binds all player attribs to IPC script\r\n    dealhandler *\r\n\r\n\r\n\r\n\"\"\"\r\n\r\n\r\n# from Munchkin.bin.players.playermodel import p1, p2, p3, p4, p5, p6, p7, p8, p9, p10 # creates circular\r\n# from Munchkin.bin.engine.game_logic import start_choice as game_logic_start_choice\r\n# from Munchkin.bin.engine import cut_scenes as cs\r\nfrom Munchkin.bin.all_cards.table import cards, dice\r\nfrom random import randint, choice\r\nimport bin.GUI.gui_variables as gameVar\r\nfrom itertools import cycle\r\n\r\nfrom time import sleep\r\n\r\n\r\n##################################################################\r\n# main loop\r\n##################################################################\r\n# first = True\r\n\"\"\" V3.0  \"\"\"\r\n\r\n\r\nclass PlayerSetUp:\r\n    \"\"\"class to determine number of players and hand to player order\"\"\"\r\n\r\n    def __init__(self):\r\n        self.cycle = 0 #needed?\r\n\r\n#meths associated to play\r\n\r\n    def select_players(self): # slices num of available players with gui entry\r\n        \"\"\"called from gui (playersetter method) takes gameVar int and uses to slice list of player instances and binds to new gameVar (active_players).\r\n         deal_handler is called to provide starting number of cards for each player\"\"\"\r\n        num_of_players = gameVar.StartVariables.new_players # get int representing num of players in current session (from spinbox)\r\n        print(f\"Number of players in session: {num_of_players}\") ## GUI test for number acceptance# remove at end. calls __repr__ for each instance\r\n        gameVar.GameObjects.session_players = gameVar.StartVariables.players_available[:num_of_players] # slice creates new list of players in\r\n        # session binding to new variable gamevar\r\n        self.deal_handler(\"start\") # Deals cards to all players. results in putting in player.sack. Does not bind to gameVar\r\n\r\n    def player_name_gender(self, playerindex): # gui attrib, passes session_players index identifying specific instance\r\n        \"\"\"Gets player with list index and Sets name and gender to that player instance.\"\"\"\r\n        player = gameVar.GameObjects.session_players[playerindex] #references a player objects from session_players\r\n        player.char_setup() # call to set name and gender of player instance.\r\n\r\n    def set_random_player(self):\r\n        \"\"\"Selects random player to start from session_players list. Binds player as active_player and calls\r\n        method to load all attributes of the player (player_attrib_ipc_updater(). parameter is optional but explicit)\"\"\"\r\n        player = choice(gameVar.GameObjects.session_players) # selects random player from list of players\r\n        gameVar.GameObjects.active_player = player # assigns the selected player to active player in gamevar for gui to see\r\n        gameVar.GameObjects.message = f\"The dice has been rolled. Random player selected is {player.name.title()}\"\r\n        self.player_attrib_ipc_updater(player) # arg not needed. Calls method to set all attribs in in gamevar of player\r\n\r\n# class Game_Play:\r\n\r\n    def player_order(self, current_player): # called with gameVar rand_index\r\n        \"\"\"Triggered at end of turn. Note 1st player was random and assigned to active_player after player creation.\r\n        Current_player = active player\"\"\"\r\n        play = True # win condition need method that will check all players\r\n        player_gen = cycle(gameVar.GameObjects.session_players) # generator function that cycles a list indefinitely\r\n        y = next(player_gen) # yields players from the list, at start this would be first item = p1.\r\n        while play:\r\n            if current_player == y and current_player.alive: # conditions to see if x==y (x= player, y=list item)\r\n                print(f\"Current player {current_player.name} turn ended\\n\")\r\n                gameVar.GameObjects.active_player = next(player_gen) # binds next player to rand_player, (changes x)\r\n                self.player_attrib_ipc_updater(gameVar.GameObjects.active_player) #  binds new player\r\n                print(f\"{gameVar.GameObjects.active_player.name} has been binded\")\r\n                break\r\n            elif current_player == y and not current_player.alive and not gameVar.Options.perm_death:\r\n                print(f\"print player {current_player} is dead\") # move in to conditional for perm-a-death\r\n                current_player.alive = True # resets player status ##########need per-a-death bit here\r\n                gameVar.GameObjects.active_player = next(player_gen) # changes x without binding and moves to next player\r\n                continue\r\n            else:\r\n                print(f\"{y.name.title()} did not match. Searching for player in list\")\r\n                y = next(player_gen) # changes y to find commonality to x\r\n\r\n        gameVar.GameObjects.message = f\"{gameVar.GameObjects.active_player.name.title()}'s turn...\"\r\n\r\n    def player_attrib_ipc_updater(self, playerinst=gameVar.GameObjects.active_player): # defaults to gamevar active_player player\r\n        \"\"\"Binds all player atribs to gameVar for current player activity. Can take param of a player or grab active_player.\"\"\"\r\n        gameVar.PlayerAtribs.player_name = playerinst.name.title()\r\n        gameVar.PlayerAtribs.player_gender = playerinst.gender.title()\r\n        gameVar.PlayerAtribs.player_level = playerinst.level\r\n        gameVar.PlayerAtribs.player_bonus = playerinst.bonus\r\n        gameVar.PlayerAtribs.player_wallet = playerinst.wallet\r\n        gameVar.PlayerAtribs.player_race = playerinst.race.title()\r\n        gameVar.PlayerAtribs.player_race2 = playerinst.race2.title()\r\n        gameVar.PlayerAtribs.player_klass = playerinst.klass.title()\r\n        gameVar.PlayerAtribs.player_klass2 = playerinst.klass2.title()\r\n        gameVar.PlayerAtribs.player_sack = playerinst.sack\r\n        gameVar.PlayerAtribs.player_l_hand = playerinst.update_bindings(\"L_hand\")\r\n        gameVar.PlayerAtribs.player_r_hand = playerinst.update_bindings(\"R_hand\")\r\n        gameVar.PlayerAtribs.player_two_hand = playerinst.update_bindings(\"two_hand\")\r\n        gameVar.PlayerAtribs.player_headgear = playerinst.update_bindings(\"headgear\")\r\n        gameVar.PlayerAtribs.player_armor = playerinst.update_bindings(\"armor\")\r\n        gameVar.PlayerAtribs.player_knees = playerinst.update_bindings(\"knees\")\r\n        gameVar.PlayerAtribs.player_footgear = playerinst.update_bindings(\"footgear\")\r\n        gameVar.PlayerAtribs.player_necklace = playerinst.update_bindings(\"necklace\")\r\n\r\n# card handling class:\r\n\r\n    def deal_handler(self, option, deal_amount=0):\r\n        \"\"\" Sends requests to the dealer based on the option parameter to define card type.\r\n        Deal_amount defines how many of the cards are to be returned to a player.\r\n        \"\"\"\r\n\r\n        playerinst = gameVar.GameObjects.active_player # gets current player, at start this is none.\r\n\r\n        if option == \"start\": # initial play selector to deal cards to each player. NO GOOD FOR RESURRECT OPTION as deals to all players\r\n            for player in gameVar.GameObjects.session_players: #loops over each player in session_players\r\n                player.sack = cards.card_sop.deal_cards(option, cardnum=gameVar.Options.cards_dealt) # deals cards with params \"start\" & num of cards to deal)\r\n\r\n        elif option == \"door\": # Standard gameplay loop on door kick\r\n            print(\"In deal_handler, retrieving door card & determining fate of card\")  # test location\r\n            door_card = cards.card_sop.deal_cards(option, cardnum=1) # fetches 1 door card,\r\n            return door_card # for pic use only in gui\r\n\r\n        elif option == \"treasure\": # Deal treasure, requires number for amount to deal.\r\n            print(\"retrieving treasure card/s\") # test location\r\n            add_treasure = cards.card_sop.deal_cards(option, cardnum=deal_amount) # cardnum is usually determined by the treasures a monster holds.\r\n            playerinst.sack = playerinst.sack + add_treasure # DUMPS ALL IN THE ACTIVE_PLAYER.....TODO::Sort how treasure is handled when used as currency for another players help\r\n\r\n        elif option == \"resurrect\":\r\n            if gameVar.Options.perm_death:\r\n                playerinst.sack = cards.card_sop.deal_cards(\"start\", cardnum=gameVar.Options.cards_dealt)\r\n            else:\r\n                print(f\"Game over for {playerinst.name}, BUMMER!\")\r\n\r\n        else:\r\n            print(\"option parameter not defined/matched in deal_handler\")\r\n\r\n    def door_card_designator(self, card, door_attempts=1): # for all door cards that are drawn from the pack or placed by another player.\r\n        \"\"\"Takes in door card and door_attempts as params to decide card fate.\r\n        Cards have different fates dependent upon the type of card it is ie: monster, curse, other and the number of\r\n        times the door button is clicked. Also update the message dependent on action\r\n        \"\"\"\r\n        player = gameVar.GameObjects.active_player\r\n\r\n        if door_attempts: #On first kick of the door. Decides what to do with the cards dependent on situation\r\n\r\n            # if monster, put on table ready to fight\r\n            if card.get(\"type\") == \"monster\": # if the cards a monster #1st/2nd kicks covered\r\n                gameVar.GameObjects.message = f\"{card.get('name')} placed on table, Level {card.get('lvl')}\"\r\n                cards.in_play[0].append(card) # places card on table in the lol for the first fight. functionality returned to gui. TODO need downstream processing changed for the fight\r\n                print(\"This is the card in play;\", cards.in_play)\r\n\r\n\r\n            # WORK REQUIRED!!     if curse, activate effects. need check to see if conditions in place to stop cursing ie ork/ wishing ring.\r\n            elif card.get(\"type\") == \"curse\": # if the cards a monster #1st/2nd kicks covered\r\n                gameVar.GameObjects.message = f\"The room you have entered has a curse {card.get('name').title()}.\\n Lets hope you have protection!\"\r\n                print(\"In curse::\", player.active_curses)\r\n                # ~~~~~~~~~~~~~TODO  curse checker method required ie tin hat, ork ect\r\n                if card.get(\"duration\") == \"persistent\": # for constant effect curse\r\n                    player.card_meths(card, \"method\", \"on\") # switches card on.\r\n                    player.active_curses.append(card) # adds card to player curse list so method can be called o remove\r\n                elif card.get(\"duration\") == \"one_shot\": ########### matches card key to the one_shot action\r\n                    player.card_meths(card, \"method\", \"on\")  ########## calls card method and switches it on TO BE REMOVED\r\n                    cards.burn_pile.append(card) # disposes of to burn pile\r\n                    print(f\"card duration is one_shot, added to burn pile check:\\nBurn pile {cards.burn_pile}\")\r\n                elif card.get(\"duration\") == \"timed\": ########## for time dependent effect\r\n                    gameVar.GameObjects.message = f\"timed curse card not configured yet\" # overrides top message\r\n                    #TODO meth for timed\r\n                    cards.burn_pile.append(card) # disposes of to burn pile\r\n                    print(f\"card status is passive, should be added to burn pile!\\nBurn pile {cards.burn_pile}\")\r\n\r\n            else: # for all other cards that have no direct effect or influence.\r\n                print(f\"Adding {card['name']}to sack.\")\r\n                player.sack.append(card)  # adds card to player's items\r\n                gameVar.GameObjects.message = f\"Adding 2nd draw to sack.\" # need to be removed dont want to broadcast what other player gets\r\n                return card  # to show if first time only 2nd it hides\r\n\r\n        else:\r\n            \"2nd kick of door (looting room). Will need condition statement if player wants to fight mon from hand, rather than std flow to sack\"\r\n            print(\"adding to sack\")\r\n            gameVar.GameObjects.message = \"2nd kck, Adding card to sack\"  # 2nd kick\r\n            player.sack.append(card)  # adds to player sack\r\n\r\n    def card_method_activator(self, scenario, action, table_card_index): # will need to be a selector\r\n        \"\"\"method to activate a card dependent upon the scenario of having a specific monster/ curse/ item in play and action to\r\n        switch on or off the condition\"\"\"\r\n        card = cards.in_play[int(table_card_index)] # selects the monster in the fight on the table\r\n        player = gameVar.GameObjects.active_player\r\n        if scenario == \"persistent\":\r\n            player.card_meths(card, 'static', action)  ######## will cause probs with monster individuality ######################\r\n\r\n\r\n\r\n\r\n    def zipper(self, action):\r\n        \"\"\"zips card id's to checkbox bools from selected_list. Used for all card sorting regardless of card type.\r\n        action is conduit for card_matcher\"\"\"\r\n        gameVar.GameObjects.zipped_tup.clear()  # clears tup list ready for new entry. not working...................\r\n        for status in gameVar.GameObjects.check_but_intvar_gen: # gets attribute from object then from the attribute which is an object gets the value stored (list>intvar>get()>1 or 0)\r\n            gameVar.GameObjects.check_but_boo.append(status.get()) # creates a list of 1s & 0s from check buttons status\r\n            x, y = gameVar.GameObjects.check_but_card_ids, gameVar.GameObjects.check_but_boo\r\n            gameVar.GameObjects.zipped_tup = list(zip(x, y)) # result [(card_id,  bool), (card_id, bool)]\r\n        # print(\"moving to player script\", gameVar.GameObjects.zipped_tup) # checker shows all cleared lists\r\n        self.card_matcher(action)\r\n\r\n    def card_matcher(self, action):\r\n        \"\"\"compares tuple to selected_items searching for matching card ids and only passes on cards that contain\r\n        a tuple with the boolean true. Action determines the whats happening to the cards next. \"\"\"\r\n        for card in gameVar.GameObjects.selected_items: # for every card in selected_items\r\n            for tup in gameVar.GameObjects.zipped_tup: # go over every tuple in  zipped_tup. (card_id, bool tuples).\r\n                if tup[0] == card[\"id\"] and tup[1]: # if tup id matches card fid from selected items and bool is True from the checkbox\r\n                    if action == \"sell\":\r\n                        gameVar.GameObjects.active_player.sell_item(card)\r\n                    elif action in \"equip, disposable ,use\": # equip/disposable will be treasures\r\n                        self.tri_qualifier(card) # test ~~ok~~\r\n                    elif action == \"remove\":\r\n                        player = gameVar.GameObjects.active_player\r\n                        player.equipped_items(\"removal\", card)\r\n\r\n    def tri_qualifier(self, card):\r\n        \"\"\" Checks player attribs against an item card before it can be used by the player. Split into 2 parts:\r\n        1st: checks card for a specific restriction that would count against a player due to a specific attrib, ie if u are human u cant use this card.\r\n        2nd part: \"\"\"\r\n\r\n        player = gameVar.GameObjects.active_player\r\n\r\n        checks = {player.race: \"race_requirement\", player.race2: \"race_requirement\", player.klass: \"klass_requirement\",\r\n                  player.klass2: \"klass_requirement\", player.gender: \"gender_requirement\"} # card specific requirements to use\r\n        flag = 1 # True\r\n\r\n        for player_attribs, card_requirement in checks.items():\r\n            # checks card restrict method lexical for non use cases. If found player cant use.\r\n            if card.get('restriction', False): # checks to see if there is a key named 'restriction' in card if not return False\r\n                print(\"Searching card restriction method\")\r\n                if player_attribs in card.get('restriction'):  # checks all player attribs to see if in restricted treasure card list #\r\n                    # THINK ABOUT CARDS YOU ARE APPLYING THEM TOO; TREASURE!\r\n                    print('Restriction found in card')\r\n                    if player.name == \"The_Creator\":  # dev mode\r\n                        print(f\"{player_attribs} - Restriction avoided: Dev path\")\r\n                        break\r\n                    else: # sets flag so card cant be used\r\n                        print('Restricted, card cant be used.')\r\n                        flag = 0\r\n                        break\r\n            # checks cards for player dependent attribs to use card\r\n            if card.get(card_requirement):  # checks card to see if requirement present\r\n                if card.get(card_requirement) == player_attribs: # if race_requirement = 'human' == player.race = 'human' change flag and break out of loop\r\n                    print(f\"Main path for: {card_requirement}\")\r\n                    continue # checks next requirement parameter for conformance\r\n                elif player.name == \"The_Creator\":  # dev mode\r\n                    print(f\"{player_attribs} - Dev path\")\r\n                    continue\r\n                else:\r\n                    gameVar.GameObjects.message = f\"You cant use this card, {card_requirement}\"\r\n                    flag = 0\r\n                    # gameVar.StartVariables.message = f\"{card.get('name')} can not be quipped: {val}.\" # not working\r\n                    break\r\n\r\n        if flag: # only if flag remains True, compliant to non restrictions.\r\n            if card[\"category\"] == \"treasure\":  # for all treasure cards the player uses that was from their hand\r\n                self.player_treasure_cards(card) # for the use of treasure cards\r\n            # elif card[\"category\"] == \"door\":  # for all enhancers ect that the player has from their hand  DO DOOR CARDS REALLY COME DOWN THIS ROUTE! however thowables???\r\n            #     self.player_door_cards(card) # for the use of door cards\r\n\r\n    def player_treasure_cards(self, card):\r\n        \"\"\"method to sort the locations of treasure cards that the player has selected\"\"\"\r\n        player = gameVar.GameObjects.active_player\r\n        if card.get(\"type\") == \"armor\":\r\n            player.equip_armor(card)  # leads to player meth for placing in right place\r\n        elif card.get(\"type\") == \"weapon\":\r\n            player.equip_weapon(card)\r\n        elif card.get(\"type\") == \"disposable\":  # for disposable throwable only\r\n            pass  # meth for selecting target and changing bonuses, # TODO\r\n        else:\r\n            pass # for all other cards ie steeds\r\n\r\n    def player_door_cards(self, card): #card meth#####################################################\r\n        player = gameVar.GameObjects.active_player\r\n        player.card_meths(card, \"method\", \"on\")  # link to player to card meths.\r\n        print(player.klass_unlock, player.race_unlock)  # only shows at end of turn due to meth restriction in class,\r\n        # meths added at end_turn\r\n\r\n    def scrub_lists(self):\r\n        \"\"\"Clears all appended list that are not capable of clearing.\"\"\"\r\n        gameVar.GameObjects.selected_items.clear()  # clears the card objects list\r\n        gameVar.GameObjects.check_but_intvar_gen.clear()  # clears list of intVar objects from check buttons\r\n        gameVar.GameObjects.check_but_boo.clear()  # clears boolean list\r\n        gameVar.GameObjects.check_but_card_ids.clear()  # clears card id list\r\n        gameVar.GameObjects.zipped_tup.clear()  # clears tup list\r\n\r\n##################################################################\r\n    def fight(self, helper=0, additional=0):# helper would be other player interactions. additional is anything else\r\n        \"\"\"for cards that are monsters and placed on the table\"\"\"\r\n        print(\"In the fight!\")\r\n        card = cards.in_play.pop() # end of cards on table\r\n        player = gameVar.GameObjects.active_player\r\n        player.card_meths(card, 'static', 'on') # turns on card static content for fight TODO change to something more relevant than \"static\"\r\n        if player.bonus + player.level + helper + gameVar.Fight_enhancers.player_aid \\\r\n                >= card[\"lvl\"] + gameVar.Fight_enhancers.monster_aid: # consideration required for player consumables and enhancers\r\n            print(\"Player wins!\")\r\n            reward = card['treasure']\r\n            self.deal_handler('treasure', deal_amount=reward) # fetches treasure for player\r\n            gameVar.GameObjects.message = f\"You win! You have found {reward} treasures for your trouble.\"\r\n            player.level += card[\"level_up\"]\r\n            cards.burn_pile.append(card) # removes card\r\n            player.card_meths(card, 'static', 'off') # turns off static card content\r\n            print(f\"cards in the burn pile: {len(cards.burn_pile)}\")\r\n            return \"win\"\r\n        # need action to go up lvl note some cards do more than one level!\r\n        else:\r\n            gameVar.GameObjects.message = \"Fight lost\"\r\n            print(\"Fight lost\")\r\n            player.card_meths(card, 'method', 'on') # calls card bad stuff\r\n            player.card_meths(card, 'static', 'off') # turns off static effect of card in play\r\n            return \"lose\"\r\n\r\n    def run(self):\r\n        roll = dice.dice_sop.roll()\r\n        player = gameVar.GameObjects.active_player\r\n        print(f\"You rolled a {roll}.\")\r\n        if roll >= player.run:\r\n            print(f\"You rolled a {roll}. You out ran your pursuer.\")\r\n            remove = cards.in_play.pop(0)\r\n            player.card_meths(remove, 'static', 'off')# turns off static card content\r\n            cards.burn_pile.append(remove)\r\n            return \"success\"\r\n        else:\r\n            print(\"Tried to run and slipped. Things are gona get ugly!\\n\")\r\n            # only fight is available now so that cna handle all the logic\r\n            return \"fail\"\r\n\r\nengine = PlayerSetUp()\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    # NumberOfPlayers().select_players() # starts game by activating NOP building the objects, and activating select_players\r\n    # running wach line.\r\n    engine.player_name_gender()\r\n\r\n\r\n\r\n\r\n\r\n\r\n# old\r\n# def door_card_designator(self, card, door_attempts=1):  # for all door cards that are drawn from the pack\r\n#     \"\"\"method that sort the cards that the player draws from the deck during play. This could be monster, curse ect.\r\n#     door0-attempts is used to determine how many times the door has been kicked in a turn and in 2nd instance the door is put into the\r\n#     players hand unseen. Mechanism is also used to trigger a curse\r\n#     \"\"\"\r\n#     player = gameVar.GameObjects.active_player\r\n#\r\n#     if door_attempts:\r\n#         if card.get(\"type\") == \"monster\":  # if the cards a monster #1st/2nd kicks covered\r\n#             if door_attempts:  # determines if first kick of door (T or F), if 1 = first kick\r\n#                 gameVar.GameObjects.message = f\"{card.get('name')} placed on table, Level {card.get('lvl')}\"\r\n#                 cards.in_play.append(\r\n#                     card)  # adds to table # careful as cards selected from hand will go strait to table\r\n#                 print(\r\n#                     f\"In door_card_designator, monster added to table. Returned card is: {[x['name'] for x in cards.in_play]}\\n\")\r\n#             else:\r\n#                 print(\"adding to sack\")\r\n#                 gameVar.GameObjects.message = \"Adding card to sack\"  # 2nd kick\r\n#                 player.sack.append(card)  # adds to player sack\r\n#\r\n#         elif card.get(\"type\") == \"curse\":  # if the cards a monster #1st/2nd kicks covered\r\n#             if door_attempts:  # 1st kick\r\n#                 print(\"In curse::\", player.curses)\r\n#                 gameVar.GameObjects.message = \"You have been cursed!\"  # look at card meth and action\r\n#                 player.card_meths(card, \"method\", \"on\")  # actions curs card as soon as picked up\r\n#                 if card.get(\"status\") == \"active\":  # for constant effect curse\r\n#                     player.curses.append(card)  # adds card to player curse list\r\n#                 elif card.get(\"status\") == \"passive\":  # for one shot effect\r\n#                     cards.burn_pile.append(card)  # disposes of to burn pile\r\n#                     print(f\"card status is passive, should be added to burn pile!\\nBurn pile {cards.burn_pile}\")\r\n#             else:\r\n#                 gameVar.GameObjects.message = \"Adding card to sack\"\r\n#                 player.sack.append(card)\r\n#\r\n#         else:  # for all other cards that have no direct effect or influence.\r\n#             print(f\"Adding {card['name']}to sack.\")\r\n#             if door_attempts:\r\n#                 player.sack.append(card)  # adds card to player's items\r\n#                 gameVar.GameObjects.message = f\"Adding/using {card.get('name')}.\"\r\n#                 return card  # to show if first time only 2nd it hides\r\n#             else:\r\n#                 gameVar.GameObjects.message = \"Adding 2nd card to sack\"\r\n#                 player.sack.append(card)\r\n
===================================================================
diff --git a/Munchkin/bin/engine/game_loop_v3.py b/Munchkin/bin/engine/game_loop_v3.py
--- a/Munchkin/bin/engine/game_loop_v3.py	
+++ b/Munchkin/bin/engine/game_loop_v3.py	
@@ -41,7 +41,7 @@
         """called from gui (playersetter method) takes gameVar int and uses to slice list of player instances and binds to new gameVar (active_players).
          deal_handler is called to provide starting number of cards for each player"""
         num_of_players = gameVar.StartVariables.new_players # get int representing num of players in current session (from spinbox)
-        print(f"Number of players in session: {num_of_players}") ## GUI test for number acceptance# remove at end. calls __repr__ for each instance
+        print(f"Number of players in session: {num_of_players}") # GUI test for number acceptance # remove at end. calls __repr__ for each instance
         gameVar.GameObjects.session_players = gameVar.StartVariables.players_available[:num_of_players] # slice creates new list of players in
         # session binding to new variable gamevar
         self.deal_handler("start") # Deals cards to all players. results in putting in player.sack. Does not bind to gameVar
@@ -192,9 +192,6 @@
         if scenario == "persistent":
             player.card_meths(card, 'static', action)  ######## will cause probs with monster individuality ######################
 
-
-
-
     def zipper(self, action):
         """zips card id's to checkbox bools from selected_list. Used for all card sorting regardless of card type.
         action is conduit for card_matcher"""
