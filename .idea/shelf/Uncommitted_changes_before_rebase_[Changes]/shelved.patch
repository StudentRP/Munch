Index: Munchkin/bin/players/playermodel.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nClass to build model players and assign new attributes associated with cards through gameplay.\n\nConsider what the player class is responsible for...\n\nConsiderations:\n    Player model\n    player setup name & gender\n    Death and reset\n    accessing player and changing player resources\n    save -- most likely shelve objects\n    stats access\n\n\"\"\"\n\n\nfrom Munchkin.bin.all_cards.table import Table # most likely not used here (pos for cross talk bypassing circular\n# import but may require for adding to player inventory and stats (note same card in engine will return here)\nfrom Munchkin.bin.all_cards.treasure_cards.treasurecards import Treasure\n\nfrom Munchkin.bin.players.playersetup import P_tools # OF LITTLE USE. Methods name/gender moved to this script.\nimport bin.GUI.variables_library as library\n# from bin.all_cards.table import cards\nfrom bin.GUI.variables_library import cards # single location to same memory address\nfrom bin.all_cards.door_cards.doorcards import MonTools\nfrom bin.all_cards.treasure_cards.treasurecards import T_tools\nfrom itertools import cycle\n\n\"\"\"This is the player class. It will have all setting to configure players and modify attributes that are set to that\nplayer. It will inherit from moncurse and treasure so that a player can add items to their attributes and modify\nattributes based on action outcomes.\"\"\"\n\n#####################################################################\n# MAIN PLAYER CLASS\n#####################################################################\n\n\nclass Player(MonTools, T_tools):\n    \"\"\"Main player class, inherits off card methods making changes to the player.\"\"\"\n    num_of_instances = 0\n\n    def __init__(self):\n        Player.num_of_instances = Player.num_of_instances + 1\n        self.ref = Player.num_of_instances\n        self.name = \"\"\n        self.gender = \"male\" # default required..dont think it works like this...\n        self.level = 1 # win lvl 10, make changeable so edit score to win\n        self.bonus = 0\n        self.wallet = 0\n        self.race = \"human\" # string eval to True so will show\n        self.race2 = \"\"\n        self.race_unlock = False # DEFAULT = False method by halfbread triggers this a True state (method to be added)\n        self.klass = \"No class\"\n        self.klass2 = \"\"\n        self.klass_unlock = False # method by supermunchkin triggers this a True state\n        self.big = \"\" # can carry only 1 big item\n        self.big2 = []\n        self.big_unlock = False\n        self.weapons = {\"L_hand\": \"\", \"R_hand\": \"\", \"two_hand\": \"\"} # values will be cards\n        self.weapon_count = 2  # 1 per hand, can add to with cheat. adding +=, removal -=.\n        self.armor = {\"headgear\": \"\", \"armor\": \"\", \"knees\": \"\", \"footgear\": {'testcard': 'armor'},\n                      \"necklace\": \"\", \"ring\": \"\", \"ring2\": \"\"}\n        self.sack = [] # 5 max, editable in options\n        self.hireling = []\n        # self.unsorted = [] # Old! list of all cards that are used to by sorting\n        self.alive = True\n        self.longevity = 0 # counts cycles alive, if 0 player misses go\n        self.cheat = 0 # set to false\n        self.cheat_card = 0 # card the player is cheating with\n        self.enhancer_cards = []  # cards that elicit an effect ie supermunch/class card, ect. card lexical must be added to enhancer lexical\n        self.enhancers_lexical = set() # all positive effects strings for comparative evaluation. only added when card installed on player.\n        self.active_curses = []  # place to store all curse cards effecting player. card remove meth should reverse player change\n        self.negative_lexical = set() # all negative effects strings for comparative evaluation. only added when card installed on player.\n        self.run = 4 # ability to run, manipulable. note elf must change this. !!! use as bool and escape value!\n        self.run_away = True # locks ability toi run or not dependent on some monsters\n\n    def __repr__(self):\n        \"\"\"developer aid\"\"\"\n        return f\"\\nPLAYER Ref:{self.ref}\\nName:{self.name}\\nGender:{self.gender}\\nLevel:{self.level}\" \\\n               f\"\\nBonus:{self.bonus}\\nSack:{self.wallet}\\n\"\n\n    @classmethod\n    def factory(cls):\n        return Player()\n\n    @classmethod\n    def gender(cls):\n        \"\"\"Sets gender\"\"\"\n        x = library.PlayerAttribs.player_gender # grabs string stored in in game var\n        return x\n\n    @classmethod\n    def name(cls):\n        \"\"\"Sets name\"\"\"\n        x = library.PlayerAttribs.player_name\n        if x == \"rory\":  # ......................................................................... dev mode\n            y = \"The_Creator\"\n            return y\n        return x\n\n    def update_bindings(self, carried):\n        \"\"\"just gets whats attached to the player\"\"\"\n        category = [self.weapons, self.armor]  # locations to search\n        for sub_cat in category:  # is the dict as a whole\n            for key in sub_cat:\n                if isinstance(sub_cat[key], dict) and key == carried:\n                    # gameVar.GameObjects.message = f'{sub_cat.get(key).get(\"name\")} has been bound to {key}'\n                    return sub_cat.get(key).get(\"name\")\n\n    def char_setup(self):\n        # complete, prints to be removed\n        \"\"\"sets up name and gender in gameVar and player instance when called\"\"\"\n        na = Player.name() # method to set name\n        self.name = na  # makes change to player\n        xy = Player.gender()\n        self.gender = xy\n\n        if self.name == \"The_Creator\": # ................................................................... dev mode\n            self.gender = \"bob\"\n            self.bonus = 200\n            self.wallet = 20000\n            library.PlayerAttribs.player_gender = self.gender\n            library.GameObjects.message2 = f\"{self.name} is in play, A God among mortals!\"\n\n        #~~~~~~~~~~~~ info\n        print(f\"The player {self.name.title()} with the gender {self.gender.title()} has been created.\")\n        # ~~~~~~~~~~~~\n\n    def inventory(self, key, cardtype): # called from GUI on button press\n        \"\"\"Returns list of dict from player sack cards that have a specific key and specific value.\n        (ie sub_type == armour). returns all sub_types with the val of armor\"\"\"\n        library.GameObjects.selected_items = [obj for obj in self.sack if obj[key] == cardtype]\n\n    def item_by_key(self, key):# generalised meth for key search\n        \"\"\"Returns list of cards form player sack list that contain the key x. (ie \"sell\").\n        This is generalised meth for key search \"\"\"\n        library.GameObjects.selected_items = [obj for obj in self.sack if obj.get(key)]\n\n    def sell_item(self, card): # called by player.sell_item so self bound to player\n        \"\"\"Call from zipper to sell items, remove cards, reset gameVars and call to add to burn pile\"\"\"\n        self.wallet += card[\"sell\"] #adds worth of card to player\n        library.GameObjects.message = f\"Selling sack {card['name']}, Card added to burn pile. Depth: {len(cards.burn_pile)}\"\n        x = self.sack.pop(self.sack.index(card)) # removes card from player sack deck\n        cards.add_to_burn(x)# adds card to burn pile on table\n        library.GameObjects.message = f\"Selling sack {card['name']}, \" \\\n                                      f\"\\nCard added to burn pile. Depth: {len(cards.burn_pile)}\"\n        # print(\"tup list: \", gameVar.GameObjects.zipped_tup)\n\n    def sum_of_bonuses(self): # pos multi usage and use as player item searcher. limited by equipped_items as caller\n        \"\"\" Adds up all bonuses and bind to player in weapons and armour\"\"\"\n        tot_bonus = 0\n        locations = [self.weapons, self.armor] #locations to search\n        for obj in locations: # looks at each object in list\n            for sub_menu in obj:\n                if isinstance(obj[sub_menu], dict): #checks submenu for card attachment in the form of a dict\n                    # print(obj.get(sub_menu, \"No sub menu\").get(\"bonus\", \"No bonus found\"))\n                    tot_bonus += obj.get(sub_menu, \"\").get(\"bonus\", \"Problem getting bonus\")\n                    continue\n        if self.name == \"The_Creator\":\n            tot_bonus = 200 + tot_bonus\n        self.bonus = tot_bonus\n\n    def equipped_items(self, action, my_cards=None, card_id=None): # in use by gui list_equipped meth\n        \"\"\"Shows all items that have been equipped to the player. If remove, Sorts through equipped items,\n        removing items that have been selected\"\"\"\n        locations = [self.weapons, self.armor]  # locations to search\n        for obj in locations:  # looks at each object in list. obj is the dict of all the poss locations as seen in player attrbs\n            for sub_menu in obj:  # sub_menu is the keys which link to the card is placed in: armor = {}\n                if isinstance(obj[sub_menu], dict):  # checks submenu for card attachment in the form of a dict\n                    card = obj.get(sub_menu) # x is the card object\n                    if action == \"list_equipped\":\n                        library.GameObjects.selected_items.append(card) #adds cards to selected_items list in gameVar\n                        continue\n                    elif action == \"removal\":\n                        if card[\"id\"] == my_cards[\"id\"]:\n                            self.sack.append(card) # adds card back to player inventory\n                            obj[sub_menu] = \"\" # resets player atrib location\n                            self.sum_of_bonuses() # recalculates bonuses\n                            self.weapon_count += card.get(\"hold_weight\", 0) # adds the cards carry_weight for available hands, if available.\n                            continue\n                    elif action == \"curse\": # not tested\n                        print(\"In equipped items remove cursed item\")\n                        pass\n\n    def equip_armor(self, card):\n        \"\"\" Equips armor to the player\"\"\"\n        location = self.armor\n        print(\"in armor\")\n        for sub_type in location.keys():\n            if card[\"sub_type\"] == sub_type:  # matches card[\"sub_type] to list\n                occupied = isinstance(self.armor[sub_type], dict)\n                if not occupied:\n                    x = self.sack.pop(self.sack.index(card))  # removes cards from sack list\n                    self.armor[sub_type] = x  # adds to player's attribs\n                    break\n                elif occupied:\n                    card_removed = self.armor.pop(sub_type)  # removing card from player's attrib\n                    self.sack.append(card_removed)\n                    x = self.sack.pop(self.sack.index(card))  # removes cards from sack list\n                    self.armor[sub_type] = x  # binds now card to player attribute\n                    break\n        library.GameObjects.message = f\"Equipping {card['name']}\"\n        self.sum_of_bonuses()\n\n    def equip_weapon(self, card):\n        \"\"\"New simplified model. Checks L/R hands to see if full, equipping if not.\n        Two hand items will not work when other hands full. \"\"\"\n        if self.weapon_count > 0:\n            if card[\"sub_type\"] == \"1hand\" and not isinstance(self.weapons[\"L_hand\"], dict): # if 1handed weap and no card in players left hand...\n                added_card = self.sack.pop(self.sack.index(card)) # gets list index for pop by calling index() on object thus returning index\n                self.weapons[\"L_hand\"] = added_card\n                self.weapon_count -= card.get(\"hold_weight\")\n                library.GameObjects.message = f\"Equipping {card['name']} to left hand\"\n            elif card[\"sub_type\"] == \"1hand\" and not isinstance(self.weapons[\"R_hand\"], dict): # not equipped\n                library.GameObjects.message = f\"Equipping {card['name']} to right hand\"\n                added_card = self.sack.pop(self.sack.index(card))\n                self.weapons[\"R_hand\"] = added_card\n                self.weapon_count -= card.get(\"hold_weight\")\n            elif card[\"sub_type\"] == \"2hand\" and not isinstance(self.weapons[\"two_hand\"], dict):\n                if isinstance(self.weapons[\"L_hand\"], dict) or isinstance(self.weapons[\"R_hand\"], dict):\n                    library.GameObjects.message = \"You can not equip this item while you have items in your other hands\"\n                elif not isinstance(self.weapons[\"L_hand\"], dict) and not isinstance(self.weapons[\"R_hand\"], dict):\n                    library.GameObjects.message = f\"Equipping {card['name']} to both hands\"\n                    added_card = self.sack.pop(self.sack.index(card))\n                    self.weapons[\"two_hand\"] = added_card\n                    self.weapon_count -= card.get(\"hold_weight\")\n            else: # cheat card section/ big item\n                pass\n        else:\n            library.GameObjects.message = \"You are at max capacity. Remove some weapons to attach others!\"\n        print(\"capacity count\", self.weapon_count)\n        self.sum_of_bonuses()\n\n    def card_meths(self, *args, **kwargs): # expects (card/s) dict('static'='on')\n        \"\"\" link to card methods, args should be the card/s, kwards the different card meths and actions to take\n        ie 'static':'on' \"\"\"\n        print(f\"In player card_meth. Num of cards: {len(args)}, kwargs: {kwargs}\") # args are the cards sent, info on meth used and status\n        for method, state in kwargs.items(): # loops supplied kwards which contain card meth search and an action to take\n            print(f'Card is {args[0][\"name\"]}. Searching for a {method} method')\n            if args[0].get(method): # checks 1st card in args for the kward key method\n                for listed_meth in args[0].get(method): # loops over the list values. \"static\": [\"no_outrun\", 'test_meth']\n                    print(listed_meth) # leave in to make sure I made it a list!!! TEST\n                    if listed_meth in MonTools.method_types: # checks if method (the value from above) is in monster_types dict\n                        method_call = MonTools.method_types.get(listed_meth) # returns method associated to the value of monster_types\n                        dispose_card = method_call(self, state, args[1:]) # returns None, or [card_destination, card] method_call(self, on, all other cards in the tuple)\n\n                        if dispose_card: # screens out non types. Received args back are in form of list when given. ['burn', removed_item]\n                            if dispose_card[0] == 'burn':\n                                cards.add_to_burn(dispose_card[1]) # recycles any card that has been removed from a player from a method\n                            elif dispose_card[0] == 'wondering':\n                                print(' are wee here?')\n                                cards.in_play.append(dispose_card[1]) # places new monster on table\n                                cards.add_to_burn(args[0]) # disposes of original card ie wandering monster card\n                            elif dispose_card[0] == 'enhancer':\n                                cards.add_to_burn(args[0])\n                                return dispose_card[1] # returns to caller for processing further, usually enhancer to monster will be added to specific fight\n\n\n\n    # def card_meths(self, *args, **kwargs): #card meth to take in all card formats whether as single card/series of cards or presented as a list of cards\n    #     \"\"\" link to card methods, args should be the card, kwards the different card meths and actions to take\n    #     ie 'static':'on' \"\"\"\n    #     print(f\"In player card_meth. Args: {args}, kwargs: {kwargs}\") #  args are the cards sent, info on meth used and status\n    #\n    #     for cardset in args: # takes in as many cards in args tuple. Also works if cards are wrapped in list\n    #         for card in cardset: # if args list of cards iterates over each card, IF single card iterates over the keys!\n    #             for k, v in kwargs.items(): # loops supplied kwards which contain card meth search and an action to take\n    #                 print(k, v)\n    #                 # if k in card: # 1st arg of tuple. Looks for kward key in provided card. ie is there a static key in card? (kward key == card key)\n    #                 print('card is', card)\n    #                 print(f'confirmed match of {k}')\n    #                 if isinstance(cardset, list):\n    #                     method = card.get(k) # gets method of the found key in card ie static : no_run........ THIS COULD VERY EASILY BE A LIST THAT CAN BE LOOPED OVER TO IMPLEMENT SEVERAL METHS\n    #                 else:\n    #                     method = cardset.get(k)\n    #\n    #                 for action in method: # loops over the list value  in card provided by the key.\n    #                     print(f\"this card has {method} methods that will all be {v}\")\n    #                     if action in MonTools.method_types: # checks to see if method (the value from above) is in dict\n    #                             method_call = MonTools.method_types.get(action)\n    #                             method_call(self, k, v) # self=player, static, on .. need to think. do i need the k? am i only supplying the values: on, off, ect\n\n\n\n\n\n\"\"\"\ncard meth to handle curse, monsters ect. must handle both a static action and methods associated to add and remove.\ncalls required from; player select card, door kick for static ie no run, and loose scenario  \n\n\n\"\"\"\n\n\nif __name__ == '__main__':\n    p1 = Player()\n    print(p1)\n    # p1.get_treasure() # duplicate val is print state from Handler class method (note is same: GOOD)\n    # p1.char_setup() # calls player name/gender setup, to be called after player number select\n    # p1.inventory() # shows inventory of new built char\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/players/playermodel.py b/Munchkin/bin/players/playermodel.py
--- a/Munchkin/bin/players/playermodel.py	(revision 1b5271f872c8f8de72bbcbd0e215f2a8cf578c1e)
+++ b/Munchkin/bin/players/playermodel.py	(date 1650894771608)
@@ -146,7 +146,8 @@
                                       f"\nCard added to burn pile. Depth: {len(cards.burn_pile)}"
         # print("tup list: ", gameVar.GameObjects.zipped_tup)
 
-    def sum_of_bonuses(self): # pos multi usage and use as player item searcher. limited by equipped_items as caller
+    def sum_of_bonuses(self): # pos multi usage and use as player item searcher. limited by equipped_items as caller ############
+        # TODO: DISSOLVE THIS METH ONTO THE CARD_METH FOR ACTIVATION WITH METHOD='ON'/'OFF') TO MAKE CHANGES TO PLAYER
         """ Adds up all bonuses and bind to player in weapons and armour"""
         tot_bonus = 0
         locations = [self.weapons, self.armor] #locations to search
@@ -174,6 +175,7 @@
                     elif action == "removal":
                         if card["id"] == my_cards["id"]:
                             self.sack.append(card) # adds card back to player inventory
+                            # self.card_meths(card, method='off') ################################### NEED SWITCHING ON WHEN ARMOUR METHS HAVE BEEN SORTED
                             obj[sub_menu] = "" # resets player atrib location
                             self.sum_of_bonuses() # recalculates bonuses
                             self.weapon_count += card.get("hold_weight", 0) # adds the cards carry_weight for available hands, if available.
@@ -195,10 +197,13 @@
                     break
                 elif occupied:
                     card_removed = self.armor.pop(sub_type)  # removing card from player's attrib
+                    # self.card_meths(card_removed, method='off') # switches off card meths ################################### NEED SWITCHING ON WHEN ARMOUR METHS HAVE BEEN SORTED
                     self.sack.append(card_removed)
                     x = self.sack.pop(self.sack.index(card))  # removes cards from sack list
                     self.armor[sub_type] = x  # binds now card to player attribute
                     break
+
+        # self.card_meths(card, method='on') # switches card meths on################################### NEED SWITCHING ON WHEN ARMOUR METHS HAVE BEEN SORTED
         library.GameObjects.message = f"Equipping {card['name']}"
         self.sum_of_bonuses()
 
@@ -237,13 +242,15 @@
         print(f"In player card_meth. Num of cards: {len(args)}, kwargs: {kwargs}") # args are the cards sent, info on meth used and status
         for method, state in kwargs.items(): # loops supplied kwards which contain card meth search and an action to take
             print(f'Card is {args[0]["name"]}. Searching for a {method} method')
-            if args[0].get(method): # checks 1st card in args for the kward key method
-                for listed_meth in args[0].get(method): # loops over the list values. "static": ["no_outrun", 'test_meth']
-                    print(listed_meth) # leave in to make sure I made it a list!!! TEST
-                    if listed_meth in MonTools.method_types: # checks if method (the value from above) is in monster_types dict
-                        method_call = MonTools.method_types.get(listed_meth) # returns method associated to the value of monster_types
-                        dispose_card = method_call(self, state, args[1:]) # returns None, or [card_destination, card] method_call(self, on, all other cards in the tuple)
+            if args[0].get(method, 'no meth found'): # checks 1st card in args for the kward key method ( 1st card is the 1 to action, any others are for work later on).
+                for listed_meth in args[0].get(method): # loops over the list the key returns. ie: "static": ["no_outrun", 'test_meth']
+                    print(listed_meth) # leave in to make sure I made it a list!!! ******* TEST PRINT
+                    if listed_meth in MonTools.method_types: # checks if method (the value from above) is in monster_types dict     (we can pretty much garentee the meth will be in the list...)
+                        method_call = MonTools.method_types.get(listed_meth) # returns method associated to the value of monster_types WILL NEED ANOTHER CONDITIONAL DEPENDENT ON CARD TYPE
+                        dispose_card = method_call(self, state, args[1:]) # pushes any other cards to the fist cards methods.
+                        # returns None, or [card_destination, card] method_call(self, on, all other cards in the tuple)
 
+                        # handle returned objects
                         if dispose_card: # screens out non types. Received args back are in form of list when given. ['burn', removed_item]
                             if dispose_card[0] == 'burn':
                                 cards.add_to_burn(dispose_card[1]) # recycles any card that has been removed from a player from a method
Index: Munchkin/bin/engine/controller.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nController provudes backend logic to the view script and makes changes to variable library\nInitiates player personalisation and runs game cycle for each player fetching cards and initiation\neach scene of play\n\nContents functions:\n    rand * picks single player from list of players\n    varbinding * binds all player attribs to IPC script\n    dealhandler *\n\n\n\n\"\"\"\n\n\nfrom Munchkin.bin.players.playermodel import Player\nfrom Munchkin.bin.all_cards.table import dice # , cards\nfrom random import randint, choice\nimport bin.GUI.variables_library as library\nfrom itertools import cycle\n\nfrom bin.GUI.variables_library import cards\nprint('controller', id(library.cards))\nfrom time import sleep\n\n\n\n\n##################################################################\n# main loop\n##################################################################\n\"\"\" V4.0  \"\"\"\n\n\nclass PlayerSetUp:\n    \"\"\"class to determine number of players and hand to player order\"\"\"\n    card_from_engine = cards\n\n    def __init__(self):\n        self.cycle = 0 #needed?\n\n# meths associated to play setup\n\n    def active_player_creation(self):\n        \"\"\" calls Player.factory creating player instances\"\"\"\n        for person in range(library.StartVariables.new_players):\n            player = Player.factory()\n            library.GameObjects.session_players.append(player)\n        self.deal_handler(\"start\")\n\n    def player_name_gender(self, playerindex): # gui attrib, passes session_players index identifying specific instance\n        \"\"\"Gets player with list index and Sets name and gender to that player instance.\"\"\"\n        player = library.GameObjects.session_players[playerindex] #references a player objects from session_players\n        player.char_setup() # call to set name and gender of player instance.\n\n    def set_random_player(self):\n        \"\"\"Selects random player to start from session_players list. Binds player as active_player and calls\n        method to load all attributes of the player (player_attrib_ipc_updater(). parameter is optional but explicit)\"\"\"\n        player = choice(library.GameObjects.session_players) # selects random player from list of players\n        library.GameObjects.active_player = player # assigns the selected player to active player in gamevar for gui to see\n        library.GameObjects.message = f\"The dice has been rolled. Random player selected is {player.name.title()}\"\n        self.player_attrib_ipc_updater(player) # arg not needed. Calls method to set all attribs in in gamevar of player\n\n# class Game_Play:\n\n    def player_order(self, current_player): # called with gameVar rand_index\n        \"\"\"Triggered at end of turn. Note 1st player was random and assigned to active_player after player creation.\n        Current_player = active player\"\"\"\n        play = True # win condition need method that will check all players\n        player_gen = cycle(library.GameObjects.session_players) # generator function that cycles a list indefinitely\n        y = next(player_gen) # yields players from the list, at start this would be first item = p1.\n        while play:\n            if current_player == y and current_player.alive: # conditions to see if x==y (x= player, y=list item)\n                print(f\"Current player {current_player.name} turn ended\\n\")\n                library.GameObjects.active_player = next(player_gen) # binds next player to rand_player, (changes x)\n                self.player_attrib_ipc_updater(library.GameObjects.active_player) #  binds new player\n                print(f\"{library.GameObjects.active_player.name} has been binded\")\n                break\n            elif current_player == y and not current_player.alive and not library.Options.perm_death:\n                print(f\"print player {current_player} is dead\") # move in to conditional for perm-a-death\n                current_player.alive = True # resets player status ##########need per-a-death bit here\n                library.GameObjects.active_player = next(player_gen) # changes x without binding and moves to next player\n                continue\n            else:\n                print(f\"{y.name.title()} did not match. Searching for player in list\")\n                y = next(player_gen) # changes y to find commonality to x\n\n        library.GameObjects.message = f\"{library.GameObjects.active_player.name.title()}'s turn...\"\n\n    def player_attrib_ipc_updater(self, playerinst=library.GameObjects.active_player): # defaults to gamevar active_player player\n        \"\"\"Binds all player atribs to gameVar for current player activity. Can take param of a player or grab active_player.\"\"\"\n        library.PlayerAttribs.player_name = playerinst.name.title()\n        library.PlayerAttribs.player_gender = playerinst.gender.title()\n        library.PlayerAttribs.player_level = playerinst.level\n        library.PlayerAttribs.player_bonus = playerinst.bonus\n        library.PlayerAttribs.player_wallet = playerinst.wallet\n        library.PlayerAttribs.player_race = playerinst.race.title()\n        library.PlayerAttribs.player_race2 = playerinst.race2.title()\n        library.PlayerAttribs.player_klass = playerinst.klass.title()\n        library.PlayerAttribs.player_klass2 = playerinst.klass2.title()\n        library.PlayerAttribs.player_sack = playerinst.sack\n        library.PlayerAttribs.player_l_hand = playerinst.update_bindings(\"L_hand\")\n        library.PlayerAttribs.player_r_hand = playerinst.update_bindings(\"R_hand\")\n        library.PlayerAttribs.player_two_hand = playerinst.update_bindings(\"two_hand\")\n        library.PlayerAttribs.player_headgear = playerinst.update_bindings(\"headgear\")\n        library.PlayerAttribs.player_armor = playerinst.update_bindings(\"armor\")\n        library.PlayerAttribs.player_knees = playerinst.update_bindings(\"knees\")\n        library.PlayerAttribs.player_footgear = playerinst.update_bindings(\"footgear\")\n        library.PlayerAttribs.player_necklace = playerinst.update_bindings(\"necklace\")\n\n# card handling class:\n\n    def deal_handler(self, option, deal_amount=1):\n        \"\"\" Sends requests to the dealer based on the option parameter to define card type.\n        Deal_amount defines how many of the cards are to be returned to a player.\n        \"\"\"\n\n        playerinst = library.GameObjects.active_player # gets current player. Not set at start default=None.\n\n        if option == \"start\": # initial play selector to deal cards to each player. NO GOOD FOR RESURRECT OPTION as deals to all players\n            for player in library.GameObjects.session_players: # loops over each player in session_players\n                player.sack = cards.card_sop.deal_cards(option, deal_amount=library.Options.cards_dealt) # deals cards with params \"start\" & num of cards to deal)\n\n        elif option == \"door\": # Standard gameplay loop on door kick\n            print(\"In deal_handler, retrieving door card & determining fate of card\")  # test location\n            door_card = cards.card_sop.deal_cards(option, deal_amount) # fetches 1 door card defined by the default,\n            return door_card # for pic use only in gui\n\n        elif option == \"treasure\": # Deal treasure, requires number for amount to deal.\n            print(\"retrieving treasure card/s\") # test location\n            add_treasure = cards.card_sop.deal_cards(option, deal_amount=deal_amount) # cardnum is usually determined by the treasures a monster holds.\n            playerinst.sack = playerinst.sack + add_treasure # DUMPS ALL IN THE ACTIVE_PLAYER.....TODO::Sort how treasure is handled when used as currency for another players help\n\n        elif option == \"resurrect\":\n            if library.Options.perm_death:\n                playerinst.sack = cards.card_sop.deal_cards(\"start\", deal_amount=library.Options.cards_dealt)\n            else:\n                print(f\"Game over for {playerinst.name}, BUMMER!\")\n\n        else:\n            print(\"option parameter not defined/matched in deal_handler\")\n\n    def door_card_designator(self, card, door_attempts=1): # for all door cards that are drawn from the pack or placed by another player.\n        \"\"\"Takes in door card and door_attempts as params to decide card fate.\n        Cards have different fates dependent upon the type of card it is ie: monster, curse, other and the number of\n        times the door button is clicked. Also update the message dependent on action\n        \"\"\"\n        player = library.GameObjects.active_player\n\n        if door_attempts: #On first kick of the door. Decides what to do with the cards dependent on situation\n\n            # if monster, put on table ready to fight\n            if card.get(\"type\") == \"monster\": # if the cards a monster #1st/2nd kicks covered\n                library.GameObjects.message = f\"{card.get('name')} placed on table, Level {card.get('lvl')}\" # updates broadcast message\n                cards.in_play[0].append(card) # places card on table in the lol for the first fight.\n                player.card_meths(card, static='on') # activates any static meths for the card. TESTED WITH 2 CARDS. OK!\n\n            # WORK REQUIRED!!     if curse, activate effects. need check to see if conditions in place to stop cursing ie ork/ wishing ring.\n            elif card.get(\"type\") == \"curse\": # if the cards a monster #1st/2nd kicks covered\n                library.GameObjects.message = f\"The room you have entered has a curse {card.get('name').title()}.\\n Lets hope you have protection!\"\n                print(\"In curse::\", player.active_curses)\n\n                player.card_meths(card, method_bs='on') # turns on curse bs## TEST\n\n                # ~~~~~~~~~~~~~TODO  curse checker method required ie tin hat, ork ect\n                if card.get(\"duration\") == \"persistent\": # for constant effect curse\n                    player.card_meths(card, \"method\", \"on\") # switches card on.\n                    player.active_curses.append(card) # adds card to player curse list so method can be called o remove\n                elif card.get(\"duration\") == \"one_shot\": ########### matches card key to the one_shot action\n                    player.card_meths(card, \"method\", \"on\")  ########## calls card method and switches it on TO BE REMOVED\n                    cards.burn_pile.append(card) # disposes of to burn pile\n                    print(f\"card duration is one_shot, added to burn pile check:\\nBurn pile {cards.burn_pile}\")\n                elif card.get(\"duration\") == \"timed\": ########## for time dependent effect\n                    library.GameObjects.message = f\"timed curse card not configured yet\" # overrides top message\n                    #TODO meth for timed\n                    cards.burn_pile.append(card) # disposes of to burn pile\n                    print(f\"card status is passive, should be added to burn pile!\\nBurn pile {cards.burn_pile}\"),\n\n            else: # for all other cards that have no direct effect or influence.\n                print(f\"Adding {card['name']}to sack.\")\n                player.sack.append(card)  # adds card to player's items\n                library.GameObjects.message = f\"Adding 2nd draw to sack.\" # need to be removed dont want to broadcast what other player gets\n                return card  # to show if first time only 2nd it hides\n\n        else:\n            \"2nd kick of door (looting room). Will need condition statement if player wants to fight mon from hand, rather than std flow to sack\"\n            print(\"adding to sack\")\n            library.GameObjects.message = \"2nd kck, Adding card to sack\"  # 2nd kick\n            player.sack.append(card)  # adds to player sack\n\n    def zipper(self, action):\n        \"\"\"zips card id's to checkbox bools from selected_list. Used for all card sorting regardless of card type.\n        action is conduit for card_matcher\"\"\"\n        library.GameObjects.zipped_tup.clear()  # clears tup list ready for new entry. not working...................\n        for status in library.GameObjects.check_but_intvar_gen: # gets attribute from object then from the attribute which is an object gets the value stored (list>intvar>get()>1 or 0)\n            library.GameObjects.check_but_boo.append(status.get()) # creates a list of 1s & 0s from check buttons status\n            x, y = library.GameObjects.check_but_card_ids, library.GameObjects.check_but_boo\n            library.GameObjects.zipped_tup = list(zip(x, y)) # result [(card_id,  bool), (card_id, bool)]\n        # print(\"moving to player script\", gameVar.GameObjects.zipped_tup) # checker shows all cleared lists\n        self.card_matcher(action)\n\n    def card_matcher(self, action):\n        \"\"\"compares tuple to selected_items searching for matching card ids and only passes on cards that contain\n        a tuple with the boolean true. Action determines the whats happening to the cards next. \"\"\"\n        for card in library.GameObjects.selected_items: # for every card in selected_items\n            for tup in library.GameObjects.zipped_tup: # go over every tuple in  zipped_tup. (card_id, bool tuples).\n                if tup[0] == card[\"id\"] and tup[1]: # if tup id matches card fid from selected items and bool is True from the checkbox\n                    if action == \"sell\":\n                        library.GameObjects.active_player.sell_item(card)\n                    elif action in \"equip, disposable ,use\": # equip/disposable will be treasures\n                        self.tri_qualifier(card) # test ~~ok~~\n                    elif action == \"remove\":\n                        player = library.GameObjects.active_player\n                        player.equipped_items(\"removal\", card)\n\n    def tri_qualifier(self, card):\n        \"\"\" Checks player attribs against an item card before it can be used by the player. Split into 2 parts:\n        1st: checks card for a specific restriction that would count against a player due to a specific attrib, ie if u are human u cant use this card.\n        2nd part: \"\"\"\n\n        player = library.GameObjects.active_player\n\n        checks = {player.race: \"race_requirement\", player.race2: \"race_requirement\", player.klass: \"klass_requirement\",\n                  player.klass2: \"klass_requirement\", player.gender: \"gender_requirement\"} # card specific requirements to use\n        flag = 1 # True\n\n        for player_attribs, card_requirement in checks.items():\n            # checks card restrict method lexical for non use cases. If found player cant use.\n            if card.get('restriction', False): # checks to see if there is a key named 'restriction' in card if not return False\n                print(\"Searching card restriction method\")\n                if player_attribs in card.get('restriction'):  # checks all player attribs to see if in restricted treasure card list #\n                    # THINK ABOUT CARDS YOU ARE APPLYING THEM TOO; TREASURE!\n                    print('Restriction found in card')\n                    if player.name == \"The_Creator\":  # dev mode\n                        print(f\"{player_attribs} - Restriction avoided: Dev path\")\n                        break\n                    else: # sets flag so card cant be used\n                        print('Restricted, card cant be used.')\n                        flag = 0\n                        break\n            # checks cards for player dependent attribs to use card\n            if card.get(card_requirement):  # checks card to see if requirement present\n                if card.get(card_requirement) == player_attribs: # if race_requirement = 'human' == player.race = 'human' change flag and break out of loop\n                    print(f\"Main path for: {card_requirement}\")\n                    continue # checks next requirement parameter for conformance\n                elif player.name == \"The_Creator\":  # dev mode\n                    print(f\"{player_attribs} - Dev path\")\n                    continue\n                else:\n                    library.GameObjects.message = f\"You cant use this card, {card_requirement}\"\n                    flag = 0\n                    # gameVar.StartVariables.message = f\"{card.get('name')} can not be quipped: {val}.\" # not working\n                    break\n\n        if flag: # only if flag remains True, compliant to non restrictions.\n\n            if card[\"category\"] == \"treasure\":  # for all treasure cards the player uses that was from their hand\n                self.player_treasure_cards(card) # for the use of treasure cards\n            elif card[\"category\"] == \"door\":  # for all enhancers ect that the player has from their hand  DO DOOR CARDS REALLY COME DOWN THIS ROUTE! however thowables???\n                self.player_door_cards(card) # for the use of door cards\n\n    def player_treasure_cards(self, card):\n        \"\"\"method to sort the locations of treasure cards that the player has selected\"\"\"\n        player = library.GameObjects.active_player\n        if card.get(\"type\") == \"armor\":\n            player.equip_armor(card)  # leads to player meth for placing in right place\n        elif card.get(\"type\") == \"weapon\":\n            player.equip_weapon(card)\n        elif card.get(\"type\") == \"disposable\":  # for disposable throwable only\n            pass  # meth for selecting target and changing bonuses, # TODO\n        else:\n            pass # for all other cards ie steeds\n\n    def player_door_cards(self, card): #card meth#####################################################\n        player = library.GameObjects.active_player\n        player.card_meths(card, method=\"on\")  # link to player to card meths.\n        print('unlocking:', player.klass_unlock, player.race_unlock)  # only shows at end of turn due to meth restriction in class,\n        # meths added at end_turn\n\n    def scrub_lists(self):\n        \"\"\"Clears all appended list that are not capable of clearing.\"\"\"\n        library.GameObjects.selected_items.clear()  # clears the card objects list\n        library.GameObjects.check_but_intvar_gen.clear()  # clears list of intVar objects from check buttons\n        library.GameObjects.check_but_boo.clear()  # clears boolean list\n        library.GameObjects.check_but_card_ids.clear()  # clears card id list\n        library.GameObjects.zipped_tup.clear()  # clears tup list\n\n##################################################################\n    def fight(self, helper=0, additional=0):# helper would be other player interactions. additional is anything else\n        \"\"\"for cards that are monsters and placed on the table\"\"\"\n        print(\"In the fight!\")\n        card = cards.in_play.pop() # end of cards on table\n        player = library.GameObjects.active_player\n        player.card_meths(card, 'static', 'on') # turns on card static content for fight TODO change to something more relevant than \"static\"\n        if player.bonus + player.level + helper + library.Fight_enhancers.player_aid \\\n                >= card[\"lvl\"] + library.Fight_enhancers.monster_aid: # consideration required for player consumables and enhancers\n            print(\"Player wins!\")\n            reward = card['treasure']\n            self.deal_handler('treasure', deal_amount=reward) # fetches treasure for player\n            library.GameObjects.message = f\"You win! You have found {reward} treasures for your trouble.\"\n            player.level += card[\"level_up\"]\n            cards.burn_pile.append(card) # removes card\n            player.card_meths(card, 'static', 'off') # turns off static card content\n            print(f\"cards in the burn pile: {len(cards.burn_pile)}\")\n            return \"win\"\n        # need action to go up lvl note some cards do more than one level!\n        else:\n            library.GameObjects.message = \"Fight lost\"\n            print(\"Fight lost\")\n            player.card_meths(card, 'method', 'on') # calls card bad stuff\n            player.card_meths(card, 'static', 'off') # turns off static effect of card in play\n            return \"lose\"\n\n    def card_method_activator(self, scenario, action, table_card_index): # will need to be a selector\n        \"\"\"method to activate a card dependent upon the scenario of having a specific monster/ curse/ item in play and action to\n        switch on or off the condition\"\"\"\n        card = cards.in_play[int(table_card_index)][0] # selects the monster in the fight on the table\n        player = library.GameObjects.active_player\n        if scenario == \"persistent\":\n            player.card_meths(card, 'static', action)  ######## will cause probs with monster individuality ######################\n\n    def run(self):\n        roll = dice.dice_sop.roll()\n        player = library.GameObjects.active_player\n        print(f\"You rolled a {roll}.\")\n        if roll >= player.run:\n            print(f\"You rolled a {roll}. You out ran your pursuer.\")\n            remove = cards.in_play.pop(0)\n            player.card_meths(remove, 'static', 'off')# turns off static card content\n            cards.burn_pile.append(remove)\n            return \"success\"\n        else:\n            print(\"Tried to run and slipped. Things are gona get ugly!\\n\")\n            # only fight is available now so that cna handle all the logic\n            return \"fail\"\n\n\nengine = PlayerSetUp()\n\nif __name__ == \"__main__\":\n\n    # NumberOfPlayers().select_players() # starts game by activating NOP building the objects, and activating select_players\n    # running wach line.\n    engine.player_name_gender()\n\n\n\n\n\n\n# old\n# def door_card_designator(self, card, door_attempts=1):  # for all door cards that are drawn from the pack\n#     \"\"\"method that sort the cards that the player draws from the deck during play. This could be monster, curse ect.\n#     door0-attempts is used to determine how many times the door has been kicked in a turn and in 2nd instance the door is put into the\n#     players hand unseen. Mechanism is also used to trigger a curse\n#     \"\"\"\n#     player = gameVar.GameObjects.active_player\n#\n#     if door_attempts:\n#         if card.get(\"type\") == \"monster\":  # if the cards a monster #1st/2nd kicks covered\n#             if door_attempts:  # determines if first kick of door (T or F), if 1 = first kick\n#                 gameVar.GameObjects.message = f\"{card.get('name')} placed on table, Level {card.get('lvl')}\"\n#                 cards.in_play.append(\n#                     card)  # adds to table # careful as cards selected from hand will go strait to table\n#                 print(\n#                     f\"In door_card_designator, monster added to table. Returned card is: {[x['name'] for x in cards.in_play]}\\n\")\n#             else:\n#                 print(\"adding to sack\")\n#                 gameVar.GameObjects.message = \"Adding card to sack\"  # 2nd kick\n#                 player.sack.append(card)  # adds to player sack\n#\n#         elif card.get(\"type\") == \"curse\":  # if the cards a monster #1st/2nd kicks covered\n#             if door_attempts:  # 1st kick\n#                 print(\"In curse::\", player.curses)\n#                 gameVar.GameObjects.message = \"You have been cursed!\"  # look at card meth and action\n#                 player.card_meths(card, \"method\", \"on\")  # actions curs card as soon as picked up\n#                 if card.get(\"status\") == \"active\":  # for constant effect curse\n#                     player.curses.append(card)  # adds card to player curse list\n#                 elif card.get(\"status\") == \"passive\":  # for one shot effect\n#                     cards.burn_pile.append(card)  # disposes of to burn pile\n#                     print(f\"card status is passive, should be added to burn pile!\\nBurn pile {cards.burn_pile}\")\n#             else:\n#                 gameVar.GameObjects.message = \"Adding card to sack\"\n#                 player.sack.append(card)\n#\n#         else:  # for all other cards that have no direct effect or influence.\n#             print(f\"Adding {card['name']}to sack.\")\n#             if door_attempts:\n#                 player.sack.append(card)  # adds card to player's items\n#                 gameVar.GameObjects.message = f\"Adding/using {card.get('name')}.\"\n#                 return card  # to show if first time only 2nd it hides\n#             else:\n#                 gameVar.GameObjects.message = \"Adding 2nd card to sack\"\n#                 player.sack.append(card)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/engine/controller.py b/Munchkin/bin/engine/controller.py
--- a/Munchkin/bin/engine/controller.py	(revision 1b5271f872c8f8de72bbcbd0e215f2a8cf578c1e)
+++ b/Munchkin/bin/engine/controller.py	(date 1650894771588)
@@ -226,11 +226,10 @@
 
         for player_attribs, card_requirement in checks.items():
             # checks card restrict method lexical for non use cases. If found player cant use.
-            if card.get('restriction', False): # checks to see if there is a key named 'restriction' in card if not return False
+            if card.get('restriction', False): # checks card to see if there is a key named 'restriction'. if not return False
                 print("Searching card restriction method")
-                if player_attribs in card.get('restriction'):  # checks all player attribs to see if in restricted treasure card list #
-                    # THINK ABOUT CARDS YOU ARE APPLYING THEM TOO; TREASURE!
-                    print('Restriction found in card')
+                if player_attribs in card.get('restriction'):  # checks all player attribs to see if in restricted treasure card list # Returns True if match
+                    print('Restriction found')
                     if player.name == "The_Creator":  # dev mode
                         print(f"{player_attribs} - Restriction avoided: Dev path")
                         break
@@ -271,6 +270,7 @@
         else:
             pass # for all other cards ie steeds
 
+
     def player_door_cards(self, card): #card meth#####################################################
         player = library.GameObjects.active_player
         player.card_meths(card, method="on")  # link to player to card meths.
Index: funct_trial.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\" Area to test algorithms\"\"\"\n# import tkinter as tk\n# app = tk.Tk()\n\n\"\"\"Design for engine for returning a nested dict of call associated cards and possible toplevel design for gui\"\"\"\n\n# l = [{\"id\": 1, 'type':'weap', 'des':'sword'},\n#      {\"id\": 2, 'type':'hat', 'des':'fluffy'},\n#      {\"id\": 3, 'type':'weap', 'des':'axe'}]\n\n# caller = \"hat\" #to be called as a param in the method (specific to caller!)\n#\n# x = [obj for obj in l if obj['type'] == caller]\n\n# print(x)\n# print(l[0][\"type\"])\n\n# result = [] #dont forget to clear after use\n# boo = []\n# ids = []\n# zipper = []\n# main = tk.Frame(app)\n# main.pack()\n#\n# def remove():\n#     for item in x:\n#         print(f\"item is {item}\")\n#         print(zipper)\n#         print(l)\n#         for tup in zipper:\n#             print(tup)\n#             if tup[0] == item[\"id\"] and tup[1]: # tup[1] should be 1or 0 thus true or false\n#                 print(f\"removing item {item['des']}\")\n#                 l.pop(l.index(item))\n#                 print(l)\n#             else:\n#                 continue\n#\n# def grab():\n#     global zipper\n#     for var in result:\n#         boo.append(var.get())\n#     # print(boo)\n#     # print(ids)\n#     zipper = list(zip(ids, boo))\n#     # print(zipper)\n#     remove()\n#\n#\n#\n# f = tk.Frame(main)\n# f.pack(side=\"top\", expand=True)\n# tk.Label(f, text=\"Name\").grid(row=0, column=0, sticky=\"nw\")\n# tk.Label(f, text=\"Des\").grid(row=0, column=1, sticky=\"nw\")\n# tk.Label(f, text=\"Sell\").grid(row=0, column=2, sticky=\"nw\")\n# tk.Label(f, text=\"Equip\").grid(row=0, column=3, sticky=\"nw\")\n#\n# for lab in x:\n#     status = tk.IntVar()\n#     f1 = tk.Frame(main)\n#     f1.pack(side=\"top\", expand=True)\n#     l1 = tk.Label(f1, text=lab['type'])\n#     l1.grid(row=0, column=0, sticky=\"nw\")\n#     l2 = tk.Label(f1, text=lab['des'])\n#     l2.grid(row=0, column=1, sticky=\"nw\")\n#     tk.Checkbutton(f1, text=\" \", variable=status).grid(row=0, column=2, sticky=\"nw\")\n#     result.append(status)\n#     ids.append(lab[\"id\"])\n#     # tk.Radiobutton(f1, text=\" \").grid(row=0, column=3, sticky=\"nw\")\n#\n# tk.Button(f, text=\"sell\", command=grab).grid(row=1, column=0, columnspan=3)\n#\n#\n\n# d = {\"hat\": \"\", \"chair\": {\"p\":\"winner\"}}\n#\n# if isinstance(d.get(\"chair\"), dict):\n#     print(\"true\")\n# else:\n#     print(\"false\")\n\n# def x(n):\n#     l = [1,2,3]\n#     print(l[int(n)])\n#\n# x(-1)\n#\n# f = {'rest': [\"tester\", 'pop', 'not_man']}\n#\n# if 'not_man' in f.get('rest'):\n#     print(\"yep\")\n#     print(f.get('res', False)) # none object, can now return false\n\n# for x in f['rest']:\n#     print(x)\n#\n# else:\n#     print(\"nope\")\n# app.mainloop()\n\ndef card_meth(*arg, **kwargs):\n    print(arg)\n    for cardset in arg:\n        print(cardset)\n        for card in cardset:\n            print(card)\n            if 'mon' in card:\n                print('monster found')\n            else:\n                print(card.get('enhancer', 'Not enhancer'))\n\n    # if kwargs.get('foo'):\n    #     print('in dict')\n# card_meth('foo', 'bar', foo='foobar')\n\nf = [ [{'mon': [\"a\", 'aa', 'aaa']}, {'enhancer': [\"x\", 'xx', 'xxx']}], [{'mon': [\"b\", 'bb', 'bbb']}] ]\nn = {'mon': [\"a\"]}, {'enhancer': ['enhancer found']}, {'mon': [\"b\"]}, {'weap': [\"w\"]}  # simulates 3 cards in list\n# card_meth(n)\n\n# print(f[0][0].get('mon')) # [fight selector], [monster selector].dict atrib fetcher\n# print(f[0][0])\n# print(len(f[0][0]))\n# print(len(f))\n# x=f\n# print(id(f), id(x))\n\narmor = {\"headgear\": \"\", \"armor\": \"\", \"knees\": \"\", \"footgear\": \"\", \"necklace\": \"\", \"ring\": {'fireband': ['hot!']}, \"ring2\": \"\"}\n\nprint(armor)\nprint(armor.get('ring'))\na = armor.pop('ring')\na = armor['ring'] = \"\" # need to be added back in as pop removes\nprint(armor)\nprint(a)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/funct_trial.py b/funct_trial.py
--- a/funct_trial.py	(revision 1b5271f872c8f8de72bbcbd0e215f2a8cf578c1e)
+++ b/funct_trial.py	(date 1650829437071)
@@ -131,4 +131,5 @@
 a = armor.pop('ring')
 a = armor['ring'] = "" # need to be added back in as pop removes
 print(armor)
-print(a)
\ No newline at end of file
+print(a)
+x = A
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"e89d33e8-f65b-4c0f-9d3f-1de9856c0ba0\" name=\"Changes\" comment=\"card metho sorted, can add to accept more than one card arg\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/MyPackages.iml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/MyPackages.iml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/misc.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/misc.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Python Script\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"FlaskConsoleOptions\" custom-start-script=\"import sys&#10;sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])&#10;from flask.cli import ScriptInfo&#10;locals().update(ScriptInfo(create_app=None).load_app().make_shell_context())&#10;print(&quot;Python %s on %s\\nApp: %s [%s]\\nInstance: %s&quot; % (sys.version, sys.platform, app.import_name, app.env, app.instance_path))\">\n    <envs>\n      <env key=\"FLASK_APP\" value=\"app\" />\n    </envs>\n    <option name=\"myCustomStartScript\" value=\"import sys&#10;sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])&#10;from flask.cli import ScriptInfo&#10;locals().update(ScriptInfo(create_app=None).load_app().make_shell_context())&#10;print(&quot;Python %s on %s\\nApp: %s [%s]\\nInstance: %s&quot; % (sys.version, sys.platform, app.import_name, app.env, app.instance_path))\" />\n    <option name=\"myEnvs\">\n      <map>\n        <entry key=\"FLASK_APP\" value=\"app\" />\n      </map>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"master\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"GitSEFilterConfiguration\">\n    <file-type-list>\n      <filtered-out-file-type name=\"LOCAL_BRANCH\" />\n      <filtered-out-file-type name=\"REMOTE_BRANCH\" />\n      <filtered-out-file-type name=\"TAG\" />\n      <filtered-out-file-type name=\"COMMIT_BY_MESSAGE\" />\n    </file-type-list>\n  </component>\n  <component name=\"ProjectId\" id=\"228V1szxqWwIqe83W3F9S3jTuGo\" />\n  <component name=\"ProjectLevelVcsManager\">\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\n  </component>\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">\n    <property name=\"ASKED_ADD_EXTERNAL_FILES\" value=\"true\" />\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$/../Learning_files\" />\n  </component>\n  <component name=\"RunManager\" selected=\"Python.view\">\n    <configuration name=\"controller\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/bin/GUI/controller.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"doorcards\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards/doorcards.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"funct_trial\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/funct_trial.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"game_loop_v3\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/bin/engine\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/bin/engine/game_loop_v3.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"view\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/bin/GUI/view.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"Python.view\" />\n        <item itemvalue=\"Python.doorcards\" />\n        <item itemvalue=\"Python.funct_trial\" />\n        <item itemvalue=\"Python.game_loop_v3\" />\n        <item itemvalue=\"Python.controller\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"e89d33e8-f65b-4c0f-9d3f-1de9856c0ba0\" name=\"Changes\" comment=\"\" />\n      <created>1639218994311</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1639218994311</updated>\n      <workItem from=\"1639218997657\" duration=\"35269000\" />\n      <workItem from=\"1639735508330\" duration=\"18975000\" />\n      <workItem from=\"1640013914970\" duration=\"13331000\" />\n      <workItem from=\"1640513559951\" duration=\"433000\" />\n      <workItem from=\"1640952454199\" duration=\"648000\" />\n      <workItem from=\"1649103067776\" duration=\"360000\" />\n      <workItem from=\"1649237457571\" duration=\"2195000\" />\n      <workItem from=\"1649273824130\" duration=\"6676000\" />\n      <workItem from=\"1649938477233\" duration=\"1987000\" />\n      <workItem from=\"1650490391088\" duration=\"17364000\" />\n      <workItem from=\"1650789083067\" duration=\"820000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"update to card date structure\">\n      <created>1639844962852</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1639844962852</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"changes image recall file structure to handle different os with pathlib module\">\n      <created>1649255260546</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1649255260546</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"changes image recall file structure to handle different os with pathlib module\">\n      <created>1649273835279</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1649273835279</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"docs\">\n      <created>1649280322103</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1649280322103</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"docs\">\n      <created>1649619777519</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1649619777519</updated>\n    </task>\n    <task id=\"LOCAL-00006\" summary=\"renaming scripts\">\n      <created>1650360756678</created>\n      <option name=\"number\" value=\"00006\" />\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1650360756678</updated>\n    </task>\n    <task id=\"LOCAL-00007\" summary=\"V4 starting for new player factory, fight mechanics, naming, dependencies ect\">\n      <created>1650380422544</created>\n      <option name=\"number\" value=\"00007\" />\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1650380422544</updated>\n    </task>\n    <task id=\"LOCAL-00008\" summary=\"card metho sorted, can add to accept more than one card arg\">\n      <created>1650564152449</created>\n      <option name=\"number\" value=\"00008\" />\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1650564152449</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"9\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State>\n              <option name=\"FILTERS\">\n                <map>\n                  <entry key=\"branch\">\n                    <value>\n                      <list>\n                        <option value=\"origin/testing_curse_calls\" />\n                      </list>\n                    </value>\n                  </entry>\n                </map>\n              </option>\n            </State>\n          </value>\n        </entry>\n      </map>\n    </option>\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <option name=\"ADD_EXTERNAL_FILES_SILENTLY\" value=\"true\" />\n    <MESSAGE value=\"update to card date structure\" />\n    <MESSAGE value=\"changes image recall file structure to handle different os with pathlib module\" />\n    <MESSAGE value=\"docs\" />\n    <MESSAGE value=\"renaming scripts\" />\n    <MESSAGE value=\"V4 starting for new player factory, fight mechanics, naming, dependencies ect\" />\n    <MESSAGE value=\"card metho sorted, can add to accept more than one card arg\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"card metho sorted, can add to accept more than one card arg\" />\n  </component>\n  <component name=\"XDebuggerManager\">\n    <breakpoint-manager>\n      <breakpoints>\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\n          <url>file://$PROJECT_DIR$/Munchkin/bin/GUI/view.py</url>\n          <line>516</line>\n          <option name=\"timeStamp\" value=\"20\" />\n        </line-breakpoint>\n      </breakpoints>\n    </breakpoint-manager>\n  </component>\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\n    <SUITE FILE_PATH=\"coverage/Munch$funct_trial.coverage\" NAME=\"funct_trial Coverage Results\" MODIFIED=\"1650631374183\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\n    <SUITE FILE_PATH=\"coverage/Munch$game_loop_v3.coverage\" NAME=\"game_loop_v3 Coverage Results\" MODIFIED=\"1650360495937\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/engine\" />\n    <SUITE FILE_PATH=\"coverage/Munch$controller.coverage\" NAME=\"controller Coverage Results\" MODIFIED=\"1649254694799\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\n    <SUITE FILE_PATH=\"coverage/MyPackages$doorcards.coverage\" NAME=\"doorcards Coverage Results\" MODIFIED=\"1639811290752\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards\" />\n    <SUITE FILE_PATH=\"coverage/Munch$general_tests.coverage\" NAME=\"general_tests Coverage Results\" MODIFIED=\"1649253557839\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/Tests\" />\n    <SUITE FILE_PATH=\"coverage/Munch$doorcards.coverage\" NAME=\"doorcards Coverage Results\" MODIFIED=\"1650694902157\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards\" />\n    <SUITE FILE_PATH=\"coverage/Munch$view.coverage\" NAME=\"view Coverage Results\" MODIFIED=\"1650705324079\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\n    <SUITE FILE_PATH=\"coverage/MyPackages$funct_trial.coverage\" NAME=\"funct_trial Coverage Results\" MODIFIED=\"1640266776710\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\n    <SUITE FILE_PATH=\"coverage/MyPackages$controller.coverage\" NAME=\"controller Coverage Results\" MODIFIED=\"1640513926303\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 1b5271f872c8f8de72bbcbd0e215f2a8cf578c1e)
+++ b/.idea/workspace.xml	(date 1650894826465)
@@ -2,9 +2,10 @@
 <project version="4">
   <component name="ChangeListManager">
     <list default="true" id="e89d33e8-f65b-4c0f-9d3f-1de9856c0ba0" name="Changes" comment="card metho sorted, can add to accept more than one card arg">
-      <change beforePath="$PROJECT_DIR$/.idea/MyPackages.iml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/MyPackages.iml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Munchkin/bin/engine/controller.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/engine/controller.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Munchkin/bin/players/playermodel.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/players/playermodel.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/funct_trial.py" beforeDir="false" afterPath="$PROJECT_DIR$/funct_trial.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -199,7 +200,8 @@
       <workItem from="1649273824130" duration="6676000" />
       <workItem from="1649938477233" duration="1987000" />
       <workItem from="1650490391088" duration="17364000" />
-      <workItem from="1650789083067" duration="820000" />
+      <workItem from="1650789083067" duration="3385000" />
+      <workItem from="1650877919860" duration="3525000" />
     </task>
     <task id="LOCAL-00001" summary="update to card date structure">
       <created>1639844962852</created>
@@ -257,7 +259,14 @@
       <option name="project" value="LOCAL" />
       <updated>1650564152449</updated>
     </task>
-    <option name="localTasksCounter" value="9" />
+    <task id="LOCAL-00009" summary="card metho sorted, can add to accept more than one card arg">
+      <created>1650823336289</created>
+      <option name="number" value="00009" />
+      <option name="presentableId" value="LOCAL-00009" />
+      <option name="project" value="LOCAL" />
+      <updated>1650823336289</updated>
+    </task>
+    <option name="localTasksCounter" value="10" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -304,6 +313,21 @@
           <url>file://$PROJECT_DIR$/Munchkin/bin/GUI/view.py</url>
           <line>516</line>
           <option name="timeStamp" value="20" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" suspend="THREAD" type="python-line">
+          <url>file://$PROJECT_DIR$/Munchkin/bin/players/playermodel.py</url>
+          <line>179</line>
+          <option name="timeStamp" value="23" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" suspend="THREAD" type="python-line">
+          <url>file://$PROJECT_DIR$/Munchkin/bin/players/playermodel.py</url>
+          <line>207</line>
+          <option name="timeStamp" value="24" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" suspend="THREAD" type="python-line">
+          <url>file://$PROJECT_DIR$/Munchkin/bin/players/playermodel.py</url>
+          <line>236</line>
+          <option name="timeStamp" value="25" />
         </line-breakpoint>
       </breakpoints>
     </breakpoint-manager>
