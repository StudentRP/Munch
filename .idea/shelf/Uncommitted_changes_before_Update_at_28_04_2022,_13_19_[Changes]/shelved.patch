Index: Munchkin/bin/GUI/view.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n\"\"\"\nMain gui for Munchkin, version 4 (legacy: gui_v3)\n\n\"\"\"\nimport tkinter as tk\nimport tkinter.ttk as ttk\nfrom bin.engine.controller import engine  # imports the instance\n# from bin.all_cards.table import cards\nimport bin.engine.cut_scenes as cs\nimport bin.GUI.variables_library as library\nfrom tkinter import messagebox\nfrom PIL import ImageTk, Image\nimport os\nfrom pathlib import Path\n\nfrom bin.GUI.variables_library import cards\n# import bin.GUI.gui_tools as tools\nprint('view', id(library.cards))\n\n\ngamefont = ('castellar', 12, 'bold')\nwindow_color = \"#160606\" # Would like pic here of door\ntext_color = \"#7A0600\"\nbut_color = \"#3EB0A1\"\n\n##########################################################################\n# Main controller\n##########################################################################\n\n\nclass Main(tk.Tk):\n    \"\"\"main controller class that interchanges frames, updates variables with the frames\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        tk.Tk.__init__(self, *args, **kwargs)\n        self.geometry('500x200') # adding +x+y to the end provide window location, maybe create option slider in menu\n        self.title(\"Munchkin\")\n        # main container for the different frames to be placed in\n        container = tk.Frame(self)\n        container.pack(side=tk.TOP, fill='both', expand=True) # creates frame that spans all of the main tk window\n        container.grid_rowconfigure(0, weight=1) # params = row 0 expand(1, 0 for not expand)\n        container.grid_columnconfigure(0, weight=1)\n        # holds all the prebuilt frames for the container to look up\n        self.frames = {} # app.frames\n\n        #### all Game notifications ####\n        self.message = tk.StringVar()\n        self.message2 = tk.StringVar()\n        #### all player atribs to bind ####\n        self.name = tk.StringVar()\n        self.gender = tk.StringVar()\n        self.race = tk.StringVar()\n        self.race2 = tk.StringVar()\n        self.klass = tk.StringVar()\n        self.klass2 = tk.StringVar()\n        self.level = tk.IntVar()\n        self.bonus = tk.IntVar()\n        self.wallet = tk.IntVar()\n        self.r_hand = tk.StringVar()\n        self.l_hand = tk.StringVar()\n        self.two_hand = tk.StringVar()\n        self.headgear = tk.StringVar()\n        self.armor = tk.StringVar()\n        self.knees = tk.StringVar()\n        self.footgear = tk.StringVar()\n        self.necklace = tk.StringVar()\n\n        \"Creates 3 frames all with the same parent and fills the dictionary with snapshots of built instances\"\n        for frm in StartPg, PlayerSelect, MainLoop: # snapshot of the frames (classes) put into the dict\n            frame = frm(container, self) # Instance creation. Passes container as the parent frame & self as controller (app)\n            self.frames[frm] = frame  # adding to dict\n            frame.grid(row=0, column=0, sticky='nsew')\n        self.show_frame(StartPg) # calling correct pg to top of the frame, last one stacked will show otherwise\n\n    def show_frame(self, content):\n        \"\"\" Brings the frame to the fore front within the pre packed parent frame. Content being name of frame class\n        packed into the container \"\"\"\n        frame = self.frames[content] # looks up the frame in the dict\n        frame.tkraise() # brings the child frame to the forefront to be seen within the main container frame\n\n    def update_attrib_frame(self):\n        \"\"\"Binds all the labels to the gamevar for player change with the set method\"\"\"\n        self.geometry(\"800x600+320+20\") # changes the geometry when called ## need to move\n        self.name.set(library.PlayerAttribs.player_name)\n        self.gender.set(library.PlayerAttribs.player_gender)\n        self.race.set(library.PlayerAttribs.player_race)\n        self.race2.set(library.PlayerAttribs.player_race2)\n        self.klass.set(library.PlayerAttribs.player_klass)\n        self.klass2.set(library.PlayerAttribs.player_klass2)\n        self.level.set(library.PlayerAttribs.player_level)\n        self.bonus.set(library.PlayerAttribs.player_bonus)\n        self.wallet.set(library.PlayerAttribs.player_wallet)\n\n        self.l_hand.set(library.PlayerAttribs.player_l_hand)\n        self.r_hand.set(library.PlayerAttribs.player_r_hand)\n        self.two_hand.set(library.PlayerAttribs.player_two_hand)\n\n        self.headgear.set(library.PlayerAttribs.player_headgear)\n        self.armor.set(library.PlayerAttribs.player_armor)\n        self.knees.set(library.PlayerAttribs.player_knees)\n        self.footgear.set(library.PlayerAttribs.player_footgear)\n        self.necklace.set(library.PlayerAttribs.player_necklace)\n\n    def update_message(self, action=None):\n        if action == \"show\":\n            self.message.set(library.GameObjects.message) # grabs message stored in gamevar messages\n        elif action == \"dev\":\n            self.message2.set(library.GameObjects.message2)\n        else:\n            self.message.set(\"\")\n            self.message2.set(\"\")\n\n##########################################################################\n# frames to build up interface\n##########################################################################\n\n\nclass StartPg(tk.Frame):\n    \"\"\"Starting page linking buttons to game options and game start\"\"\"\n    # window_color = \"#160606\" # Would like pic here of door\n    # text_color =\"#7A0600\"\n    # but_color = \"#3EB0A1\" # moved to top of script\n\n    def __init__(self, parent, controller): # parent = container in Main class, controller = app object.\n        tk.Frame.__init__(self, parent)\n        self.config(bg=window_color)\n\n        # welcome massage\n        label = tk.Label(self, text=f\"{cs.start()}\")\n        label.config(font=gamefont, bg=window_color, fg=text_color)\n        label.pack(pady=10, padx=10)\n\n        #button to change frame seen in container\n        but1 = tk.Button(self, text='Continue', command=lambda: controller.show_frame(PlayerSelect))\n        but1.config(bg=but_color, fg=text_color, padx=40, activebackground='red', relief=\"raised\")\n        but1.pack()\n        but1.focus_set()\n\n        # game options\n        but2 = tk.Button(self, text=\"Options\", command=GameOptions)\n        but2.config(bg=but_color, fg=text_color, padx=40, activebackground='yellow', relief=\"raised\")\n        but2.pack(side=\"bottom\")\n\n\nclass GameOptions(tk.Toplevel):\n    \"\"\"Toplevel window for setting in game options at start\"\"\" # WORKS need others added and style tidying\n    def __init__(self):\n        tk.Toplevel.__init__(self)\n        self.geometry(\"275x275+400+50\")\n\n        # Editable options binding\n        self.initial_deal = tk.IntVar()\n        self.maxlvl = tk.IntVar()\n        self.permadeath = tk.BooleanVar()\n        self.carry_weight = tk.IntVar()\n\n        #styling\n        lf = tk.LabelFrame(self, text=\"Game Options\")\n        lf.config(font=gamefont)\n        lf.pack(fill='both', expand=True)\n\n        l1 = tk.Label(lf, text=\"Number of starting cards\")\n        l1.grid(column=0, row=0)\n        e1 = tk.Entry(lf, textvariable=self.initial_deal)\n        self.initial_deal.set(4) # if options opened, sets this as default\n        e1.icursor(1) # sets blinking cursor to this index ready to change value in box\n        e1.focus() # focuses on entry,,\n        e1.grid(column=1, row=0)\n\n        l2 = tk.Label(lf, text=\"Set max level\")\n        l2.grid(column=0, row=1)\n        e2 = tk.Entry(lf, textvariable=self.maxlvl)\n        self.maxlvl.set(10)\n        e2.grid(column=1, row=1)\n\n        l2 = tk.Label(lf, text=\"Max Hand capacity\") # cards not visible to all players.\n        l2.grid(column=0, row=2)\n        e2 = tk.Entry(lf, textvariable=self.carry_weight)\n        self.carry_weight.set(10) # change when cards are categorised, should be 6\n        e2.grid(column=1, row=2)\n\n        l3 = tk.Label(lf,text=\"Perm-a-death\")\n        l3.grid(column=0, row=3)\n        cbut = tk.Checkbutton(lf, variable=self.permadeath)\n        cbut.grid(column=1, row=3, sticky=\"w\")\n\n        b1 = tk.Button(lf, text=\"OK\", command=self.setopts)\n        b1.config(padx=20)\n        b1.grid(column=0, row=4, columnspan=2)\n\n    def setopts(self):\n        \"\"\"Sets gamevar options to the new values provided with the get() method used for tkvars. \"\"\"\n        library.Options.cards_dealt = self.initial_deal.get() # gets value stored in the bound tkvar associated to initial_deal\n        library.Options.win_lvl = self.maxlvl.get()\n        library.Options.perm_death = self.permadeath.get()\n        library.Options.carry_weight = self.carry_weight.get()\n        message = f\"Starting deal: {library.Options.cards_dealt}\\nWin level:{library.Options.win_lvl}\\n\" \\\n                  f\"Carry weight: {library.Options.carry_weight}\\nPerm_a_death: {library.Options.perm_death}\"\n        messagebox.showinfo(\"Settings Changed!\", message) # tk built in message\n        GameOptions.destroy(self) # destroys toplevel after all actions complete.\n\n\nclass PlayerSelect(tk.Frame):\n    \"\"\"Selection on number of players and meth to deal initial cards\"\"\"\n    def __init__(self, parent, controller): # controller always passed in from main, parent is Main container\n        tk.Frame.__init__(self, parent)\n        self.Num_of_players = tk.IntVar() # (int) of players in session\n        self.count = tk.IntVar() # gameVar.StartVariables.new_players\n        self.config(bg=window_color)\n\n        label = tk.Label(self, text=\"Select number of players\")\n        label.config(font=gamefont, bg=window_color, fg=text_color)\n        label.pack(pady=10, padx=10)\n        l1 = ttk.Spinbox(self, from_=1, to=10, increment=1, textvariable=self.Num_of_players) # num of players select\n        l1.focus()\n        l1.set(1) # sets inittal value on spinbox to 1\n        l1.pack()\n        but1 = tk.Button(self, text=\"Confirm\", command=self.playersetter)\n        but1.config(bg=but_color, fg=text_color, padx=40, activebackground='red', relief=\"raised\")\n        but1.pack(side=\"bottom\")\n\n    def playersetter(self):\n        \"\"\"Binds values from spinbox to gui_var for later use and calls next stage. Calls playermodel factory and meth to set\n        initial player cards.\"\"\"\n        library.StartVariables.new_players = self.Num_of_players.get() # int for Playerinfo toplevel window generation per player\n        library.StartVariables.player_rand = self.Num_of_players.get() # binds in 2nd location for later used in indexing\n\n        engine.active_player_creation() # creates list of session players for the game\n        PlayerInfo() # each player in session_players sets their name and gender in a toplevel window.\n\n\nclass PlayerInfo(tk.Toplevel):\n    \"\"\"Top level for players to enter names and gender. Must: update title label with player number, store variables\n    from entries, call game_loop with index para, increment index\"\"\"\n    label_counter = 1 # player identity title number for arbitrary label ie Player 1\n    list_indexer = 0 # index to access correct player instance in list. Ensures player details are bound to the correct instance\n\n    def __init__(self):\n        tk.Toplevel.__init__(self)\n        \"\"\"throw-away vars for names/gender \"\"\"\n        self.instname = tk.StringVar()\n        self.instgender = tk.StringVar()\n        \"\"\"main toplevel setup\"\"\"\n        self.geometry('350x150+500+300')\n\n        self.mainframe = tk.Frame(self)\n        self.mainframe.pack(side='top', fill='both', expand=True)\n        self.mainframe.focus_set()  # focus on this window objects\n        self.mainframe.grab_set()  # make modal\n\n        self.arbitary = tk.Label(self.mainframe, text=f\"Player {PlayerInfo.label_counter}\") # unique title\n        self.arbitary.config(font=('castellar', 15, 'bold'), fg='blue')\n        self.arbitary.grid(column=0, row=0, columnspan=2, sticky='n,e,s,w')\n\n        self.namelab = tk.Label(self.mainframe, text='Name: ')\n        self.namelab.grid(column=1, row=1, sticky='w')\n        self.nameent = tk.Entry(self.mainframe, textvariable=self.instname)\n        self.nameent.grid(column=2, row=1, sticky='w,e')\n        self.nameent.focus_set()\n\n        self.genderlab = tk.Label(self.mainframe, text='Gender: ')\n        self.genderlab.grid(column=1, row=2, sticky='w')\n        self.instgender.set(\"male\") # creates default\n        self.nameent = ttk.Combobox(self.mainframe, textvariable=self.instgender, values=[\"Male\", \"Female\"])\n        self.nameent.grid(column=2, row=2, sticky='w')\n\n        self.but2 = tk.Button(self.mainframe, text='Confirm', command=self.initial_set)\n        self.but2.config(bd=10, activebackground='green')\n        self.but2.grid(column=2, row=4, columnspan=2, sticky='n,e,s,w')\n        self.bind('<Return>', self.initial_set)  # alternative to button press\n\n    def initial_set(self, event=None):\n        \"\"\"Primary function: call method == session_players[list_indexer] for player instance setting name and gender,\n        & set a random player binding to active_player.\n        Secondary requirements: Increments arbitrary label_counter & counts down from the number of players in-game\n        ensuring all get attribute assignment. \"\"\"\n\n        players_assign = library.StartVariables.new_players # players_assign  = total players_assign of players in play ie 4.\n        if players_assign >= 1: # loop wont work as branch needs to be restarted per player\n            players_assign -= 1 # decreases the num of new pLayer integer to count down players_assign of players left to assign\n            PlayerInfo.label_counter += 1 # increase player counter for arbitrary label in class scope\n            library.PlayerAttribs.player_name = self.instname.get() # gameVar atrib is used to store the entered player name.\n            library.PlayerAttribs.player_gender = self.instgender.get() # entered gender binds to gameVar\n            engine.player_name_gender(PlayerInfo.list_indexer) # method to index session_players list for specific player and set name and gender attribs\n            PlayerInfo.list_indexer = PlayerInfo.list_indexer + 1 # increases index value so looping will call next player in session_players list\n            PlayerInfo.destroy(self) # destroys toplevel window wiping all entered info for next player to enter\n            library.StartVariables.new_players = players_assign # gamevar is bound to the new value for players_assign\n\n            if players_assign != 0: # loop for next player\n                PlayerInfo() # rebuilds toplevel anew for next player\n            else:\n                \"once all player attribs have been set\"\n                PlayerInfo.destroy(self) # final destruction of top window\n                #~~~~~~~~ debug loop\n                print(\"\\nPlayers in game:\", end=\" \")\n                for players in library.GameObjects.session_players: # loop to see all player names\n                    print(players.name.title(), end=\", \") # checks all players names assigned in session_players\n                print(\"\\n...............\")\n                #~~~~~~~~~~~~~~~\n\n                engine.set_random_player() # gets a random player from the active player list, auto calls varbinging binding all variables.\n                app.update_attrib_frame() # updates all label variables from gameVar to MainLoop frame.\n                app.update_message(\"show\")\n                app.update_message(\"dev\") # dev addition message from the creator\n                app.show_frame(MainLoop) # calls next frame to raise by controller\n                ########## deal cards to all players required\n\n\n####################################################################################################################\nclass MainLoop(tk.Frame):\n    \"\"\"MainLoop configures main window presenting all buttons and handlers for gameplay. The gameplay area is split into\n    3 domains player info, button console and table cards/message screen\"\"\"\n\n    def __init__(self, parent, controller):\n        tk.Frame.__init__(self, parent)\n\n        \"frame for buttons - may create some buttons to inherit style from \"\n        self.butframe = tk.LabelFrame(self, text='Navigation')\n        self.butframe.config(bg=\"darkgrey\", fg=\"red\")\n        self.butframe.pack(side='bottom', fill='x', ipady=80)\n\n        self.end_turn_button = tk.Button(self.butframe, text=\"End Turn\", command=self.end_turn)\n        self.end_turn_button.config(activebackground='#0ABF28', bg=\"#B40BEE\", padx=15, pady=20)\n        self.end_turn_button.place(x=600, y=45)\n\n        self.door_button = tk.Button(self.butframe, text=\"Kick Door\", command=self.door)\n        self.door_button.config(activebackground='#0ABF28', bg=\"#082EF6\", padx=5, pady=10)\n        self.door_button.place(x=350, y=45)\n\n        self.weapons_button = tk.Button(self.butframe, text=\"Weapons\", command=self.list_weapons)\n        self.weapons_button.place(x=250, y=10)\n        self.armor_button = tk.Button(self.butframe, text=\"Armour\", command=self.list_armor)\n        self.armor_button.place(x=225, y=45)\n        self.consumables_button = tk.Button(self.butframe, text=\"Consumables\", command=self.consumables)\n        self.consumables_button.place(x=250, y=80)\n\n        self.sell_button = tk.Button(self.butframe, text=\"Sell\", command=self.list_sell)\n        self.sell_button.config(padx=15)\n        self.sell_button.place(x=450, y=10)\n        self.sack_button = tk.Button(self.butframe, text=\"Sack\", command=self.list_sack) ########### used as dummy atm\n        self.sack_button.config(padx=10)\n        self.sack_button.place(x=475, y=45)\n        self.equipped_button = tk.Button(self.butframe, text=\"Equipped items\", command=self.list_equipped)\n        self.equipped_button.place(x=450, y=80)\n\n        self.interfere_button = tk.Button(self.butframe, text=\"Interfere\", command=self.interfere)\n        self.interfere_button.place(x=10, y=50)\n        self.ask_for_help_button = tk.Button(self.butframe, text=\"Help/Trade\", command=self.ask_for_help)\n        self.ask_for_help_button.place(x=10, y=100)\n\n        self.fight_button = tk.Button(self.butframe, text=\"Fight!\", command=self.fight, state=\"disabled\")\n        self.fight_button.place(x=100, y=50)\n        self.run_away_button = tk.Button(self.butframe, text=\"Run!!\", command=self.run, state=\"disabled\")\n        self.run_away_button.place(x=100, y=100)\n\n        self.private_items_button = tk.Button(self.butframe, text=\"Hand\", command=self.hand)  # for hidden objects\n        self.private_items_button.place(x=365, y=100)\n\n        self.satatus_effect_button = tk.Button(self.butframe, text=\"Status Effects\", command=self.status_effect)# for player curses\n        self.satatus_effect_button.place(x=600, y=10)\n\n        # self.b14 = tk.Button(self.butframe, text=\"Update info\", command=self.update_info)  # for hidden objects\n        # self.b14.place(x=10, y=10)\n\n        \"frame player attribs\"\n        self.plframe = tk.LabelFrame(self, text='Player Info')\n        self.plframe.config(pady=20)\n        self.plframe.pack(side='left', fill=\"y\", ipadx=50)\n\n        player_info = {\"Name: \": controller.name, \"Gender: \": controller.gender,\n                       \"Level: \": controller.level, \"Bonus: \": controller.bonus, \"Wallet: \": controller.wallet,\n                       \"Race: \": controller.race, \"Class: \": controller.klass}\n\n        player_defence = {\"L_hand: \": controller.l_hand, \"R_hand: \": controller.r_hand, \"two_hand: \": controller.two_hand,\n                           \"Head Gear: \": controller.headgear, \"Armor: \": controller.armor, \"Knees: \": controller.knees,\n                           \"Foot gear: \": controller.footgear, \"Necklace\": controller.necklace}\n        row = 0\n        for key, val in player_info.items():\n            self.l1 = tk.Label(self.plframe, text=key.title())\n            self.l1.grid(row=row, column=1, sticky='nsew')\n            self.l1b = tk.Label(self.plframe, textvariable=val)  ## works binding strait to stringvar in Main\n            self.l1b.grid(row=row, column=2, sticky='nsew')\n            row += 1\n        \"To work with player supermunch/halfbreed meths to turn on\"\n        self.race2_option = tk.Label(self.plframe, text=\"Race_2:\")\n        self.race2_optionb = tk.Label(self.plframe, textvariable=controller.race2)\n        self.klass2_option = tk.Label(self.plframe, text=\"Class_2:\")\n        self.klass2_optionb = tk.Label(self.plframe, textvariable=controller.klass2)\n        row = 10\n        for key, val in player_defence.items():\n            self.l1 = tk.Label(self.plframe, text=key.title())\n            self.l1.grid(row=row, column=1, sticky='nsew')\n            self.l1b = tk.Label(self.plframe, textvariable=val)  ## works binding strait to stringvar in Main\n            self.l1b.grid(row=row, column=2, sticky='nsew')\n            row += 1\n\n        \"Game Window\"\n        self.tblframe = tk.LabelFrame(self, text='Table') # main back window\n        self.tblframe.config(bg='lightgrey')\n        self.tblframe.pack(fill=\"both\", expand=True)\n\n        self.notifications = tk.Frame(self.tblframe)\n\n        self.notifications.pack(side=\"top\", fill=\"x\", expand=True)\n\n        self.message = tk.Label(self.notifications, textvariable=controller.message)\n        self.message.pack(side=\"top\", fill=\"x\", expand=True)\n        self.message2 = tk.Label(self.notifications, textvariable=controller.message2)\n        self.message2.pack(side=\"top\", fill=\"x\", expand=True)\n\n        self.canvas = tk.Canvas(self.tblframe, height=450) # canvas not dynamically expanding\n        self.canvas.config(bg=\"black\")\n        self.canvas.pack(side=\"top\", expand=True, fill=\"both\") # without self should now be accessible for the class....\n        self.img = \"\"\n\n    \"Handlers\"\n    def end_turn(self):\n        \"\"\"require method to be called from gameloop to rebase all variables in guivar. this should update the var in Mainloop\n        with app.update_frame() method call\"\"\"\n        # meth for checking sack size of player\n        library.CardDraw.door_attempts_remaining = 1 # resets door kicks for next player.. Should change to false\n        self.canvas.delete(\"all\")  # clears the canvas(table) for new player\n        # Methods that need to be applied to a player for next turn.\n        self.door_button.config(state=\"normal\") # enables kick door button\n        self.weapons_button.config(state=\"normal\")  # weapons\n        self.armor_button.config(state=\"normal\")  # armor\n        self.sell_button.config(state=\"normal\")  # sell\n        self.fight_button.config(state=\"disabled\")  # fight\n        self.run_away_button.config(state=\"disabled\")  # run\n        # app.update_message() #clears all messages\n\n        engine.player_order(library.GameObjects.active_player) # sends active player rebind new player in game_loop\n        Tools.fluid_player_info() # adds or removes player class2/race2 option\n        app.update_message()  # clears all messages\n        app.update_message(\"show\") # updates main broadcast message\n        # self.message2.destroy() # destroys message2 for the dev mode\n        app.update_attrib_frame() # updates the tk.vars in Main under the instance controller.\n        print(\" Turn ended!\\n\", \".\"*10, \"\\n\")\n\n    def door(self):\n        \"\"\"Calls methods associated to kicking the door. End result is to move cards to the desired location ie on table\n        ready for fight (and display) or in to the players handCommits a player to game action by disabling buttons. \"\"\"\n\n        print(\"\\nKicking door method\")\n        # Commits player to game loop\n        self.message2.destroy()  # removes dev label\n        self.end_turn_button.config(state=\"disabled\") # disables end turn button, enabled at end of fight\n\n        # main actions, get card, define where it belongs activate static meths\n        door_card = engine.deal_handler(\"door\") # fetch a door card\n        engine.door_card_designator(door_card, door_attempts=library.CardDraw.door_attempts_remaining) # Assigns card to destination. switches on static meths of curses and monsters\n\n        # 1st attempt, gui setup\n        if library.CardDraw.door_attempts_remaining: # first kick of door (always get this at start of turn!) == 1(True)\n            print(\"VIEWING CARD\")\n\n            # display card\n            self.img = Tools.viewer(door_card[\"id\"]) # gets card id. needs self or garbage collected!\n            self.canvas.create_image(10, 10, image=self.img, anchor=\"nw\")# view card on canvas. will need meth for this to add cards in linear fashion\n\n            # broadcast new message\n            if door_card.get('type') != 'monster' and door_card.get('type') != 'curse': # General card that is NOT a mon or a curse\n                library.GameObjects.message = f\"Your card is: {door_card.get('name')}\"\n                app.update_message(\"show\") # update the broadcast message\n\n            # if monster set the following button configs.\n            if door_card[\"type\"] == \"monster\":\n                self.door_button.config(state=\"disabled\") # kick door NO MORE USE OF THE DOOR!\n                self.weapons_button.config(state=\"disabled\") # weapons\n                self.armor_button.config(state=\"disabled\") # armor\n                self.sell_button.config(state=\"disabled\") # sell\n                self.fight_button.config(state=\"normal\") # fight\n                self.run_away_button.config(state=\"normal\") # run\n\n            # other cards fall of bottom for the door_attempts_remaining catch to be set.\n\n\n                # 2nd attempt circumstance\n        elif library.CardDraw.door_attempts_remaining == 0:\n            print(\"2nd kick activated\")\n            library.GameObjects.message = f\"You have drawn a face down card that is placed in your hand\"\n            app.update_message(\"show\")  # update the broadcast message\n            self.img = Tools.viewer(0)  # gets card pic face down\n            self.canvas.create_image(10, 10, image=self.img, anchor=\"nw\") # puts door card face down\n            self.door_button.config(state=\"disabled\") # disables door button\n            self.end_turn_button.config(state=\"normal\")\n            app.update_message(\"show\")\n\n        # final end of methods\n\n        library.CardDraw.door_attempts_remaining = 0  # set to false after first kick, only monster will deactivate the button\n        Tools.fluid_player_info() # updates any changes cause by status effecting cards to the player............................right place?\n        print(\"Door attempts:zero= last attempt:: \", library.CardDraw.door_attempts_remaining)\n\n    # def update_info(self): # may be redundant for TOOLS fluid_player_info just button link left\n    #     \"\"\"method to update a player info window with any changes ie halfbreed ect\"\"\"\n    #     if gameVar.GameObjects.active_player.race_unlock: # packing for klass and race in the event of supermunch ect\n    #         self.race2_option.grid(row=8, column=1, sticky='nsew')\n    #         self.race2_optionb.grid(row=8, column=2, sticky='nsew')\n    #     if gameVar.GameObjects.active_player.klass_unlock:\n    #         self.klass2_option.grid(row=9, column=1, sticky='nsew')\n    #         self.klass2_optionb.grid(row=9, column=2, sticky='nsew')\n\n    def fight(self):\n        #Todo next job sort this mess and add in monster selector TL\n        \"\"\" selecting monster and fighting\"\"\"\n        # while cards.in_play >= 1:\n        #     # chooses monster to fight\n        #     #\n        #     # remove monster set\n        print(\"Fight button pressed\") # TEST\n        #fight select setup\n        cards_set = cards.in_play[cards.fight_index][0] # grabs the card set for the fight\n        print('the monstrer u will be fighting is:')\n        print(cards_set) # WORKING , need to change card on table to match..\n        # player_obj = library.GameObjects.active_player #\n        # print(player_obj.armor)\n        # card = cards.in_play[0][0] # specific call to the card\n        # print(f\"the monster is {card['name']}\")\n        # player_obj.card_meths(card, method_bs='on') #  can throw more cards in here from the library.card_transfer list\n        # print(player_obj.armor)\n        # print(f'burn cards: {len(cards.burn_pile)}')\n\n\n\n\n        # if len(cards.in_play) > 1:\n        #     # run monster selection toplevel selector\n        #     print('more than one monster present!!!!!!!!!!!')\n        #     pass\n        #\n        # else:\n        #     # grab first card\n        #     self.selected_card = cards.in_play[0][0] # [fight selector], [monster selector/enhancer selector]. to be defined by monster selector tl\n        #     print(self.selected_card, id(cards.in_play))\n        # # player_obj.card_meths(self.selected_card, static='on') # turns on any card meths associated with monster DO NOT PUT STATIC METH HERE!\n        #\n        # selfobj = app.frames[MainLoop] # what is this doing?\n        #\n        # result = engine.fight() # helper may be added when sorting it <----------- HERE to add to for selection\n        #\n        # app.update_message(\"show\") # name and lvl of monster\n        # if result == \"win\":\n        #     self.canvas.delete(\"all\") # clears the canvas, not quite right as will remove all cards\n        #     print('remove off canvas?????? ')\n        #     # pass # remove single card off tablecards off table\n        # elif result == \"loose\":\n        #     pass # clears table runs card method\n        #\n        # self.fight_button.config(state=\"disabled\")  # fight\n        # self.run_away_button.config(state=\"disabled\")  # run\n        # self.door_button.config(state=\"disabled\")  # kick door\n        #\n        # # remove card form list and canvas ect\n        self.end_turn_button.config(state=\"normal\") # end turn\n        self.weapons_button.config(state=\"normal\")  # weapons\n        self.armor_button.config(state=\"normal\")  # armor\n        print(\"End of Fight\\n\")\n        Tools.fluid_player_info()\n\n    def run(self):\n        player = library.GameObjects.active_player\n        if player.run_away: # checks ability to run from player attrib\n            result = engine.run()\n            if result == \"success\":\n                self.end_turn_button.config(state=\"normal\")  # end turn\n                self.fight_button.config(state=\"disabled\")  # fight\n                self.run_away_button.config(state=\"disabled\")  # run\n                self.canvas.delete(\"all\")  # clears the canvas, not quite right as will remove all cards TAG maybe?\n            else:\n                library.GameObjects.message = \"You are trapped! All that is left is to fight!\"\n                app.update_message(\"show\")\n                self.run_away_button.config(state=\"disabled\")  # run\n\n        else:\n            library.GameObjects.message = \"This is not a fight you can run from!\"\n            app.update_message(\"show\")\n            self.run_away_button.config(state=\"disabled\")  # run\n\n    def list_weapons(self):\n        \"\"\" builds a list of cards that meet the the weapons criterion. List is bound to gameVar..selected_items \"\"\"\n        library.GameObjects.message = \"Weapons list\"\n        app.update_message(\"show\")\n        engine.scrub_lists()\n        player = library.GameObjects.active_player\n        player.inventory(\"type\", \"weapon\") # key= 'type', value = 'weapon'\n        # print(gameVar.GameObjects.selected_items)  list all items placed in list that meet the criteria above.\n        OwnedItems(\"Weapons owned\", \"weap\")\n\n    def list_armor(self):\n        library.GameObjects.message = \"Armour list\"\n        app.update_message(\"show\")\n        engine.scrub_lists()\n        player = library.GameObjects.active_player\n        player.inventory(\"type\", \"armor\") # load all weapons items into gamevar.selected_items\n        OwnedItems(\"Armor Owned\", \"armor\")\n\n    def consumables(self):\n        library.GameObjects.message = \"Consumable items\"\n        app.update_message(\"show\")\n        engine.scrub_lists()\n        player = library.GameObjects.active_player\n        player.inventory(\"type\", \"disposable\")\n        OwnedItems(\"One shot items\", \"consume\")\n\n    def list_sell(self):\n        \"\"\"builds toplevel with sellable items\"\"\"\n        library.GameObjects.message = \"Sell selected\"\n        app.update_message(\"show\")\n        engine.scrub_lists() # resets all lists for next action\n        player = library.GameObjects.active_player # gets current player\n        player.item_by_key(\"sell\") # generates list of sellable cards passed on to gameVar.selected_items\n        # print(gameVar.StartVariables.selected_items) # call method that in gamefile that creates zip\n        OwnedItems(\"Sellable Items\", \"sell\") # calls toplevel with window title\n\n    def hand(self):\n        library.GameObjects.message = \"Hidden items selected\"\n        app.update_message(\"show\")\n        engine.scrub_lists()\n        player = library.GameObjects.active_player\n        player.inventory(\"category\", \"door\")\n        OwnedItems(\"Hidden Items\", \"hidden\")\n\n    def interfere(self): #will link to player select toplvl window that then add an action . may need to look at card_matcher to be more flexible\n        library.GameObjects.message = \"Toplevel window where another player can interfere with play\\n NOT SET UP\"\n        app.update_message(\"show\")\n        RadioSelector('interfere')\n\n    def ask_for_help(self): #mot set\n        library.GameObjects.message = \"Toplevel window where another player can help... for a price..\"\n        app.update_message(\"show\")\n        Table_Target_Selector()\n\n    def list_sack(self):\n        \"\"\"shows all items in sack\"\"\"\n        library.GameObjects.message = \"The contents of sack:\"\n        app.update_message(\"show\")\n        engine.scrub_lists()\n        player = library.GameObjects.active_player\n        player.inventory(\"category\", \"treasure\")\n        OwnedItems(\"Sack Items\")\n\n    def list_equipped(self):\n        \"\"\"list showing all items that are equipped\"\"\"\n        engine.scrub_lists()\n        player = library.GameObjects.active_player\n        player.equipped_items(\"list_equipped\")\n        OwnedItems(\"Equipped Items\", \"remove\")\n\n    def status_effect(self):\n        \"\"\"method for showing what status effect are active on the current player\"\"\"\n        RadioSelector('monster_select')\n\n        # self.img = Tools.viewer(cards.in_play[cards.fight_index][0][\"id\"])  # updates canvas?????? NOPE..\n        # self.canvas.create_image(30, 30, image=self.img, anchor=\"nw\")\n\n\nclass OwnedItems(tk.Toplevel):\n    \"\"\"Generates toplevel from cards place in gameVar.GameObjects.selected_items where selections can be made on those cards.\n    Buttons will be dependent upon the type of cards selected prior.\"\"\"\n    def __init__(self, wind_title=\"Template\", set_but=\"No Buttons\"): #title and buttons to be used for items\n        tk.Toplevel.__init__(self)\n        self.title(wind_title)\n        # self.geometry(\"350x250+200+200\")\n        self.set_but = set_but\n        # print(f\"Top level self: {self}\")\n\n        if not library.GameObjects.selected_items: # if nothing in list display a label message\n            fm = tk.Frame(self)\n            fm.pack(side=\"top\", expand=True)\n            tk.Label(fm, text=\"No cards to show\").pack(side='top')\n\n        # main toplevel window for displaying items and button choices dependent on the set_but string\n        else:\n            f = tk.Frame(self)\n            f.pack(side=\"top\", expand=True)\n            tk.Label(f, text=\"Name\").grid(row=0, column=0, sticky=\"nw\")# column titles\n            tk.Label(f, text=\"Type\").grid(row=0, column=1, sticky=\"nw\")\n            if self.set_but == \"sell\":\n                tk.Label(f, text=\"Value\").grid(row=0, column=2, sticky=\"nw\") # column title if item has gold value\n            # elif self.set_but == \"hidden\":\n            #     pass\n            elif self.set_but in \" weap, armor, consume, equip, remove\":# same column title requirement\n                tk.Label(f, text=\"Bonus\").grid(row=0, column=2, sticky=\"nw\") # column title set to Bonus to see bonus values for items\n            # else:\n            #     tk.Label(f, text=\"Bonus\").grid(row=0, column=2, sticky=\"nw\")\n            tk.Label(f, text=\"Select\").grid(row=0, column=3, sticky=\"nw\") # title column for check boxes\n\n            # specific labels and tk variable\n            set_row = 1 # row incrementor for loop\n            for card in library.GameObjects.selected_items: # for each card in the selected items\n                status = tk.IntVar() # for keeping track of check buttons, 1 per loop ###\n                tk.Label(f, text=card['name']).grid(row=set_row, column=0, sticky=\"nw\")\n                tk.Label(f, text=card['type']).grid(row=set_row, column=1, sticky=\"nw\")\n                if self.set_but == \"sell\":\n                    tk.Label(f, text=card['sell']).grid(row=set_row, column=2, sticky=\"nw\")\n                elif self.set_but in \" weap, armor, consume, equip, remove\":\n                    tk.Label(f, text=card['bonus']).grid(row=set_row, column=2, sticky=\"nw\")\n                if set_but != \"No Buttons\":\n                    tk.Checkbutton(f, text=\" \", variable=status).grid(row=set_row, column=3, sticky=\"nw\")\n                tk.Button(f, text=\"Info\", command=lambda c=card[\"id\"]: self.showcard(c)).grid(row=set_row, column=4)\n\n                library.GameObjects.check_but_intvar_gen.append(status) # creates list of IntVars for each item in list\n                library.GameObjects.check_but_card_ids.append(card[\"id\"]) # sends card ids int to list\n                set_row += 1\n\n        # specific buttons\n        if self.set_but in \"weap, armor, sell\":\n            tk.Button(self, text=\"Sell\", command=self.sell).pack(side=\"left\")\n        if self.set_but in \"consume, hidden\":\n            tk.Button(self, text=\"Use item\", command=self.use_item).pack(side=\"left\")\n        if self.set_but in \"weap, armor\": # == \"weap\" or self.set_but == \"armor\":##### added hidden for wandering mon ect\n            tk.Button(self, text=\"Equip\", command=self.equip).pack(side=\"left\")\n        if self.set_but == \"remove\":\n            tk.Button(self, text=\"Remove\", command=self.remove).pack(side=\"left\")\n\n    def showcard(self, card_id):\n        \"\"\" Method for showing the card in a toplevel window\"\"\"\n        CardVeiw(card_id)\n\n    def sell(self):\n        \"\"\"triggers sell event when pushed\"\"\"\n        Tools.common_set(\"sell\")# calls zipper with param\n        Tools.fluid_player_info() # calls an update method for gui to show all player changes, also cleans lists from zipper\n        OwnedItems.destroy(self) # destroys toplevel window\n        app.update_message(\"show\")\n\n    def equip(self):\n        Tools.common_set(\"equip\")\n        Tools.fluid_player_info()\n        OwnedItems.destroy(self)\n\n        app.update_message(\"show\")\n\n    def use_item(self): #hidden items path hand and consume lead here\n        \"\"\"for consumables and hidden objects\"\"\"\n        Tools.common_set(\"disposable\") #\n        Tools.fluid_player_info() # adds or removes player class2/race2 option\n        OwnedItems.destroy(self)\n        app.update_message(\"show\")\n\n    def remove(self):\n        Tools.common_set(\"remove\")\n        Tools.fluid_player_info()\n        OwnedItems.destroy(self)\n        app.update_message(\"show\")\n\n\nclass RadioSelector(tk.Toplevel): # In production\n    \"\"\" A toplevel window to select the monster a player wishis to fight in the event there is more than 1 on the table\"\"\"\n    def __init__(self, action):\n        tk.Toplevel.__init__(self)\n        print('in top lvl')\n        self.action = action # string input defining setup for objects\n        self.focus_set()  # focus on this window objects\n        self.grab_set()  # make modal\n        self.geometry('250x150+500+300')\n        self.title('Monster Selector')\n        self.var = tk.IntVar()\n        self.list_of_interest = []\n\n        self.mainframe = tk.Frame(self)\n        self.mainframe.pack(side='top', fill='both', expand=True)\n        count = 1\n        monsters = [x[0] for x in library.cards.in_play]\n        # get list of required iterable lists\n        if self.action == 'monster_select': # monsters only to choose from\n            self.list_of_interest = monsters\n        elif self.action == 'interfere': # all monsters and players to choose from\n            self.list_of_interest = monsters + library.GameObjects.session_players\n\n        for all_obj in self.list_of_interest:\n            self.radio = tk.Radiobutton(self.mainframe, variable=self.var, value=count-1)\n            if isinstance(all_obj, dict): # monster cards are in dict form\n                self.radio.config(text=f'{all_obj[\"name\"]}'f' Level: {all_obj[\"lvl\"]}') # configs radio button specific to monsters.\n                tk.Button(self.mainframe, text=\"Info\",\n                          command=lambda c=all_obj[\"id\"]: self.showcard(c)).grid(row=count, column=2) # provides card view of monster\n            else:#\n                self.radio.config(text=f'{all_obj.name}'f' Level: {all_obj.level}') # configs radio specific to players\n            self.radio.grid(row=count, column=1)\n            count += 1\n\n        self.buttonframe = tk.Frame(self)\n        self.buttonframe.pack()\n        tk.Button(self.buttonframe, text='Select', command=self.select).pack()\n\n    def select(self):\n        print('In handler ~Need to sort setting position for fight')\n        engine.radio_selector_handler(self.var.get(), self.list_of_interest) #send index and the list where the index has relevance\n        # print('Item of iterst is:', self.list_of_interest[self.var.get()])\n        self.destroy()\n\n    def showcard(self, card_id):\n        \"\"\" Method for showing the card in a toplevel window\"\"\"\n        CardVeiw(card_id)\n\n\nclass Table_Target_Selector(tk.Toplevel):\n    \"\"\"class for interference selection\"\"\"\n\n    # player = gameVar.GameObjects.active_player\n    # all_players = gameVar.GameObjects.session_players\n\n    def __init__(self):\n        tk.Toplevel.__init__(self)\n        self.title('Target Selector')\n        self.frame = tk.Frame()\n\n        self.player = library.GameObjects.active_player\n        self.all_players = library.GameObjects.session_players\n\n        self.frame.pack(fill='both', expand=True)\n        # print(self.all_players)\n        print(\"cards in play:\", cards.in_play)\n\n        # for object in Table_Target_Selector.all_players + table.cards.in_play:\n        #     print(object)\n\n\nclass CardVeiw():\n    \"\"\"Places image in a toplevel window in own canvas\"\"\"\n    def __init__(self, card_id=None):\n        # path = \"..\\\\imgs\\\\cards\\\\\"\n        # PIC = os.path.abspath(r\"..\\imgs\\cards\")\n        win = tk.Toplevel()\n        win.title(\"Card Info\")\n        img = Tools.viewer(card_id) # returns ImageTk.PhotoImage from file breadcrumb\n        # img = ImageTk.PhotoImage(file=PIC + f\"\\\\{str(card_id)}.png\")\n\n        can = tk.Canvas(win)\n        can.pack(fill=tk.BOTH)\n        can.config(width=img.width(), height=img.height())\n        can.create_image(2, 2, image=img, anchor=tk.NW)  # x, y coordinates\n        win.mainloop()\n\n\nclass Tools:\n    \"\"\"method sets to uphold dry programing\"\"\"\n\n    # def __init__(self, keyword):\n    #     self.key_word = keyword\n    @staticmethod\n    def common_set(action):\n        engine.zipper(action)  # calls card_matcher() passing the parameter to it.\n        # engine.varbinding(gameVar.GameObjects.active_player)\n        # app.update_frame()\n\n    @staticmethod\n    def fluid_player_info():\n        \"\"\"class for showing individual player info ie klass2 race2 and updating any changes that may affect the player\"\"\"\n        selfid = app.frames[MainLoop]  # simplifies attachment to value for direct access.\n\n        if not library.GameObjects.active_player.race_unlock: # linked to player flag triggered by specific card.\n            selfid.race2_option.grid_forget()\n            selfid.race2_optionb.grid_forget()\n        else:\n            selfid.race2_option.grid(row=8, column=1, sticky='nsew')\n            selfid.race2_optionb.grid(row=8, column=2, sticky='nsew')\n        if not library.GameObjects.active_player.klass_unlock:\n            selfid.klass2_option.grid_forget()\n            selfid.klass2_optionb.grid_forget()\n        else:\n            selfid.klass2_option.grid(row=9, column=1, sticky='nsew')\n            selfid.klass2_optionb.grid(row=9, column=2, sticky='nsew')\n\n        engine.player_attrib_ipc_updater(library.GameObjects.active_player) # ensures all player info is up to\n        # date and sent to gameVar\n        app.update_attrib_frame() # updates the GUI with the new player info\n        engine.scrub_lists() # clears all the lists for zipper ect for fresh search\n\n    @staticmethod\n    def viewer(card_id=None):\n        \"\"\"use PhotoImage to get the image from a path that can change dependent of os\"\"\"\n\n        # path = \"..\\\\imgs\\\\cards\\\\\" # this path will not work on linux requires os module and resolve() method\n        # img = ImageTk.PhotoImage(file=f\"{path}{str(card_id)}.png\") #dependent on windows os\n        BASE_DIR = Path(__file__).resolve().parent.parent\n        try:\n            img = ImageTk.PhotoImage(file=os.path.join(BASE_DIR, 'imgs', 'cards', f'{str(card_id)}.png')) # works regardless of os\n        except FileNotFoundError:\n            img = ImageTk.PhotoImage(file=os.path.join(BASE_DIR, 'imgs', 'cards', f'{str(0)}.png'))\n        return img\n\n\nif __name__ == \"__main__\":\n    app = Main()\n\n    app.mainloop()\n\n# Main().mainloop(), # removes the instance (self) which is needed for later activities\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/GUI/view.py b/Munchkin/bin/GUI/view.py
--- a/Munchkin/bin/GUI/view.py	(revision 824e26d9dd3021129d41aaa602f27bdc62551c47)
+++ b/Munchkin/bin/GUI/view.py	(date 1651148205420)
@@ -505,15 +505,60 @@
     def fight(self):
         #Todo next job sort this mess and add in monster selector TL
         """ selecting monster and fighting"""
+        print("Fight button pressed")
+        if len(cards.in_play) > 1: # more than 1 monster on the table
+            card_set = cards.in_play[library.Fight_enhancers.card_selector_index] # gets index of card produced by radio selector
+        print('the card set u will be facing is:')
+        print(card_set) #will return the card set for all cards associated to this monster inc monster
         # while cards.in_play >= 1:
-        #     # chooses monster to fight
+        #     # chooses monster to
+
+        # player_obj = library.GameObjects.active_player #
+        # print(player_obj.armor)
+        # card = cards.in_play[0][0] # specific call to the card
+        # print(f"the monster is {card['name']}")
+        # player_obj.card_meths(card, method_bs='on') #  can throw more cards in here from the library.card_transfer list
+        # print(player_obj.armor)
+        # print(f'burn cards: {len(cards.burn_pile)}')
+
+
+
+
+        # if len(cards.in_play) > 1:
+        #     # run monster selection toplevel selector
+        #     print('more than one monster present!!!!!!!!!!!')
+        #     pass
+        #
+        # else:
+        #     # grab first card
+        #     self.selected_card = cards.in_play[0][0] # [fight selector], [monster selector/enhancer selector]. to be defined by monster selector tl
+        #     print(self.selected_card, id(cards.in_play))
+        # # player_obj.card_meths(self.selected_card, static='on') # turns on any card meths associated with monster DO NOT PUT STATIC METH HERE!
+        #
+        # selfobj = app.frames[MainLoop] # what is this doing?
+        #
+        # result = engine.fight() # helper may be added when sorting it <----------- HERE to add to for selection
+        #
+        # app.update_message("show") # name and lvl of monster
+        # if result == "win":
+        #     self.canvas.delete("all") # clears the canvas, not quite right as will remove all cards
+        #     print('remove off canvas?????? ')
+        #     # pass # remove single card off tablecards off table
+        # elif result == "loose":
+        #     pass # clears table runs card method
+        #
+        # self.fight_button.config(state="disabled")  # fight
+        # self.run_away_button.config(state="disabled")  # run
+        # self.door_button.config(state="disabled")  # kick door
+        #
+        # # remove card form list and canvas ect
+        self.end_turn_button.config(state="normal") # end turnfight
         #     #
         #     # remove monster set
-        print("Fight button pressed") # TEST
+        # TEST
         #fight select setup
-        cards_set = cards.in_play[cards.fight_index][0] # grabs the card set for the fight
-        print('the monstrer u will be fighting is:')
-        print(cards_set) # WORKING , need to change card on table to match..
+
+
         # player_obj = library.GameObjects.active_player #
         # print(player_obj.armor)
         # card = cards.in_play[0][0] # specific call to the card
@@ -630,7 +675,8 @@
     def ask_for_help(self): #mot set
         library.GameObjects.message = "Toplevel window where another player can help... for a price.."
         app.update_message("show")
-        Table_Target_Selector()
+        # Table_Target_Selector() # depreciated for radioselector
+        RadioSelector('help')
 
     def list_sack(self):
         """shows all items in sack"""
@@ -748,7 +794,9 @@
 
 
 class RadioSelector(tk.Toplevel): # In production
-    """ A toplevel window to select the monster a player wishis to fight in the event there is more than 1 on the table"""
+    """ A toplevel window presenting radio buttons for selection of monsters, players or both given a criteria.
+    End result is to generate a index and a list relative to the list created or a list in play.
+    """
     def __init__(self, action):
         tk.Toplevel.__init__(self)
         print('in top lvl')
@@ -763,15 +811,18 @@
         self.mainframe = tk.Frame(self)
         self.mainframe.pack(side='top', fill='both', expand=True)
         count = 1
-        monsters = [x[0] for x in library.cards.in_play]
+        monsters = [x[0] for x in library.cards.in_play] # loops over each cardset the x[0] gets first dict in the list returned
         # get list of required iterable lists
         if self.action == 'monster_select': # monsters only to choose from
             self.list_of_interest = monsters
         elif self.action == 'interfere': # all monsters and players to choose from
             self.list_of_interest = monsters + library.GameObjects.session_players
+        elif self.action == 'help':
+            self.list_of_interest = library.GameObjects.session_players
 
         for all_obj in self.list_of_interest:
             self.radio = tk.Radiobutton(self.mainframe, variable=self.var, value=count-1)
+
             if isinstance(all_obj, dict): # monster cards are in dict form
                 self.radio.config(text=f'{all_obj["name"]}'f' Level: {all_obj["lvl"]}') # configs radio button specific to monsters.
                 tk.Button(self.mainframe, text="Info",
@@ -786,9 +837,9 @@
         tk.Button(self.buttonframe, text='Select', command=self.select).pack()
 
     def select(self):
-        print('In handler ~Need to sort setting position for fight')
+        """Passes index and list to controller.py for sorting"""
         engine.radio_selector_handler(self.var.get(), self.list_of_interest) #send index and the list where the index has relevance
-        # print('Item of iterst is:', self.list_of_interest[self.var.get()])
+        # print('Item of interest is:', self.list_of_interest[self.var.get()])
         self.destroy()
 
     def showcard(self, card_id):
@@ -796,26 +847,26 @@
         CardVeiw(card_id)
 
 
-class Table_Target_Selector(tk.Toplevel):
-    """class for interference selection"""
-
-    # player = gameVar.GameObjects.active_player
-    # all_players = gameVar.GameObjects.session_players
-
-    def __init__(self):
-        tk.Toplevel.__init__(self)
-        self.title('Target Selector')
-        self.frame = tk.Frame()
-
-        self.player = library.GameObjects.active_player
-        self.all_players = library.GameObjects.session_players
-
-        self.frame.pack(fill='both', expand=True)
-        # print(self.all_players)
-        print("cards in play:", cards.in_play)
-
-        # for object in Table_Target_Selector.all_players + table.cards.in_play:
-        #     print(object)
+# class Table_Target_Selector(tk.Toplevel):
+#     """class for interference selection"""
+#
+#     # player = gameVar.GameObjects.active_player
+#     # all_players = gameVar.GameObjects.session_players
+#
+#     def __init__(self):
+#         tk.Toplevel.__init__(self)
+#         self.title('Target Selector')
+#         self.frame = tk.Frame()
+#
+#         self.player = library.GameObjects.active_player
+#         self.all_players = library.GameObjects.session_players
+#
+#         self.frame.pack(fill='both', expand=True)
+#         # print(self.all_players)
+#         print("cards in play:", cards.in_play)
+#
+#         # for object in Table_Target_Selector.all_players + table.cards.in_play:
+#         #     print(object)
 
 
 class CardVeiw():
Index: Munchkin/docs/algorthum_mapper
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>MUNCHKIN\n\ncontents:\n    GAME GENERAL\n        SCRIP DEPENDENCIES\n    PLAY CYCLE\n        START\n        GAME LOOP\n        END TURN\n    CLASSES METHODS AND LOGIC\n    ALGORITHM MAPPER\n    PLANNED CHANGES\n\n****************************************************************************************************\n**************************************** GAME GENERAL ************************************\n****************************************************************************************************,\n\n\n######################################################\n# SCRIPT DEPENDENCIES\n######################################################\n\nview.py: provides front end logic and building blocks for GUI\n\nvariables_library.py (referred to as library): acts as a IPC script that view.py can interact with and controller.py\ncan change without creating conflicting imports and convoluted return statements.\nThis create a clear uncomplicated area that values may be seen, like game options, or stored without obfuscation.\n\ncontroller.py (referred to as engine): location of all the backend logic that called from the GUI, generic card methods\nfor sorting, player rotation, control of play and anything else that sits on top of the basic script logic.\nThis script imports table.py giving access to both doorcards.py & treasurercards.py and playermodel.py.\n\ntable.py: is modeled on a playing table and contains classes that relate to a dealer, dice and table. dealer will fetch\ncards from both doorcards.py & treasurercards.py returning the card back to the caller (usually engine).\nDuring a fight or when cards are discarded they go to the table. Recovery of cards from the burn pile is controlled\nby dealer.\n\nplayermodel.py: with set number of instances to prevent card shortage, this class creates the fundamental player.\nMethods in this class are indicative of those that cause change to the players individual info or relate to the player\nsome way. This calls inherits from  doorcards.MonCur so that method like curses can effect the player in question and\ntreasurecards.T_tools for methods associated to enchanted items. playersetup.py is also imported using the P-tools class.\nthis however has little functionality and may be absorbed into the player model.\n\ntreasurecards.py: contains all cards for the treasure deck. This is a list of nested ditcionaries containing all\ninformation relevent to any of the cards in question. treasurecards.py inherits from T_tools that contains a dictioanry of all\nmethods associated to a card as a value to the called key received from a card in or used during play.\n\n\n\n**********************************************************************************************\n****************************** play cycle *******************************\n**********************************************************************************************\n\n##################################################\nSTART\n##################################################\nstart gui (links to methods below)\nSelect number of players\nmenu options:\n    ### game options: number of cards in backpack, lvl to win, starting deal card number, permadeath.\n    ### start\nName of each player and gender\nDeal cards, 4 of each (changable in possible options)\nRandom player index\n\nEND RESULT: new list of player instances each with names, genders and set of cards.\n            random player selected from list and push to game loop\n            ### menu added\n\n################################################\nGAME LOOP:\n################################################\n\nCheck to see if player is alive (True), skip if False\nPlayer inventory actions, (gui selection process) = INVENTORY Method, Full access, (sell, equipment, use)\nPlayer initiates Door card to be drawn (on button press)\n\nCard is placed on table(visible) (outcomes A | B)\ncondition check outcomes\ninfo on outcome\n\n A: MONSTER: Menu Options (inspect, inventory, ask for help, fight, run, interfere)\n    INSPECT OPTION:\n        inspect all visible cards on table (players, monster)\n\n    INVENTORY OPTION:\n        player item select use item/s (implement effect) INVENTORY Method, Restricted access, NO equip!\n\n    HELP OPTION:\n        player ask others for aid, help(condition: gold/treasure)\n\n    INTERFERE option:\n        other player interference, selecting items to use for or against\n\n    FIGHT OPTION:\n        fight monster/s (first in list or selected...)\n        If monster has a static method (const effect) this need to be activated before any actions.\n        if additional players want to interfere/help action the methods\n\n\n        FIGHT OUTCOME:\n            Constant outcome:\n                any player specific objects used during fight removed from inventory (spent)\n                spent cards moved to Table burn_pile\n            Win specific:\n                any assisting players help condition met (if treasure distribute according to terms, gold transfer)\n                treasure distributed\n                level increase +n dependent on monster\n\n\n            Death/BADSTUFF:\n                if Death:\n                    # check win condition death if True remove player from player list\n                    player alive flag set to false\n                    death method for player atrib stripping\n                    branch for dead players to be reset and cards re-delt\n                    END PLAYER TURN\n                If BADSTUFF:\n                    referer to Monster card as associated methods (require processor function)\n\n\n            END FIGHT\n            Remove monster specific static methods\n\n    RUN OPTION:\n       check run attempt condition true or false (cant run from same monmster unless item allows)\n       other player/s interference option\n       if run true remove card from table list (add to burn pile list)\n       run attempt from each monster on the table (alternate between run and fight)\n       if Fail set run condition to False (removes/greys_out run option button for current monster)\n       END FIGHT IF RUN SUCCESSFUL\n       RETURN TO FIGHT IF UNSUCCESSFUL\n\n B:\n    NON FIGHTING CARD\n        condition to check type of card\n            if not curse card\n                move card player sack\n                look for trouble (draw card from hand)\n                GO TO FIGHT Method called\n            else: cursed:\n                apply status\n                draw a face down card\n\n\nEND FIGHT / END TURN CLEAN UP\n    check player level if win END Game function\n    check player sack max\n    option to access pack Method equipping, selling, use\n    menu: (inspect table, end turn)\n    inspect table (all player visible cards)\n    end turn button\n\n#####################################################\nEND TURN\n#####################################################\n Next player\n condition check alive\n    if alive == False and premdeath == False\n        reset condition\n        END TURN\n\n######################################################\n\n\n****************************************************************************************************\n**************************************** CLASSES METHODS AND LOGIC ************************************\n****************************************************************************************************\n\n\nPlayer class:\nclass for specific setup\ninitialisation\n    player attributes\n        self.ref = ref # simple form to keep track of players ( MAY CHANGE TO self.__str__() )\n        self.name = None # to be set when called\n        self.sex = None\n        self.level = 1 # win lvl 10, make changeable so edit score to win\n        self.bonus = 0\n        self.wallet = 0\n        self.race = {'r1': True, 'r2': False} # string eval to True so will show\n        self.klass = {'c1': True, 'c2': False}\n        self.weapons = {\"L_hand\": None, \"R_hand\": None, \"big\": None, \"special_1\": None, \"special_2\": False}\n        self.armor = {\"headgear\": None, \"armor\": None, \"armor1\": False, \"armor2\": False, \"footgear\": None,\n                      \"special_1\": None, \"special_2\": False, \"special_3\": False}\n        self.sack = [] # volume to be monitored\n        self.visible_cards = [] # cards visible on the table that have value\n        self.hireling = []\n        self.undefined = [] # unclassified objects for all the things i want but dont know it\n        self.alive = True\n        self.longevity = 1 # counts cycles alive, if 0 player misses go\n\n    char_setup\n        call meth to set up name (P_tools class)\n        call method to set up sex\n\n    inventory\n        method to set items to the player\n\n\nclass P_tools\n    all player related methods unclutter player class\n\n\ngui#### should (YES, IPC as better known) i have an intermediate gui script that holds all the variables? WORKING PROGRESS\n\nmain_gui reports(sets vars) to gui_var script and engine get all variables from gui var script\nthus main_gui imports gui_var and engine imports gui_var. gui can then call the classes of engine without moving any variables\nor changing the self parameter\n\n\n\nController:\n    Controller serves up pages(frames) that are raised to the top.\n    These are pre-build at the beginning\n    An update method is required that binds all tk.Vars to library scrip (updated from player model)\n\n\nPages:\n    start page-\n        welcomes with start button that progresses to options toplevel\n\n    options-\n        sets game options in variables_library.py.Options.  These will be game flags for certain activities\n        modal infobox detailing changes on conformation button press\n\n    player select-\n        spin box with player select. textvariable = num_of_players\n        button leads to player details playersetter method\n        playersetter-\n            num_of_players = IntVar() binds to 2 variables in library -\n                1) library.StartVariables.new_players that manipulates label in Toplevel\n                2) library.StartVariables.player_rand that drives the index for the instances in the list during selection\n\n\n        PlayerInfo:\n            provides a  generic player name with a box to enter name and gender\n            button to confirm either moves to another player name/gender or starts game loop\n            Information required:\n                method to check num of players\n                link to game var to bind plays name/gender\n                call of method in engine to bind attribs to the correct player\n                possible yield loop that takes player instance\n                order:\n                    while new_players =>1\n                    box pops up.\n                    player inputs info\n                    button is pushed\n\n                        calls player method\n                        for each instance (in order) from Maxplayers\n                            fetches variable_library and binds to player\n                            yields player\n\n                    calls next() method\n\n\nfor main play window the gui must have the librarys ready linking to the instance in question. button will change the\ninstance associated\n\nmainloop class to define a method to send index to game_loop class.\n\ncontroller.py:\n\n    controller.py main directive is to either source logic from other classes, provide one shot logic demanded by the\n    GUI and primarily to update variables_library.py  that can be accessed by view.py\n\n        Main class: PlayerSetup:\n            set_random_player method:\n                usees random choice function from the random module.\n                picks a random player instance from the generated active_players list\n                send result to verbinding method.\n\n            player_attrib_ipc_updater method:\n                accepts parameter of a player instance\n                uses instance to bind all player attributes to library\n\n\n    before MainLoop is called all tkVar need to be set up. this is handled by the controller by the method update_atrib_frame.\n    At the end of Playerinfo class method test, game_loop will use index to determine the correct player in library.active_players.\n    indexed player will bind self to library.player_atribs.x\n    controller.Main class binds self.x to StringVar()\n    Main.update_atrib_frame method binds all player attributes to tk Variables and the library script\n    This update method must be called to refresh/concurrent the labels in the play area\n\n\n\n***************************************************************************************************\n******************************** ALGORITHM MAPPER **************************************\n***************************************************************************************************\n\n#######################################################################\n# Game start and options methods\n#######################################################################\nDetailed method for start page and game options\n\ncontroller.StartPg, class\n    Presents two options start or options\n    - start button will call controller.show_frame(PlayerSelect) so that number of players can be selected from the spinbox\n    - options button will call toplevel GameOptions class\n\nstart button\n    controller.show_frame(PlayerSelect)\n        See player rotation method detailed in independent section bellow\n\nGameOptions, toplevel\n    presents options that change library.Options that act as flags for specific in game methods\n    Defaults are set in library. Options for are:\n        library.Options.cards_delt = self.inital_deal.get()     # number of each type of card to deal on start\n        library.Options.win_lvl = self.maxlvl.get()             # level needed to win game\n        library.Options.perm_death = self.permadeath.get()      # game death permanency\n        library.Options.carry_weight = self.carry_weight.get()  # number of cards that can be placed in sack\n    'Ok' button calls method setopts(self)\n\n    setopts(self), method\n        Fetches all tk variables and binds to all library variables.\n        creates a message variable with all f-string of all new values\n        messagebox.showinfo(title,contents) is called\n        messagebox.showinfo(\"Settings Changed!\", message) is called highlighting the changes\n\n    GameOptions.destroy(self), tk.method\n        toplevel with options is destroyed after acknowledging messagebox\n+\ncontroller.StartPg\nplayer can now either re-enter options of press start\n\n#######################################################################\n# Name/gender, random player to start and deal starting set of cards\n#######################################################################\nDetails method for setting a players name/gender, dealing each player a starter set of cards, setting random player to\nstart and binding that player to the active_player variable for a reference in the game scope for player attrib access.\n\nPlayerSelect(), class (views.py)\n    creates spinbox with textvariable=self.Num_of_players bound to tk.IntVar()\n    and Confirm Button that calls self.playersetter() method\n\n    playersetter(),  Button handler\n        library.StartVariables.new_players = self.Num_of_players.get()\n            pulls the number of selected players from the spinbox and binds within variable_library.py under StartVariables\n            new_players. This is the number of players wanted in the current game.\n\n        library.StartVariables.player_rand = self.Num_of_players.get()\n            Also uses the spinbox var for later indexing\n\n        engine.active_player_creation(), method\n            Calls Player.factory() for each player in range(library.StartVariables.new_players).\n            Each player is then added to the session_players list within the variables_library script.\n            method ends with a call to deal_handler(option='start') which deals cards to each player in the session_players list.\n            The amount assigned is dependent on the option provided before game start.\n\n            deal_handler(self, option, deal_amount=0), method\n            Flexible method created to deal cards either at start, after death or specific cards (door/treasure).\n            player.unsorted = cards.card_sop.deal_cards(\"start\", library.Options.cards_dealt)\n                Used to issue cards to all players. \"start\" parameter is used to define the the type of deal wanted.\n                This then loops over the players in session_players calling cards.card_sop.deal_cards() table.py\n\n                cards.card_sop.deal_cards(\"start\", library.Options.cards_dealt)\n                    Calls Table class and the card method card_sop for the Dealer class (a table has-a Dealer) with the\n                    method deal_cards. The arguments \"start\" and ameVar.Options.cards_dealt specify the mode of deal\n                    through the branch and the number of each card to deal laid out by the game options respectively.\n                    Card selection fo each type is randomised through the use of Random module.\n                    Cards are stored in the variable starter_set and returned to caller and bound to player.unsorted.\n                    This is a list of cards that associates to the individual player\n\n        PlayerInfo(), toplevel\n            Complex script to create a arbitrary name tag with incrementation number, set the name and gender of\n            the player, generate a random player to start and structure a game loop that loops over session_players.\n\n                class had 2 class variables:\n                    counter = 1  #  player identity title number for arbitrary label\n                    indexing = 0 # index to access correct player instance in session_players list and ensures\n                    details are bound to the correct player instance.\n                    note a 3rd is used but located in library (new_players) set by the playersetter method above.\n\n                Players enter their details and press \"confirm\" button that triggers initial_set (return button does\n                same thing).\n\n                    number = library.StartVariables.new_players\n\n                initial_set, method\n                    Branch is created for checking the number of players in library.StartVariables.new_players assigned\n                    to the variable name = number. Each time this method is called it reduces number by 1 ensuring that\n                    the final entry is the last to redraw the toplevel window. (number -= 1)\n\n                    PlayerInfo.counter += 1 is used to increase the number for the arbitrary player label\n\n                    library.PlayerAtribs.player_name = self.instname.get()\n                    library.PlayerAtribs.player_gender = self.instgender.get()\n                    Both bind the player attribs provided to the player name in library\n                    engine.player_name_gender(PlayerInfo.indexing) is then called\n\n                    engine.player_name_gender(PlayerInfo.indexing), engine class method\n                        player = library.StartVariables.session_players[playerindex]\n                            class indexing variable is used to pass to player_name_gender method to access the correct\n                            player in session_players.\n                            player is now a specific player instance\n\n                        player.char_setup() method is called to set and bind attrribs to players\n\n                        player.char_setup(), method\n                            calls P_tools.name() and xy = P_tools.name()\n                            return value of each is set as a player attribute\n                            if the return val is == to the dev mode other attribs will be attributed to the player\n\n                            P_tools.name()\n                                x = library.PlayerAtribs.player_name\n                                returns name stored in library with title method\n                                or dev mode name if criteria met\n\n                            P_tools.name()\n                            x = library.PlayerAtribs.player_gender\n                            return x.title()\n\n                    PlayerInfo.indexing = PlayerInfo.indexing + 1 is increased for the next player when passed back into\n                    engine.player_name_gender(self, playerindex)    NOTE: index == playerindex as it becomes method argument\n                    PlayerInfo.destroy(self) is called to destroy the toplevel window\n                    library.StartVariables.new_players = number changes the number new_players in library to the new\n                    decreased number.\n\n                        Inner loop triggered if number not equal to 0 triggering toplevel to rebuild with the new\n                        arbitrary counter label increasing.\n\n                        When the condition runs that the number is == 0, the integer in new_players list has reached\n                        zero. This will destroy the toplevel PlayerInfo permanently and trigger the next sequence of\n                        events.\n\n                        engine.set_random_player(), method\n                            method for selecting a player from the session_players to go first with the use of the\n                            random module - player = choice(library.StartVariables.session_players).\n                            This method then calls player_attrib_ipc_updater(player), a method specifically for binding the player\n                            attributes to library.\n                            Importantly library active_player is named: library.StartVariables.active_player = player\n                            used later in turn based assignment\n\n                            player_attrib_ipc_updater(player) method\n                                Binds all player attributes to library.PlayerAtribs. Note this method can take in any\n                                player instance and bind to library.PlayerAtribs.\n\n                        app.update_attrib_frame(), method\n                            part of view.py class Main method that acts as the controller. Sets all tk.Vars with\n                            library.PlayerAttribs. Act like a refresh for new bindings from player_attrib_ipc_updater that impacts upon\n                            MainLoop frame that calls controller.attrib. method also changes size of the Main window\n                            ready for gameplay.\n\n                        app.show_frame(MainLoop), method\n                            Raises MainLoop to the forefront\n\n#######################################################################\n# player rotation method, (initial start and game progression)\n#######################################################################\n\nSetting player rotation method and binding attributes. In previous section player_attrib_ipc_updater(player) and update_atrib_frame()\nset the player info to the random selected player. This is detailed in the player info to the left on the game screen and\ngoes first in the game. End turn button should trigger events that lead to the next player and the update of the\nplayer info window.\n\n    end_turn, button method\n    On button press player turn ends and another players turn begins.\n        engine.player_order(library.StartVariables.active_player) active_player bound in set_random_player method above becomes\n        current_player. while play is true (to be set as conditional for library.Options.win_lvl) creates loop for\n        players in game. With the use of itertools cycle is used to iterate over the session_players\n        player_gen = cycle(library.StartVariables.session_players). next is called to yield next player and loop back\n        to the beginning of the list.\n\n        within the while loop there is a branch. current_player is compared to next(player_gen) that is called y.\n        If the conditional in not met  current_player == y next is called again until current_player is found == y.\n        When this happens there are 2 outcomes either the player is alive or the player is dead.\n\n        In the event of alive library.active_player is updated to next(player_gen) thus next in line to play. player_attrib_ipc_updater\n        is called with the new player argument library.active_player. The loop is then broken preventing endless recursion.\n\n        Death and its conditionals will be addressed later.\n\n        app.update_attrib_frame(), method\n        method again updates the player info to the left of the screen\n\n\n#######################################################################\n# sell method\n#######################################################################\n\nSell method uses code re-usability to the max with shortened functions that allow various usage buy numerous callers.\nThe end goal is to remove items from the player adding them to the burn pile and gaining profit from the sale.\n\n    Mainloop the sell (sell_list) button-\n        From controller.Mainloop the sell button calls sell_list.\n        sell_list first calls scrub_lists. This important as all linked lists ar appended and not built anew.\n        calls player from active_player in library\n\n        Player has method called item_by_key. This takes 1 argument 'sell' defined as key on other end\n        (but could be anything specific from a game card)\n        item_by_key(self, key) generates a list from all cards in player.unsorted (a list of cards delt to the player during\n        controller.PlayerSelect.playersetter during player slice) that are specific in the fact they have in card dictionary\n        a key called 'sell'. Under list comprehension this generates a list of only sellable objects in the player deck.\n        this list is binded to library.GameObjects.selected items.\n\n        Returning to controller, OwnedItems(window_title) Toplevel is now called with the arg \"Sellable Items\".\n        OwnedItems loops over objects in selected_items creating a list format each with a name,type,value and a checkbox.\n        ** consider adding info buttion that either raise the pic of the card or text description.\n        library.GameObjects.check_but_intvar_gen.append(status) is also build per item and bound to checkbutton changing\n        independently with checkbutton activity.\n        The id of each card is appended to a new list in library.GameObjects.check_but_card_ids.\n        This order is the same order as Checkbutton object in the other list.\n        The button is use to call sell method\n\n    sell button -\n    engine.zipper() # passes string arg for card_matcher (method acts as conduit)\n        Calls engine.zipper method (generic method for zipping 2 list together into a tuple)\n        library.GameObjects.zipped_tup.clear() is called to ensure list is clear.\n        First step required is the conversion of the Checkbutton objects to the boolean value (0 or 1) from\n        library.GameObjects.check_but_intvar_gen, a list of all tk Vars, associated to the check button, requiring .get method.\n        This creates new list of booleans called library.GameObjects.check_but_boo consisting of the boolean values.\n        x, y = library.GameObjects.check_but_card_ids, library.GameObjects.check_but_boo\n        library.GameObjects.zipped_tup = list(zip(x, y)) function is to zip cards independent ids to their bool.\n        This creates tuple pairs of (id,0/1) for each card in library.GameObjects.selected items.\n        engine.card_matcher(action) is then called.\n\n    engine.card_matcher(action) CREATED FOR FLEXIBILITY OF INPUTS AND FORWARD PASS\n        creates loop for each card in library.GameObjects.selected_items that iterates over cards then\n        creates an inner loop or tup in library.GameObjects.zipped_tup for each card, NOTE:tup contains (card id, 0or1).\n        Conditional if tup[0] == card[\"id\"] and tup[1] filters the cards by matching ids (tup[0]) and only if the\n        tup[1] value is == 1 (True).\n        After qualification a branch is created calling the correct method associated to action parameter, in this case \"sell\"\n        the qualifying card is passed to sell_item(self, card).\n\n        sell_item(self, card)\n            player wallet is substituted with the card value and the card is popped form the\n            player unsorted list and cards.add_to_burn(x) is called.\n\n            cards.(self, discard) method -\n            x = self.unsorted.pop(self.unsorted.index(card)) # pops card from player unsorted deck\n            cards.add_to_burn(x) # popped item is used as arg\n                simple method that adds cards to the burn pile that have been remove from the game. note simple arg of the card\n                to be removed\n\n    OwnedItems.destroy(self)\n        destroys toplevel with sellable items listed\n\n    engine.scrub_lists()\n        Critical for appended lists.\n        calls scrub_list from engine resetting all appendable lists: selected_items, check_but_intvar_gen, check_but_boo,\n        check_but_card_ids and zipped_tup. This reset allows new creation when recalled or new player.\n\n    rebinding variables\n    engine.player_attrib_ipc_updater(library.StartVariables.active_player)\n    app.update_atrib_frame()\n        updates the player info screen detailing changes to player wallet\n\n\n##########################################################################\n# Equipping method\n##########################################################################\n\nAccessed by either weapons or armour buttons.\nMainLoop, class\n    Armor, Main screen button - calls list_armor method\n\n    list_armor, method:\n        library.GameObjects.message & app.update_message(\"show\") - Call simple message to the main window\n\n        engine.scrub_lists() - clears all lists ready for new item stack in the toplevel window.\n\n        player.inventory(\"type\", \"armor\") - searches player card list for cards that have a key of \"type\" and val of \"armor\".\n            Cards that meet this criteria are sent to library.selected_items. Note that this meth take two params as it is looking for a\n            specific key val pair. Note cards have \"type\":\"armor\" arrangement in the card dict.\n\n        OwnedItems(\"Armor Owned\", \"armor\") - TopLevel call with params for title other for button layout specific to armor.\n\n    OwnedItems(title, set_but) - Toplevel, Window is built with title and specific set of buttons for armor cards found in the player.\n        Buttons include: sell (method as above), Equip (This focus), a check box and info (displays card) for each item.\n\n        equip - button method, ran on those items that have been checked.\n            calls common_set That calls a common set of methods found with many buttons.\n                engine.zipper(\"equip\"), method -  See sell meth for action (brief - takes selected_items list and bools\n                from checkbox to make. Calls card_matcher)\n\n                card_matcher(action), method - See sell , (brief - id matches cards with the unsorted. The tuples return\n                    True to yield cards that can be used). The action parameter defines what happens to the card next).\n\n                    method - For any card to be equipped it must be checked to ensure that it is suited\n                        to the player in respects of race, class and gender. This is required as some cards have restrictions\n                        who can use them. (This is an updated meth that does away with the a fractured 3 method approach).\n                        Uses dict of key vals to loop over player and card. First card is checked for any restrictions,\n                        if none exist the loop is exited resulting in the card being passed to the next method.\n                        If the card contains a restriction it is compared to the player. In the event the player does not\n                        qualify, the cards remains in the unsorted list unequipped. A flag is used to control passage.\n                        ############## small bug name can be r and still qualify if no gender set ####################### ADDED DEFAULT GENDER\n                        If qualified, door_card_designator(player, card) is called passing the card and player along.\n\n\n\nPREBUILD CONSIDERATIONS PLAN\nconsider changing card to fit ie equip:True then loop over for equipped items. good to dete,rmine bonuses, use re for\nstatus effects/qualifiers. name of equipped item for player info = verbinding can call meth that returns it or none\n\nneed to set up vars in Main\naccess to them\nseparate player list for equipped/curse/status effects\nmethod to select equipperble items and populate selected_items\nway to screen items dependent on player ie for dwarfs only ect\n\nsteps needed:::\nway to screen cards race/gender... same for cursing??\n\nway to add to player or check if place is occupied already and remove player and add to sack\n\n\n##########################################################################\n# view method\n##########################################################################\ndone\n\n\n\n#######################################################################\n# remove items\n#######################################################################\ndone\naction =  engine,zipper(\"remove\")>\nrequires a search if player assets as no items will show in top level as they have been removed.\n\n\n\n#######################################################################\n# enhancers\n#######################################################################\nnot done\nmost likely card associated methods that are called at start of play to enrich/encumber player\n\n\n\n#######################################################################\n# door\n#######################################################################\nDoor button triggers the advancement through the game by placing cards on the table and actioning any static methods is may\nhave to influence play. 3 types of card can be door cards.\nThe three types include: monster, curse or other. In the case of a non-fighting card the player may have the option to\nloot the room (another kick of the door that send a card strait to the players hand, not shown on table) or look for trouble\n(fight a monster from their hand).\n\nOn the first kick of the door, and a monster or curse card is returned, a static method is ran on the card to implement\nany effects it may have on the player ready for the fight.\nCurses come in 3 flavours, one_shot, time dependent (lasts certain amount of time usually a turn) and permanent until a\ncondition is met. More on curses under curse section. In this section we are only interested in their action when kicking\n(1st turn) a door and how this effects the player.\n\nHitting the door button initiates a cascade of events that leads to:\n    - certain buttons being disabled\n    - static methods of cards activated\n    - card being delt to the table\n    - card being displayed\n    - broadcast system update\n\n\nDoor button > door method\n     self.end_turn_button.config(state=\"disabled\"), disables end_turn to prevent incorrect usage.\n\n     door_card = engine.deal_handler(\"door\", deal_amount=default)\n        Is one of the main method and excepts a return object. The card returned is dependent on the string parameter used.\n        In this case the parameter 'door' is used to retrieve a door card. This is the value to the key 'category' within the card's dict.\n        door_attempts as a parameter exerts control over where the card ends up and in the current class defines how the\n        card is viewed. The returned card is used for the picture on canvas and trigger the card method.\n\n        deal_handler(self, option, deal_amount=1):\n            # option = 'start', 'door', 'treasure', 'resurrect'\n            # deal_amount = default=1, set for treasure cards to deal back to player/s\n               This method is used to define what call is made to the dealer by the option parameter.\n               a 'door' param, now re-defined as option controls the type of card to get from the deck. As a default deal_amount will always be 1\n               returning only 1 door card from the dealer.\n\n                door_card = cards.card_sop.deal_cards(option, deal_amount) #  REQUIRES ALL PARAMS TO BE PASSED BY CALLER\n                    Runs the Table class that has-a dealer() method that returns a door cards. Note, dealer will check the pack first\n                    and if insufficient cards are present it will empty and sort the burn_pile to refresh the card decks. !MAY BE CHANGE TO A FIRST IN FIRST OUT ALGORITHM!\n                    A card is returned to the caller back to door_card variable.\n\n     engine.door_card_designator(door_card, door_attempts=library.CardDraw.door_attempts_remaining)\n        # door_card is the returned card above\n        # door_attempts determines how many times the door has been kicked  and the gui changes to be made.\n            Method first checks door_attempts as this will define where the card is placed. Consider a monster, 1st\n            kick would be placed on table while 2nd would be placed in hand.\n            Branch statements there after defines the fate of the card dependent upon the card type ('door', 'curse', other).\n            else block catches the cards that do not fall into the monster/curse scenarios placing in the player sack.\n            The final else block relates to the outer branch for door_attempts providing a generic catch that places\n            a card in the player hand. ##################################################### (TO BE UPDATED WITH A LOOT_ROOM OR LOOK FOR TROUBLE METHODS).\n            HANDS BACK TO GUI COMPONENT\n\n     Branch: library.CardDraw.door_attempts_remaining FIRST KICK\n        Processes the card to display it on the canvas.\n        Conditional check for mon/curs to update broadcast\n        If monster a cascade of events relating to button states will ensue main one being the deactivation of the door preventing\n        further use on the current players turn.\n\n     Branch: library.CardDraw.door_attempts_remaining == 0:\n        Will never be reached if kick button deactivated. Only works if first kick was NOT a monster.\n        Cascade events to not show the card on canvas and disable door for further use and enable end_turn state change.\n\n    library.CardDraw.door_attempts_remaining = 0\n        Always run but does not make difference when first kick is monster.\n        Importance is in the card that is not the monster allowing second kick to proceed.\n\n    Tools.fluid_player_info()\n           Updates any changes to the player made by the the door_card ready for the next scenario.\n\nRemember: After this method ends static card methods have been enabled, card is on the table or in hand, button sates have changed\n\n\n#######################################################################\n# fight\n#######################################################################\nfight button becomes available when a monster is on the table within the in_play list. any additions to this list will\nforce the player to battle monsters in a first in last out order until no monsters are left. This order is also apparent\nwith the run button discussed later.\n\n\n\n#######################################################################\n# run\n#######################################################################\nmethod looks up a players ability to run - as a bool 0 = false so no run and all other numbers = true.\nIf true this number represents the roll required to escape\n\n\n#######################################################################\n# card activation\n#######################################################################\nCard activation is a massive part of the game so a dynamic system is required. cards are required to be activated when:\n# first put on table be it monster or curse\n# used in interferance, wondering monster, enhancer\n# when equipped as enhancer\n# results of win/looses in fights\n# change must be specific to a player\n\nMethod must:\n    # take in any number of cards and methods and states\n    # activate card method\n    # change player state/ include remove items\n    # elicit change from and enchantment within a player\n    # in some cases return a cred for further processing\n\nGeneric method calls:\n    # player.card_meths(card, static='on') 3 important parts: 1) player is the active player during the game\n        2) Card/s must be the first argument/s 3) keywords must be used to define a method and a state.\n\nMethod:\n        card_meths(self, *args, **kwargs)\n            Loops over kwargs generating retrieving the keys and values (method : state).\n            The first arg should be the card in which u wish to activate with the method and state\n            Cards are packed in a tuple thus indexing is used to address the correct card.\n            Method should retrieve a list of methods as its value from the card and iterated over. This is so a card\n            can have more than one method associated to a key.\n            The method from the list is checked against the keys of method_types found in either the doorcards.py or\n            treasure.py scripts.\n            matches calls the first class object with params : method_call(self, state, args[1:])\n            This places the player in direct association to the methods associated to the cards and thus changing\n            player states. state will tell the method to switch on or off and args[1:] passes all but the first card to\n            the method if required. This is important for wondering monsters!\n\nTypical monster method:\n        def test_meth(self, *args):\n            print('In test meth expecting level change to 500')\n            if \"on\" in args:\n                print('lvl changed')\n                self.level = 500\n            else:\n                self.level = -500\n\n    # args in this cas uses args[0] as state control, all others will be cards.\n    # self.level gives direct access to the player state information.\n\nNotes: from within doorcards.py or treasure.py scripts cards can not be sent to the burn or put into play. Them must therefore\n    be return back to the caller in controller class for further processing. As a relic of the proces of iteration through the\n    listed_meths a none type can be returned. This is screened out by a return check. before returned cards are processed.\n    any object returned to the caller is in the form of a list object. The first arg of this is a string that is used to\n    determine the fate of the cards. This process is also used to deal with the initial fires card, args[0].\n\nLook_up kwargs calls:\n    static='on' # turns the static method on. 'off' will have the opposite effect..\n    method_bs='on' # Runs the bad stuff after a fight\n\n\n\n\n\n\n\n#######################################################################\n# curses\n#######################################################################\nConsider that there are 3 kind of curses, 1 that effects the player in a single instance like a one_shot. Theses cards\nwould have an effect and an action instantly, ie loose head_gear. Cards of this type would be returned to burn_pile after\naction complete or not.\n\nThe second type is the continued effect. Theses cards will effect a player attribute until removed ie -1 to run away.\nWhen called the method is triggered (if valid for the player) and its effect implemented. Removal of the cures must trigger\nthe curse card's remove method to ensure attributes are returned to normal. Theses cards will be stored under\nplayer.active_curses and NOT returned back to burn pile until a condition to do so is met. This ensures a record of the curse\nis kept and access to the removal method is possible.\n\nThe 3rd type would be a single turn activity that last a single cycle of play.\n\nCruse cards can be iterated over to find the one the player wants to remove when in the active_cures list of a player.\n\nconsider curses that have effect and those that dont.\n    dont > back to burn pile\n    do > determine location of activity ( armor, weapon?) needs link to card that is effected (id) and storage\n    somewhere in player model. card active in correct situation then deactivation meth required\n\ndoor_card_designator(self, card, call=1): look under curses to add meth\n\nWHERE I AM NOW...\nmeth needed to determine if player susceptible to curse. IDEA= all cards that promote and effect can have key word/s that are added to player lexacl or dict with meths.\ncures would check against this list for resistant method\nie: lexical would be filled with class bonus words and other bonuses like tinhat. These would be looked up by curse and if non compatible would reject cures.\n\n\n#######################################################################\n# enhancers method\n#######################################################################\nenchantment to stay on lost weapons!\n\n# may be not a requirement. method can be run by card when used to attach to item and run a remove meth when chosen\n(ie with on or off param for adding/removing)\n\n\n\n\n#######################################################################\n# interfere method\n#######################################################################\n\n\n\n#######################################################################\n# help\n#######################################################################\n\n\n\n#######################################################################\n# pay to go up level\n#######################################################################\n\n****************************************************************************************************\n**************************************** planned changes *************************************\n****************************************************************************************************\n\nConsider ownership of action handling ie who is responsible for what in the programme ie what is responsible\nfor sorting cards or game flow?\n\ncontroller.py\n* Splitting up this module into more defined classes will be needed.\n\n\n\n########## NOTES FOR CHANGE ###\nchange table system to display monsters as list of list with dicts eg:  [ [{monster card},{monster enhancers}],[{monster},{wandering monster] ]\n\nThis gives each monster on the table the player has to fight a way to enhance, run monster specific methods and provide a way to run from specific monsters.\nBasically this provides and environment so that each monster can become independent.\n\nThe thought with this is the idea that if a single monster is placed on the table the fight can continue normally.\nHowever, when more than one is present and in the case where players want to intervene, a selection toplevel window would be required.\nThe top level would require a tick box, to select monster/player to use a card against, names of the objects, and  a button to handel the events.\nWeather zipper can be used for this is unknown...\n\nTop level would be used when: selecting a monster to fight, adding an item to the proceeding fight, (note when fight button pushed all interference ceases),\nseleting which one to run from, to use a crd against, and all things that require clarity in a target.\n\nQ:: how to run a monster conditions method (method that is ran when facing a specific monster on the table?\n    * need auto method on single monster, check required in many cases.\n        # check required on run, fight, use\n    * to switch off is another monster is added to the table. or to switch on when:\n        * assured only one monster on the field of battle, or, suitable selection is made to define which monster is to be challenged.\n    * switch on when another monster is chosen.\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/docs/algorthum_mapper b/Munchkin/docs/algorthum_mapper
--- a/Munchkin/docs/algorthum_mapper	(revision 824e26d9dd3021129d41aaa602f27bdc62551c47)
+++ b/Munchkin/docs/algorthum_mapper	(date 1651148205408)
@@ -853,7 +853,7 @@
 
 
 ########## NOTES FOR CHANGE ###
-change table system to display monsters as list of list with dicts eg:  [ [{monster card},{monster enhancers}],[{monster},{wandering monster] ]
+change table system to display monsters as list of list with dicts eg:  [ [{monster card},{monster enhancers}],[{monster},{wandering monster] ] DONE
 
 This gives each monster on the table the player has to fight a way to enhance, run monster specific methods and provide a way to run from specific monsters.
 Basically this provides and environment so that each monster can become independent.
@@ -864,7 +864,7 @@
 Weather zipper can be used for this is unknown...
 
 Top level would be used when: selecting a monster to fight, adding an item to the proceeding fight, (note when fight button pushed all interference ceases),
-seleting which one to run from, to use a crd against, and all things that require clarity in a target.
+seleting which one to run from, to use a crd against, and all things that require clarity in a target. Also used to selct player to interfere and where to use hteir item. MOST OF IT DONE
 
 Q:: how to run a monster conditions method (method that is ran when facing a specific monster on the table?
     * need auto method on single monster, check required in many cases.
@@ -874,4 +874,10 @@
     * switch on when another monster is chosen.
 
 
+ change bonus system to be on card methods which add or remove from player directly, loose calc method for it!.
+ Monsters run 3 methods types: static, method, method_bs. static can
+ search through player enhancers (placed on there by armour methods ect) to see if special event ie fire armour 2+
+ bonus.
+
+
 
Index: Munchkin/bin/engine/controller.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nController provudes backend logic to the view script and makes changes to variable library\nInitiates player personalisation and runs game cycle for each player fetching cards and initiation\neach scene of play\n\nContents functions:\n    rand * picks single player from list of players\n    varbinding * binds all player attribs to IPC script\n    dealhandler *\n\n\n\n\"\"\"\n\n\nfrom Munchkin.bin.players.playermodel import Player\nfrom Munchkin.bin.all_cards.table import dice\nfrom random import randint, choice\nimport bin.GUI.variables_library as library\nfrom itertools import cycle\nfrom bin.GUI.variables_library import cards\nprint('controller', id(library.cards))\nfrom time import sleep\n\n\n\n\n##################################################################\n# main loop\n##################################################################\n\"\"\" V4.0  \"\"\"\n\n\nclass PlayerSetUp:\n    \"\"\"class to determine number of players and hand to player order\"\"\"\n    card_from_engine = cards\n\n    def __init__(self):\n        self.cycle = 0 #needed?\n\n# meths associated to play setup\n\n    def active_player_creation(self):\n        \"\"\" calls Player.factory creating player instances\"\"\"\n        for person in range(library.StartVariables.new_players):\n            player = Player.factory()\n            library.GameObjects.session_players.append(player)\n        self.deal_handler(\"start\")\n\n    def player_name_gender(self, playerindex): # gui attrib, passes session_players index identifying specific instance\n        \"\"\"Gets player with list index and Sets name and gender to that player instance.\"\"\"\n        player = library.GameObjects.session_players[playerindex] #references a player objects from session_players\n        player.char_setup() # call to set name and gender of player instance.\n\n    def set_random_player(self):\n        \"\"\"Selects random player to start from session_players list. Binds player as active_player and calls\n        method to load all attributes of the player (player_attrib_ipc_updater(). parameter is optional but explicit)\"\"\"\n        player = choice(library.GameObjects.session_players) # selects random player from list of players\n        library.GameObjects.active_player = player # assigns the selected player to active player in gamevar for gui to see\n        library.GameObjects.message = f\"The dice has been rolled. Random player selected is {player.name.title()}\"\n        self.player_attrib_ipc_updater(player) # arg not needed. Calls method to set all attribs in in gamevar of player\n\n# class Game_Play:\n\n    def player_order(self, current_player): # called with gameVar rand_index\n        \"\"\"Triggered at end of turn. Note 1st player was random and assigned to active_player after player creation.\n        Current_player = active player\"\"\"\n        play = True # win condition need method that will check all players\n        player_gen = cycle(library.GameObjects.session_players) # generator function that cycles a list indefinitely\n        y = next(player_gen) # yields players from the list, at start this would be first item = p1.\n        while play:\n            if current_player == y and current_player.alive: # conditions to see if x==y (x= player, y=list item)\n                print(f\"Current player {current_player.name} turn ended\\n\")\n                library.GameObjects.active_player = next(player_gen) # binds next player to rand_player, (changes x)\n                self.player_attrib_ipc_updater(library.GameObjects.active_player) #  binds new player\n                print(f\"{library.GameObjects.active_player.name} has been binded\")\n                break\n            elif current_player == y and not current_player.alive and not library.Options.perm_death:\n                print(f\"print player {current_player} is dead\") # move in to conditional for perm-a-death\n                current_player.alive = True # resets player status ##########need per-a-death bit here\n                library.GameObjects.active_player = next(player_gen) # changes x without binding and moves to next player\n                continue\n            else:\n                print(f\"{y.name.title()} did not match. Searching for player in list\")\n                y = next(player_gen) # changes y to find commonality to x\n\n        library.GameObjects.message = f\"{library.GameObjects.active_player.name.title()}'s turn...\"\n\n    def player_attrib_ipc_updater(self, playerinst=library.GameObjects.active_player): # defaults to gamevar active_player player\n        \"\"\"Binds all player atribs to gameVar for current player activity. Can take param of a player or grab active_player.\"\"\"\n        library.PlayerAttribs.player_name = playerinst.name.title()\n        library.PlayerAttribs.player_gender = playerinst.gender.title()\n        library.PlayerAttribs.player_level = playerinst.level\n        library.PlayerAttribs.player_bonus = playerinst.bonus\n        library.PlayerAttribs.player_wallet = playerinst.wallet\n        library.PlayerAttribs.player_race = playerinst.race.title()\n        library.PlayerAttribs.player_race2 = playerinst.race2.title()\n        library.PlayerAttribs.player_klass = playerinst.klass.title()\n        library.PlayerAttribs.player_klass2 = playerinst.klass2.title()\n        library.PlayerAttribs.player_sack = playerinst.sack\n        library.PlayerAttribs.player_l_hand = playerinst.update_bindings(\"L_hand\")\n        library.PlayerAttribs.player_r_hand = playerinst.update_bindings(\"R_hand\")\n        library.PlayerAttribs.player_two_hand = playerinst.update_bindings(\"two_hand\")\n        library.PlayerAttribs.player_headgear = playerinst.update_bindings(\"headgear\")\n        library.PlayerAttribs.player_armor = playerinst.update_bindings(\"armor\")\n        library.PlayerAttribs.player_knees = playerinst.update_bindings(\"knees\")\n        library.PlayerAttribs.player_footgear = playerinst.update_bindings(\"footgear\")\n        library.PlayerAttribs.player_necklace = playerinst.update_bindings(\"necklace\")\n\n# card handling class:\n\n    def deal_handler(self, option, deal_amount=1):\n        \"\"\" Sends requests to the dealer based on the option parameter to define card type.\n        Deal_amount defines how many of the cards are to be returned to a player.\n        \"\"\"\n\n        playerinst = library.GameObjects.active_player # gets current player. Not set at start default=None.\n\n        if option == \"start\": # initial play selector to deal cards to each player. NO GOOD FOR RESURRECT OPTION as deals to all players\n            for player in library.GameObjects.session_players: # loops over each player in session_players\n                player.sack = cards.card_sop.deal_cards(option, deal_amount=library.Options.cards_dealt) # deals cards with params \"start\" & num of cards to deal)\n\n        elif option == \"door\": # Standard gameplay loop on door kick\n            print(\"In deal_handler, retrieving door card & determining fate of card\")  # test location\n            door_card = cards.card_sop.deal_cards(option, deal_amount) # fetches 1 door card defined by the default,\n            return door_card # for pic use only in gui\n\n        elif option == \"treasure\": # Deal treasure, requires number for amount to deal.\n            print(\"retrieving treasure card/s\") # test location\n            add_treasure = cards.card_sop.deal_cards(option, deal_amount=deal_amount) # cardnum is usually determined by the treasures a monster holds.\n            playerinst.sack = playerinst.sack + add_treasure # DUMPS ALL IN THE ACTIVE_PLAYER.....TODO::Sort how treasure is handled when used as currency for another players help\n\n        elif option == \"resurrect\":\n            if library.Options.perm_death:\n                playerinst.sack = cards.card_sop.deal_cards(\"start\", deal_amount=library.Options.cards_dealt)\n            else:\n                print(f\"Game over for {playerinst.name}, BUMMER!\")\n\n        else:\n            print(\"option parameter not defined/matched in deal_handler\")\n\n    def door_card_designator(self, card, door_attempts=1): # for all door cards that are drawn from the pack or placed by another player.\n        \"\"\"Takes in door card and door_attempts as params to decide card fate.\n        Cards have different fates dependent upon the type of card it is ie: monster, curse, other and the number of\n        times the door button is clicked. Also update the message dependent on action\n        \"\"\"\n        player = library.GameObjects.active_player\n\n        if door_attempts: # On first kick of the door. Decides what to do with the cards dependent on situation\n\n            # if monster, put on table ready to fight\n            if card.get(\"type\") == \"monster\": # if the cards a monster #1st/2nd kicks covered\n                library.GameObjects.message = f\"{card.get('name')} placed on table, Level {card.get('lvl')}\" # updates broadcast message\n                cards.in_play[0].append(card) # places card on table in the lol for the first fight.\n                player.card_meths(card, static='on') # activates any static meths for the card. TESTED WITH 2 CARDS. OK!\n\n            # WORK REQUIRED!!     if curse, activate effects. need check to see if conditions in place to stop cursing ie ork/ wishing ring.\n            elif card.get(\"type\") == \"curse\": # if the cards a monster #1st/2nd kicks covered\n                library.GameObjects.message = f\"The room you have entered has a curse {card.get('name').title()}.\\n Lets hope you have protection!\"\n                print(\"In curse::\", player.active_curses)\n\n                player.card_meths(card, method_bs='on') # turns on curse bs## TEST\n\n                # ~~~~~~~~~~~~~TODO  curse checker method required ie tin hat, ork ect\n                if card.get(\"duration\") == \"persistent\": # for constant effect curse\n                    player.card_meths(card, \"method\", \"on\") # switches card on.\n                    player.active_curses.append(card) # adds card to player curse list so method can be called o remove\n                elif card.get(\"duration\") == \"one_shot\": ########### matches card key to the one_shot action\n                    player.card_meths(card, \"method\", \"on\")  ########## calls card method and switches it on TO BE REMOVED\n                    cards.burn_pile.append(card) # disposes of to burn pile\n                    print(f\"card duration is one_shot, added to burn pile check:\\nBurn pile {cards.burn_pile}\")\n                elif card.get(\"duration\") == \"timed\": ########## for time dependent effect\n                    library.GameObjects.message = f\"timed curse card not configured yet\" # overrides top message\n                    #TODO meth for timed\n                    cards.burn_pile.append(card) # disposes of to burn pile\n                    print(f\"card status is passive, should be added to burn pile!\\nBurn pile {cards.burn_pile}\"),\n\n            else: # for all other cards that have no direct effect or influence.\n                print(f\"Adding {card['name']}to sack.\")\n                player.sack.append(card)  # adds card to player's items\n                library.GameObjects.message = f\"Adding 2nd draw to sack.\" # need to be removed dont want to broadcast what other player gets\n                return card  # to show if first time only 2nd it hides\n\n        else:\n            \"2nd kick of door (looting room). Will need condition statement if player wants to fight mon from hand, rather than std flow to sack\"\n            print(\"adding to sack\")\n            library.GameObjects.message = \"2nd kck, Adding card to sack\"  # 2nd kick\n            player.sack.append(card)  # adds to player sack\n\n    def zipper(self, action):\n        \"\"\"zips card id's to checkbox bools from selected_list. Used for all card sorting regardless of card type.\n        action is conduit for card_matcher\"\"\"\n        library.GameObjects.zipped_tup.clear()  # clears tup list ready for new entry. not working...................\n        for status in library.GameObjects.check_but_intvar_gen: # gets attribute from object then from the attribute which is an object gets the value stored (list>intvar>get()>1 or 0)\n            library.GameObjects.check_but_boo.append(status.get()) # creates a list of 1s & 0s from check buttons status\n            x, y = library.GameObjects.check_but_card_ids, library.GameObjects.check_but_boo\n            library.GameObjects.zipped_tup = list(zip(x, y)) # result [(card_id,  bool), (card_id, bool)]\n        # print(\"moving to player script\", gameVar.GameObjects.zipped_tup) # checker shows all cleared lists\n        self.card_matcher(action)\n\n    def card_matcher(self, action):\n        \"\"\"compares tuple to selected_items searching for matching card ids and only passes on cards that contain\n        a tuple with the boolean true. Action determines the whats happening to the cards next. \"\"\"\n        for card in library.GameObjects.selected_items: # for every card in selected_items\n            for tup in library.GameObjects.zipped_tup: # go over every tuple in  zipped_tup. (card_id, bool tuples).\n                if tup[0] == card[\"id\"] and tup[1]: # if tup id matches card fid from selected items and bool is True from the checkbox\n                    if action == \"sell\":\n                        library.GameObjects.active_player.sell_item(card)\n                    elif action in \"equip, disposable ,use\": # equip/disposable will be treasures\n                        self.tri_qualifier(card) # test ~~ok~~\n                    elif action == \"remove\":\n                        player = library.GameObjects.active_player\n                        player.equipped_items(\"removal\", card)\n\n    def tri_qualifier(self, card):\n        \"\"\" Checks player attribs against an item card before it can be used by the player. Split into 2 parts:\n        1st: checks card for a specific restriction that would count against a player due to a specific attrib, ie if u are human u cant use this card.\n        2nd part: \"\"\"\n\n        player = library.GameObjects.active_player\n\n        checks = {player.race: \"race_requirement\", player.race2: \"race_requirement\", player.klass: \"klass_requirement\",\n                  player.klass2: \"klass_requirement\",\n                  player.gender: \"gender_requirement\"}  # card specific requirements to use\n        flag = 1  # True\n\n        for player_attribs, card_requirement in checks.items():\n            # checks card restrict method lexical for non use cases. If found player cant use.\n            if card.get('restriction',\n                        False):  # checks card to see if there is a key named 'restriction'. if not return False\n                print(\"Searching card restriction method\")\n                if player_attribs in card.get(\n                        'restriction'):  # checks all player attribs to see if in restricted treasure card list # Returns True if match\n                    print('Restriction found')\n                    if player.name == \"The_Creator\":  # dev mode\n                        print(f\"{player_attribs} - Restriction avoided: Dev path\")\n                        break\n                    else:  # sets flag so card cant be used\n                        print('Restricted, card cant be used.')\n                        flag = 0\n                        break\n            # checks cards for player dependent attribs to use card\n            if card.get(card_requirement):  # checks card to see if requirement present\n                if card.get(\n                        card_requirement) == player_attribs:  # if race_requirement = 'human' == player.race = 'human' change flag and break out of loop\n                    print(f\"Main path for: {card_requirement}\")\n                    continue  # checks next requirement parameter for conformance\n                elif player.name == \"The_Creator\":  # dev mode\n                    print(f\"{player_attribs} - Dev path\")\n                    continue\n                else:\n                    library.GameObjects.message = f\"You cant use this card, {card_requirement}\"\n                    flag = 0\n                    # gameVar.StartVariables.message = f\"{card.get('name')} can not be quipped: {val}.\" # not working\n                    break\n\n        if flag:  # only if flag remains True, compliant to non restrictions.\n\n            if card[\"category\"] == \"treasure\":  # for all treasure cards the player uses that was from their hand\n                self.player_treasure_cards(card)  # for the use of treasure cards\n            elif card[\n                \"category\"] == \"door\":  # for all enhancers ect that the player has from their hand  DO DOOR CARDS REALLY COME DOWN THIS ROUTE! however thowables???\n                self.player_door_cards(card)  # for the use of door cards\n\n    def player_treasure_cards(self, card):\n        \"\"\"method to sort the locations of treasure cards that the player has selected\"\"\"\n        player = library.GameObjects.active_player\n        if card.get(\"type\") == \"armor\":\n            player.equip_armor(card)  # leads to player meth for placing in right place\n        elif card.get(\"type\") == \"weapon\":\n            player.equip_weapon(card)\n        elif card.get(\"type\") == \"disposable\":  # for disposable throwable only\n            player.card_meths(card, methood='on')\n        else:\n            pass # for all other cards ie steeds\n\n    def player_door_cards(self, card): #card meth#####################################################\n        player = library.GameObjects.active_player\n        player.card_meths(card, method=\"on\")  # link to player to card meths.\n        print('unlocking:', player.klass_unlock, player.race_unlock)  # only shows at end of turn due to meth restriction in class,\n        # meths added at end_turn\n\n    def scrub_lists(self):\n        \"\"\"Clears all appended list that are not capable of clearing.\"\"\"\n        library.GameObjects.selected_items.clear()  # clears the card objects list\n        library.GameObjects.check_but_intvar_gen.clear()  # clears list of intVar objects from check buttons\n        library.GameObjects.check_but_boo.clear()  # clears boolean list\n        library.GameObjects.check_but_card_ids.clear()  # clears card id list\n        library.GameObjects.zipped_tup.clear()  # clears tup list\n\n##################################################################\n    def fight(self, helper=0, additional=0):# helper would be other player interactions. additional is anything else\n        \"\"\"for cards that are monsters and placed on the table\"\"\"\n\n        print(\"In the fight!\")\n        card = cards.in_play.pop() # end of cards on table\n        player = library.GameObjects.active_player\n        player.card_meths(card, 'static', 'on') # turns on card static content for fight TODO change to something more relevant than \"static\"\n        if player.bonus + player.level + helper + library.Fight_enhancers.player_aid \\\n                >= card[\"lvl\"] + library.Fight_enhancers.monster_aid: # consideration required for player consumables and enhancers\n            print(\"Player wins!\")\n            reward = card['treasure']\n            self.deal_handler('treasure', deal_amount=reward) # fetches treasure for player\n            library.GameObjects.message = f\"You win! You have found {reward} treasures for your trouble.\"\n            player.level += card[\"level_up\"]\n            cards.burn_pile.append(card) # removes card\n            player.card_meths(card, 'static', 'off') # turns off static card content\n            print(f\"cards in the burn pile: {len(cards.burn_pile)}\")\n            return \"win\"\n        # need action to go up lvl note some cards do more than one level!\n        else:\n            library.GameObjects.message = \"Fight lost\"\n            print(\"Fight lost\")\n            player.card_meths(card, 'method', 'on') # calls card bad stuff\n            player.card_meths(card, 'static', 'off') # turns off static effect of card in play\n            return \"lose\"\n\n\n    def radio_selector_handler(self, index, obj_list):\n        \"\"\"takes in index and a list of monster/mon/players where the index has relevance\"\"\"\n        library.Fight_enhancers.card_selector_index = index # stores the index in the library\n        library.Fight_enhancers.card_list_selection = obj_list # list of all selected\n\n\n\n\n    def card_method_activator(self, scenario, action, table_card_index): # will need to be a selector\n        \"\"\"method to activate a card dependent upon the scenario of having a specific monster/ curse/ item in play and action to\n        switch on or off the condition\"\"\"\n        card = cards.in_play[int(table_card_index)][0] # selects the monster in the fight on the table\n        player = library.GameObjects.active_player\n        if scenario == \"persistent\":\n            player.card_meths(card, 'static', action)  ######## will cause probs with monster individuality ######################\n\n    def run(self):\n        roll = dice.dice_sop.roll()\n        player = library.GameObjects.active_player\n        print(f\"You rolled a {roll}.\")\n        if roll >= player.run:\n            print(f\"You rolled a {roll}. You out ran your pursuer.\")\n            remove = cards.in_play.pop(0)\n            player.card_meths(remove, 'static', 'off')# turns off static card content\n            cards.burn_pile.append(remove)\n            return \"success\"\n        else:\n            print(\"Tried to run and slipped. Things are gona get ugly!\\n\")\n            # only fight is available now so that cna handle all the logic\n            return \"fail\"\n\n\nengine = PlayerSetUp()\n\nif __name__ == \"__main__\":\n\n    # NumberOfPlayers().select_players() # starts game by activating NOP building the objects, and activating select_players\n    # running wach line.\n    engine.player_name_gender()\n\n\n\n\n\n\n# old\n# def door_card_designator(self, card, door_attempts=1):  # for all door cards that are drawn from the pack\n#     \"\"\"method that sort the cards that the player draws from the deck during play. This could be monster, curse ect.\n#     door0-attempts is used to determine how many times the door has been kicked in a turn and in 2nd instance the door is put into the\n#     players hand unseen. Mechanism is also used to trigger a curse\n#     \"\"\"\n#     player = gameVar.GameObjects.active_player\n#\n#     if door_attempts:\n#         if card.get(\"type\") == \"monster\":  # if the cards a monster #1st/2nd kicks covered\n#             if door_attempts:  # determines if first kick of door (T or F), if 1 = first kick\n#                 gameVar.GameObjects.message = f\"{card.get('name')} placed on table, Level {card.get('lvl')}\"\n#                 cards.in_play.append(\n#                     card)  # adds to table # careful as cards selected from hand will go strait to table\n#                 print(\n#                     f\"In door_card_designator, monster added to table. Returned card is: {[x['name'] for x in cards.in_play]}\\n\")\n#             else:\n#                 print(\"adding to sack\")\n#                 gameVar.GameObjects.message = \"Adding card to sack\"  # 2nd kick\n#                 player.sack.append(card)  # adds to player sack\n#\n#         elif card.get(\"type\") == \"curse\":  # if the cards a monster #1st/2nd kicks covered\n#             if door_attempts:  # 1st kick\n#                 print(\"In curse::\", player.curses)\n#                 gameVar.GameObjects.message = \"You have been cursed!\"  # look at card meth and action\n#                 player.card_meths(card, \"method\", \"on\")  # actions curs card as soon as picked up\n#                 if card.get(\"status\") == \"active\":  # for constant effect curse\n#                     player.curses.append(card)  # adds card to player curse list\n#                 elif card.get(\"status\") == \"passive\":  # for one shot effect\n#                     cards.burn_pile.append(card)  # disposes of to burn pile\n#                     print(f\"card status is passive, should be added to burn pile!\\nBurn pile {cards.burn_pile}\")\n#             else:\n#                 gameVar.GameObjects.message = \"Adding card to sack\"\n#                 player.sack.append(card)\n#\n#         else:  # for all other cards that have no direct effect or influence.\n#             print(f\"Adding {card['name']}to sack.\")\n#             if door_attempts:\n#                 player.sack.append(card)  # adds card to player's items\n#                 gameVar.GameObjects.message = f\"Adding/using {card.get('name')}.\"\n#                 return card  # to show if first time only 2nd it hides\n#             else:\n#                 gameVar.GameObjects.message = \"Adding 2nd card to sack\"\n#                 player.sack.append(card)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/engine/controller.py b/Munchkin/bin/engine/controller.py
--- a/Munchkin/bin/engine/controller.py	(revision 824e26d9dd3021129d41aaa602f27bdc62551c47)
+++ b/Munchkin/bin/engine/controller.py	(date 1651148205428)
@@ -293,37 +293,35 @@
         """for cards that are monsters and placed on the table"""
 
         print("In the fight!")
-        card = cards.in_play.pop() # end of cards on table
-        player = library.GameObjects.active_player
-        player.card_meths(card, 'static', 'on') # turns on card static content for fight TODO change to something more relevant than "static"
-        if player.bonus + player.level + helper + library.Fight_enhancers.player_aid \
-                >= card["lvl"] + library.Fight_enhancers.monster_aid: # consideration required for player consumables and enhancers
-            print("Player wins!")
-            reward = card['treasure']
-            self.deal_handler('treasure', deal_amount=reward) # fetches treasure for player
-            library.GameObjects.message = f"You win! You have found {reward} treasures for your trouble."
-            player.level += card["level_up"]
-            cards.burn_pile.append(card) # removes card
-            player.card_meths(card, 'static', 'off') # turns off static card content
-            print(f"cards in the burn pile: {len(cards.burn_pile)}")
-            return "win"
-        # need action to go up lvl note some cards do more than one level!
-        else:
-            library.GameObjects.message = "Fight lost"
-            print("Fight lost")
-            player.card_meths(card, 'method', 'on') # calls card bad stuff
-            player.card_meths(card, 'static', 'off') # turns off static effect of card in play
-            return "lose"
+        card_set = cards.in_play.pop(library.Fight_enhancers.card_selector_index) #
+        for card in card_set:
+            player = library.GameObjects.active_player
+            player.card_meths(card, 'static', 'on') # turns on card static content for fight TODO change to something more relevant than "static"
+
+            if player.bonus + player.level + helper + library.Fight_enhancers.player_aid \
+                    >= card["lvl"] + library.Fight_enhancers.monster_aid: # consideration required for player consumables and enhancers
+                print("Player wins!")
+                reward = card['treasure']
+                self.deal_handler('treasure', deal_amount=reward) # fetches treasure for player
+                library.GameObjects.message = f"You win! You have found {reward} treasures for your trouble."
+                player.level += card["level_up"]
+                cards.burn_pile.append(card) # removes card
+                player.card_meths(card, 'static', 'off') # turns off static card content
+                print(f"cards in the burn pile: {len(cards.burn_pile)}")
+                return "win"
+            # need action to go up lvl note some cards do more than one level!
+            else:
+                library.GameObjects.message = "Fight lost"
+                print("Fight lost")
+                player.card_meths(card, 'method', 'on') # calls card bad stuff
+                player.card_meths(card, 'static', 'off') # turns off static effect of card in play
+                return "lose"
 
-
     def radio_selector_handler(self, index, obj_list):
         """takes in index and a list of monster/mon/players where the index has relevance"""
         library.Fight_enhancers.card_selector_index = index # stores the index in the library
         library.Fight_enhancers.card_list_selection = obj_list # list of all selected
 
-
-
-
     def card_method_activator(self, scenario, action, table_card_index): # will need to be a selector
         """method to activate a card dependent upon the scenario of having a specific monster/ curse/ item in play and action to
         switch on or off the condition"""
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"e89d33e8-f65b-4c0f-9d3f-1de9856c0ba0\" name=\"Changes\" comment=\"rework of changes\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/Munchkin/bin/GUI/view.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Munchkin/bin/GUI/view.py\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards/doorcards.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards/doorcards.py\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/Munchkin/bin/all_cards/table.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Munchkin/bin/all_cards/table.py\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/Munchkin/bin/all_cards/treasure_cards/treasurecards.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Munchkin/bin/all_cards/treasure_cards/treasurecards.py\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/Munchkin/bin/engine/controller.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Munchkin/bin/engine/controller.py\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/Munchkin/bin/players/playermodel.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Munchkin/bin/players/playermodel.py\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Python Script\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"FlaskConsoleOptions\" custom-start-script=\"import sys&#10;sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])&#10;from flask.cli import ScriptInfo&#10;locals().update(ScriptInfo(create_app=None).load_app().make_shell_context())&#10;print(&quot;Python %s on %s\\nApp: %s [%s]\\nInstance: %s&quot; % (sys.version, sys.platform, app.import_name, app.env, app.instance_path))\">\n    <envs>\n      <env key=\"FLASK_APP\" value=\"app\" />\n    </envs>\n    <option name=\"myCustomStartScript\" value=\"import sys&#10;sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])&#10;from flask.cli import ScriptInfo&#10;locals().update(ScriptInfo(create_app=None).load_app().make_shell_context())&#10;print(&quot;Python %s on %s\\nApp: %s [%s]\\nInstance: %s&quot; % (sys.version, sys.platform, app.import_name, app.env, app.instance_path))\" />\n    <option name=\"myEnvs\">\n      <map>\n        <entry key=\"FLASK_APP\" value=\"app\" />\n      </map>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"master\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n    <option name=\"UPDATE_TYPE\" value=\"REBASE\" />\n  </component>\n  <component name=\"GitSEFilterConfiguration\">\n    <file-type-list>\n      <filtered-out-file-type name=\"LOCAL_BRANCH\" />\n      <filtered-out-file-type name=\"REMOTE_BRANCH\" />\n      <filtered-out-file-type name=\"TAG\" />\n      <filtered-out-file-type name=\"COMMIT_BY_MESSAGE\" />\n    </file-type-list>\n  </component>\n  <component name=\"ProjectId\" id=\"228V1szxqWwIqe83W3F9S3jTuGo\" />\n  <component name=\"ProjectLevelVcsManager\">\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\n  </component>\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">\n    <property name=\"ASKED_ADD_EXTERNAL_FILES\" value=\"true\" />\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$/../Learning_files\" />\n    <property name=\"settings.editor.selected.configurable\" value=\"preferences.pluginManager\" />\n  </component>\n  <component name=\"RunManager\" selected=\"Python.view\">\n    <configuration name=\"controller\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/bin/GUI/controller.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"doorcards\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards/doorcards.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"funct_trial\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/funct_trial.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"game_loop_v3\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/bin/engine\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/bin/engine/game_loop_v3.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"view\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/bin/GUI/view.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"Python.view\" />\n        <item itemvalue=\"Python.funct_trial\" />\n        <item itemvalue=\"Python.game_loop_v3\" />\n        <item itemvalue=\"Python.doorcards\" />\n        <item itemvalue=\"Python.controller\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"e89d33e8-f65b-4c0f-9d3f-1de9856c0ba0\" name=\"Changes\" comment=\"\" />\n      <created>1639218994311</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1639218994311</updated>\n      <workItem from=\"1639218997657\" duration=\"35269000\" />\n      <workItem from=\"1639735508330\" duration=\"18975000\" />\n      <workItem from=\"1640013914970\" duration=\"13331000\" />\n      <workItem from=\"1640513559951\" duration=\"433000\" />\n      <workItem from=\"1640952454199\" duration=\"648000\" />\n      <workItem from=\"1649103067776\" duration=\"360000\" />\n      <workItem from=\"1649237457571\" duration=\"2195000\" />\n      <workItem from=\"1649273824130\" duration=\"6676000\" />\n      <workItem from=\"1649938477233\" duration=\"1987000\" />\n      <workItem from=\"1650490391088\" duration=\"17364000\" />\n      <workItem from=\"1650789083067\" duration=\"3385000\" />\n      <workItem from=\"1650877919860\" duration=\"15410000\" />\n      <workItem from=\"1650963932645\" duration=\"17601000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"update to card date structure\">\n      <created>1639844962852</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1639844962852</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"changes image recall file structure to handle different os with pathlib module\">\n      <created>1649255260546</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1649255260546</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"changes image recall file structure to handle different os with pathlib module\">\n      <created>1649273835279</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1649273835279</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"docs\">\n      <created>1649280322103</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1649280322103</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"docs\">\n      <created>1649619777519</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1649619777519</updated>\n    </task>\n    <task id=\"LOCAL-00006\" summary=\"renaming scripts\">\n      <created>1650360756678</created>\n      <option name=\"number\" value=\"00006\" />\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1650360756678</updated>\n    </task>\n    <task id=\"LOCAL-00007\" summary=\"V4 starting for new player factory, fight mechanics, naming, dependencies ect\">\n      <created>1650380422544</created>\n      <option name=\"number\" value=\"00007\" />\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1650380422544</updated>\n    </task>\n    <task id=\"LOCAL-00008\" summary=\"card metho sorted, can add to accept more than one card arg\">\n      <created>1650564152449</created>\n      <option name=\"number\" value=\"00008\" />\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1650564152449</updated>\n    </task>\n    <task id=\"LOCAL-00009\" summary=\"card metho sorted, can add to accept more than one card arg\">\n      <created>1650823336289</created>\n      <option name=\"number\" value=\"00009\" />\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1650823336289</updated>\n    </task>\n    <task id=\"LOCAL-00010\" summary=\"completed card_meths\">\n      <created>1650895325367</created>\n      <option name=\"number\" value=\"00010\" />\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1650895325367</updated>\n    </task>\n    <task id=\"LOCAL-00011\" summary=\"rework of changes\">\n      <created>1650899019241</created>\n      <option name=\"number\" value=\"00011\" />\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1650899019241</updated>\n    </task>\n    <task id=\"LOCAL-00012\" summary=\"rework of changes\">\n      <created>1650906060357</created>\n      <option name=\"number\" value=\"00012\" />\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1650906060357</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"13\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <option name=\"ADD_EXTERNAL_FILES_SILENTLY\" value=\"true\" />\n    <MESSAGE value=\"update to card date structure\" />\n    <MESSAGE value=\"changes image recall file structure to handle different os with pathlib module\" />\n    <MESSAGE value=\"docs\" />\n    <MESSAGE value=\"renaming scripts\" />\n    <MESSAGE value=\"V4 starting for new player factory, fight mechanics, naming, dependencies ect\" />\n    <MESSAGE value=\"card metho sorted, can add to accept more than one card arg\" />\n    <MESSAGE value=\"completed card_meths\" />\n    <MESSAGE value=\"rework of changes\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"rework of changes\" />\n  </component>\n  <component name=\"XDebuggerManager\">\n    <breakpoint-manager>\n      <breakpoints>\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\n          <url>file://$PROJECT_DIR$/Munchkin/bin/GUI/view.py</url>\n          <line>523</line>\n          <option name=\"timeStamp\" value=\"20\" />\n        </line-breakpoint>\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\n          <url>file://$PROJECT_DIR$/Munchkin/bin/players/playermodel.py</url>\n          <line>178</line>\n          <option name=\"timeStamp\" value=\"23\" />\n        </line-breakpoint>\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\n          <url>file://$PROJECT_DIR$/Munchkin/bin/players/playermodel.py</url>\n          <line>205</line>\n          <option name=\"timeStamp\" value=\"24\" />\n        </line-breakpoint>\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\n          <url>file://$PROJECT_DIR$/Munchkin/bin/players/playermodel.py</url>\n          <line>235</line>\n          <option name=\"timeStamp\" value=\"25\" />\n        </line-breakpoint>\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\n          <url>file://$PROJECT_DIR$/Munchkin/bin/players/playermodel.py</url>\n          <line>146</line>\n          <option name=\"timeStamp\" value=\"26\" />\n        </line-breakpoint>\n      </breakpoints>\n    </breakpoint-manager>\n  </component>\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\n    <SUITE FILE_PATH=\"coverage/Munch$funct_trial.coverage\" NAME=\"funct_trial Coverage Results\" MODIFIED=\"1650905929196\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\n    <SUITE FILE_PATH=\"coverage/Munch$game_loop_v3.coverage\" NAME=\"game_loop_v3 Coverage Results\" MODIFIED=\"1650360495937\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/engine\" />\n    <SUITE FILE_PATH=\"coverage/Munch$controller.coverage\" NAME=\"controller Coverage Results\" MODIFIED=\"1649254694799\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\n    <SUITE FILE_PATH=\"coverage/MyPackages$doorcards.coverage\" NAME=\"doorcards Coverage Results\" MODIFIED=\"1639811290752\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards\" />\n    <SUITE FILE_PATH=\"coverage/Munch$general_tests.coverage\" NAME=\"general_tests Coverage Results\" MODIFIED=\"1649253557839\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/Tests\" />\n    <SUITE FILE_PATH=\"coverage/Munch$doorcards.coverage\" NAME=\"doorcards Coverage Results\" MODIFIED=\"1650694902157\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards\" />\n    <SUITE FILE_PATH=\"coverage/Munch$view.coverage\" NAME=\"view Coverage Results\" MODIFIED=\"1651006313865\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\n    <SUITE FILE_PATH=\"coverage/MyPackages$funct_trial.coverage\" NAME=\"funct_trial Coverage Results\" MODIFIED=\"1640266776710\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\n    <SUITE FILE_PATH=\"coverage/MyPackages$controller.coverage\" NAME=\"controller Coverage Results\" MODIFIED=\"1640513926303\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 824e26d9dd3021129d41aaa602f27bdc62551c47)
+++ b/.idea/workspace.xml	(date 1651148207000)
@@ -1,14 +1,11 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ChangeListManager">
-    <list default="true" id="e89d33e8-f65b-4c0f-9d3f-1de9856c0ba0" name="Changes" comment="rework of changes">
+    <list default="true" id="e89d33e8-f65b-4c0f-9d3f-1de9856c0ba0" name="Changes" comment="radio selector now excepts ars for different conditions: &#10;~ select mon for fight &#10;~ interfering with play">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/Munchkin/bin/GUI/view.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/GUI/view.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards/doorcards.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards/doorcards.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Munchkin/bin/all_cards/table.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/all_cards/table.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Munchkin/bin/all_cards/treasure_cards/treasurecards.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/all_cards/treasure_cards/treasurecards.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/Munchkin/bin/engine/controller.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/engine/controller.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Munchkin/bin/players/playermodel.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/players/playermodel.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Munchkin/docs/algorthum_mapper" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/docs/algorthum_mapper" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -40,7 +37,6 @@
       </map>
     </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
-    <option name="UPDATE_TYPE" value="REBASE" />
   </component>
   <component name="GitSEFilterConfiguration">
     <file-type-list>
@@ -293,7 +289,35 @@
       <option name="project" value="LOCAL" />
       <updated>1650906060357</updated>
     </task>
-    <option name="localTasksCounter" value="13" />
+    <task id="LOCAL-00013" summary="New gui component class MonsterSelector- &#10;&#10;Provides top lvl window with monster name and lvl. can view card selecting and radio and button select&#10;radio provides index used to select fight set. Works! no canvas card update yet but works in fight">
+      <created>1651007520924</created>
+      <option name="number" value="00013" />
+      <option name="presentableId" value="LOCAL-00013" />
+      <option name="project" value="LOCAL" />
+      <updated>1651007520924</updated>
+    </task>
+    <task id="LOCAL-00014" summary="New gui component class MonsterSelector- &#10;&#10;Provides top lvl window with monster name and lvl. can view card selecting and radio and button select&#10;radio provides index used to select fight set. Works! no canvas card update yet but works in fight">
+      <created>1651008778989</created>
+      <option name="number" value="00014" />
+      <option name="presentableId" value="LOCAL-00014" />
+      <option name="project" value="LOCAL" />
+      <updated>1651008778989</updated>
+    </task>
+    <task id="LOCAL-00015" summary="radio selector now excepts ars for different conditions: &#10;~ select mon for fight &#10;~ interfering with play">
+      <created>1651080830713</created>
+      <option name="number" value="00015" />
+      <option name="presentableId" value="LOCAL-00015" />
+      <option name="project" value="LOCAL" />
+      <updated>1651080830713</updated>
+    </task>
+    <task id="LOCAL-00016" summary="radio selector now excepts ars for different conditions: &#10;~ select mon for fight &#10;~ interfering with play">
+      <created>1651081000416</created>
+      <option name="number" value="00016" />
+      <option name="presentableId" value="LOCAL-00016" />
+      <option name="project" value="LOCAL" />
+      <updated>1651081000416</updated>
+    </task>
+    <option name="localTasksCounter" value="17" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -321,14 +345,16 @@
     <MESSAGE value="card metho sorted, can add to accept more than one card arg" />
     <MESSAGE value="completed card_meths" />
     <MESSAGE value="rework of changes" />
-    <option name="LAST_COMMIT_MESSAGE" value="rework of changes" />
+    <MESSAGE value="New gui component class MonsterSelector- &#10;&#10;Provides top lvl window with monster name and lvl. can view card selecting and radio and button select&#10;radio provides index used to select fight set. Works! no canvas card update yet but works in fight" />
+    <MESSAGE value="radio selector now excepts ars for different conditions: &#10;~ select mon for fight &#10;~ interfering with play" />
+    <option name="LAST_COMMIT_MESSAGE" value="radio selector now excepts ars for different conditions: &#10;~ select mon for fight &#10;~ interfering with play" />
   </component>
   <component name="XDebuggerManager">
     <breakpoint-manager>
       <breakpoints>
         <line-breakpoint enabled="true" suspend="THREAD" type="python-line">
           <url>file://$PROJECT_DIR$/Munchkin/bin/GUI/view.py</url>
-          <line>523</line>
+          <line>568</line>
           <option name="timeStamp" value="20" />
         </line-breakpoint>
         <line-breakpoint enabled="true" suspend="THREAD" type="python-line">
@@ -343,11 +369,6 @@
         </line-breakpoint>
         <line-breakpoint enabled="true" suspend="THREAD" type="python-line">
           <url>file://$PROJECT_DIR$/Munchkin/bin/players/playermodel.py</url>
-          <line>235</line>
-          <option name="timeStamp" value="25" />
-        </line-breakpoint>
-        <line-breakpoint enabled="true" suspend="THREAD" type="python-line">
-          <url>file://$PROJECT_DIR$/Munchkin/bin/players/playermodel.py</url>
           <line>146</line>
           <option name="timeStamp" value="26" />
         </line-breakpoint>
@@ -361,7 +382,7 @@
     <SUITE FILE_PATH="coverage/MyPackages$doorcards.coverage" NAME="doorcards Coverage Results" MODIFIED="1639811290752" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards" />
     <SUITE FILE_PATH="coverage/Munch$general_tests.coverage" NAME="general_tests Coverage Results" MODIFIED="1649253557839" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/Tests" />
     <SUITE FILE_PATH="coverage/Munch$doorcards.coverage" NAME="doorcards Coverage Results" MODIFIED="1650694902157" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards" />
-    <SUITE FILE_PATH="coverage/Munch$view.coverage" NAME="view Coverage Results" MODIFIED="1651006313865" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/bin/GUI" />
+    <SUITE FILE_PATH="coverage/Munch$view.coverage" NAME="view Coverage Results" MODIFIED="1651148205435" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/bin/GUI" />
     <SUITE FILE_PATH="coverage/MyPackages$funct_trial.coverage" NAME="funct_trial Coverage Results" MODIFIED="1640266776710" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/MyPackages$controller.coverage" NAME="controller Coverage Results" MODIFIED="1640513926303" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/bin/GUI" />
   </component>
