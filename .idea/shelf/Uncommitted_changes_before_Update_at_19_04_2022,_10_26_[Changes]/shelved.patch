Index: Munchkin/bin/GUI/gui_variables.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/GUI/gui_variables.py b/Munchkin/bin/GUI/variables_library.py
rename from Munchkin/bin/GUI/gui_variables.py
rename to Munchkin/bin/GUI/variables_library.py
--- a/Munchkin/bin/GUI/gui_variables.py	(revision df7008cb24f4d02549b37b4a5e8f0fb166521d60)
+++ b/Munchkin/bin/GUI/variables_library.py	(date 1650359023345)
@@ -1,6 +1,6 @@
 """
 ..IPC script..
-local area for all tkinter variables use in the game linking controller.py with engine(game_loop_v3.py).
+local area for all tkinter variables use in the game linking view.py with engine(controller.py).
 This script is updated by gui_v3 with game-loop_v2 requesting data for the logic.
 
 
Index: Munchkin/bin/GUI/controller.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/GUI/controller.py b/Munchkin/bin/GUI/view.py
rename from Munchkin/bin/GUI/controller.py
rename to Munchkin/bin/GUI/view.py
--- a/Munchkin/bin/GUI/controller.py	(revision df7008cb24f4d02549b37b4a5e8f0fb166521d60)
+++ b/Munchkin/bin/GUI/view.py	(date 1650360408183)
@@ -5,11 +5,11 @@
 """
 import tkinter as tk
 import tkinter.ttk as ttk
-from bin.engine.game_loop_v3 import engine  # imports the instance
+from bin.engine.controller import engine  # imports the instance
 # import bin.engine.game_loop_v3 as engine #for game loop clean up
 from bin.all_cards.table import cards
 import bin.engine.cut_scenes as cs
-import bin.GUI.gui_variables as gameVar
+import bin.GUI.variables_library as library
 from tkinter import messagebox
 from PIL import ImageTk, Image
 import os
@@ -79,31 +79,31 @@
     def update_atrib_frame(self):
         """Binds all the labels to the gamevar for player change with the set method"""
         self.geometry("800x600+320+20") # changes the geometry when called ## need to move
-        self.name.set(gameVar.PlayerAtribs.player_name)
-        self.gender.set(gameVar.PlayerAtribs.player_gender)
-        self.race.set(gameVar.PlayerAtribs.player_race)
-        self.race2.set(gameVar.PlayerAtribs.player_race2)
-        self.klass.set(gameVar.PlayerAtribs.player_klass)
-        self.klass2.set(gameVar.PlayerAtribs.player_klass2)
-        self.level.set(gameVar.PlayerAtribs.player_level)
-        self.bonus.set(gameVar.PlayerAtribs.player_bonus)
-        self.wallet.set(gameVar.PlayerAtribs.player_wallet)
+        self.name.set(library.PlayerAtribs.player_name)
+        self.gender.set(library.PlayerAtribs.player_gender)
+        self.race.set(library.PlayerAtribs.player_race)
+        self.race2.set(library.PlayerAtribs.player_race2)
+        self.klass.set(library.PlayerAtribs.player_klass)
+        self.klass2.set(library.PlayerAtribs.player_klass2)
+        self.level.set(library.PlayerAtribs.player_level)
+        self.bonus.set(library.PlayerAtribs.player_bonus)
+        self.wallet.set(library.PlayerAtribs.player_wallet)
 
-        self.l_hand.set(gameVar.PlayerAtribs.player_l_hand)
-        self.r_hand.set(gameVar.PlayerAtribs.player_r_hand)
-        self.two_hand.set(gameVar.PlayerAtribs.player_two_hand)
+        self.l_hand.set(library.PlayerAtribs.player_l_hand)
+        self.r_hand.set(library.PlayerAtribs.player_r_hand)
+        self.two_hand.set(library.PlayerAtribs.player_two_hand)
 
-        self.headgear.set(gameVar.PlayerAtribs.player_headgear)
-        self.armor.set(gameVar.PlayerAtribs.player_armor)
-        self.knees.set(gameVar.PlayerAtribs.player_knees)
-        self.footgear.set(gameVar.PlayerAtribs.player_footgear)
-        self.necklace.set(gameVar.PlayerAtribs.player_necklace)
+        self.headgear.set(library.PlayerAtribs.player_headgear)
+        self.armor.set(library.PlayerAtribs.player_armor)
+        self.knees.set(library.PlayerAtribs.player_knees)
+        self.footgear.set(library.PlayerAtribs.player_footgear)
+        self.necklace.set(library.PlayerAtribs.player_necklace)
 
     def update_message(self, action=None):
         if action == "show":
-            self.message.set(gameVar.GameObjects.message) # grabs message stored in gamevar messages
+            self.message.set(library.GameObjects.message) # grabs message stored in gamevar messages
         elif action == "dev":
-            self.message2.set(gameVar.GameObjects.message2)
+            self.message2.set(library.GameObjects.message2)
         else:
             self.message.set("")
             self.message2.set("")
@@ -189,12 +189,12 @@
 
     def setopts(self):
         """Sets gamevar options to the new values provided with the get() method used for tkvars. """
-        gameVar.Options.cards_dealt = self.initial_deal.get() # gets value stored in the bound tkvar associated to initial_deal
-        gameVar.Options.win_lvl = self.maxlvl.get()
-        gameVar.Options.perm_death = self.permadeath.get()
-        gameVar.Options.carry_weight = self.carry_weight.get()
-        message = f"Starting deal: {gameVar.Options.cards_dealt}\nWin level:{gameVar.Options.win_lvl}\n" \
-                  f"Carry weight: {gameVar.Options.carry_weight}\nPerm_a_death: {gameVar.Options.perm_death}"
+        library.Options.cards_dealt = self.initial_deal.get() # gets value stored in the bound tkvar associated to initial_deal
+        library.Options.win_lvl = self.maxlvl.get()
+        library.Options.perm_death = self.permadeath.get()
+        library.Options.carry_weight = self.carry_weight.get()
+        message = f"Starting deal: {library.Options.cards_dealt}\nWin level:{library.Options.win_lvl}\n" \
+                  f"Carry weight: {library.Options.carry_weight}\nPerm_a_death: {library.Options.perm_death}"
         messagebox.showinfo("Settings Changed!", message) # tk built in message
         GameOptions.destroy(self) # destroys toplevel after all actions complete.
 
@@ -221,8 +221,8 @@
     def playersetter(self):
         """Binds values from spinbox to gui_var for later use and calls next stage. Calls player slice and meth to set
         initial player cards. COULD USE A INSTANCE FACTORY TO BUILD PLAYERS"""
-        gameVar.StartVariables.new_players = self.Num_of_players.get() # int for Playerinfo toplevel window generation per player
-        gameVar.StartVariables.player_rand = self.Num_of_players.get() # binds in 2nd location for later used in indexing
+        library.StartVariables.new_players = self.Num_of_players.get() # int for Playerinfo toplevel window generation per player
+        library.StartVariables.player_rand = self.Num_of_players.get() # binds in 2nd location for later used in indexing
         engine.select_players() #creates slice object (session_players) and calls dealer to hand each a starting cards set
         PlayerInfo() # each player in session_players sets their name and gender in a toplevel window.
 
@@ -273,16 +273,16 @@
         Secondary requirements: Increments arbitrary label_counter & counts down from the number of players in-game
         ensuring all get attribute assignment. """
 
-        players_assign = gameVar.StartVariables.new_players # players_assign  = total players_assign of players in play ie 4.
+        players_assign = library.StartVariables.new_players # players_assign  = total players_assign of players in play ie 4.
         if players_assign >= 1: # loop wont work as branch needs to be restarted per player
             players_assign -= 1 # decreases the num of new pLayer integer to count down players_assign of players left to assign
             PlayerInfo.label_counter += 1 # increase player counter for arbitrary label in class scope
-            gameVar.PlayerAtribs.player_name = self.instname.get() # gameVar atrib is used to store the entered player name.
-            gameVar.PlayerAtribs.player_gender = self.instgender.get() # entered gender binds to gameVar
+            library.PlayerAtribs.player_name = self.instname.get() # gameVar atrib is used to store the entered player name.
+            library.PlayerAtribs.player_gender = self.instgender.get() # entered gender binds to gameVar
             engine.player_name_gender(PlayerInfo.list_indexer) # method to index session_players list for specific player and set name and gender attribs
             PlayerInfo.list_indexer = PlayerInfo.list_indexer + 1 # increases index value so looping will call next player in session_players list
             PlayerInfo.destroy(self) # destroys toplevel window wiping all entered info for next player to enter
-            gameVar.StartVariables.new_players = players_assign # gamevar is bound to the new value for players_assign
+            library.StartVariables.new_players = players_assign # gamevar is bound to the new value for players_assign
 
             if players_assign != 0: # loop for next player
                 PlayerInfo() # rebuilds toplevel anew for next player
@@ -291,7 +291,7 @@
                 PlayerInfo.destroy(self) # final destruction of top window
                 #~~~~~~~~ debug loop
                 print("\nPlayers in game:", end=" ")
-                for players in gameVar.GameObjects.session_players: # loop to see all player names
+                for players in library.GameObjects.session_players: # loop to see all player names
                     print(players.name.title(), end=", ") # checks all players names assigned in session_players
                 print("\n...............")
                 #~~~~~~~~~~~~~~~
@@ -416,7 +416,7 @@
         """require method to be called from gameloop to rebase all variables in guivar. this should update the var in Mainloop
         with app.update_frame() method call"""
         # meth for checking sack size of player
-        gameVar.CardDraw.door_attempts = 1 # resets door kicks for next player.. Should change to false
+        library.CardDraw.door_attempts = 1 # resets door kicks for next player.. Should change to false
         self.canvas.delete("all")  # clears the canvas(table) for new player
         # Methods that need to be applied to a player for next turn.
         self.door_button.config(state="normal") # enables kick door button
@@ -427,7 +427,7 @@
         self.run_away_button.config(state="disabled")  # run
         # app.update_message() #clears all messages
 
-        engine.player_order(gameVar.GameObjects.active_player) # sends active player rebind new player in game_loop
+        engine.player_order(library.GameObjects.active_player) # sends active player rebind new player in game_loop
         Tools.fluid_player_info() # adds or removes player class2/race2 option
         app.update_message()  # clears all messages
         app.update_message("show") # updates main broadcast message
@@ -438,17 +438,17 @@
     def door(self):
         """game actions for door. cards drawn from door"""
         print("\nKicking door!")
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
         self.message2.destroy()  # removes dev label
 
         self.end_turn_button.config(state="disabled") # disables end turn button, enabled at end of fight
 
         #main actions
-        door_card = engine.deal_handler("door") # fetch a door card
-        engine.door_card_designator(door_card, door_attempts=gameVar.CardDraw.door_attempts)  # defines the actions to be taken with he card...TODO should this be moved to bottom???
+        door_card = engine.deal_handler("door") # returns a door card
+        engine.door_card_designator(door_card, door_attempts=library.CardDraw.door_attempts)  # defines the actions to be taken with the card...TODO should this be moved to bottom???
 
         #card viewing
-        if gameVar.CardDraw.door_attempts: # first kick of door (always get this at start of turn!)
+        if library.CardDraw.door_attempts: # first kick of door (always get this at start of turn!)
             print("VIEWING CARD")
 
             self.pic = Tools.viewer(door_card["id"]) # gets card id. needs self or garbage collected!
@@ -456,7 +456,7 @@
 
             #broadcast
             if door_card.get('type') != 'monster' and door_card.get('type') != 'curse': # updated from door_card_designator for genearl object not monster or curse
-                gameVar.GameObjects.message = f"Your card is: {door_card.get('name')}"
+                library.GameObjects.message = f"Your card is: {door_card.get('name')}"
             app.update_message("show") #update the broadcast message
 
             #if monster do this and turn off these buttons.
@@ -472,9 +472,9 @@
                 #meth to return card, use id to put card pic
 
         # 2nd attempt circumstance
-        elif gameVar.CardDraw.door_attempts == 0:
+        elif library.CardDraw.door_attempts == 0:
             print("2nd kick activated")
-            gameVar.GameObjects.message = f"You have drawn a face down card that is placed in your hand"
+            library.GameObjects.message = f"You have drawn a face down card that is placed in your hand"
             app.update_message("show")  # update the broadcast message
             self.pic = Tools.viewer(0)  # gets card pic face down
             self.canvas.create_image(10, 10, image=self.pic, anchor="nw") # puts door card face down
@@ -482,9 +482,9 @@
             self.end_turn_button.config(state="normal") # enables fight
             app.update_message("show")
 
-        gameVar.CardDraw.door_attempts = 0  # set to false
+        library.CardDraw.door_attempts = 0  # set to false
         Tools.fluid_player_info() # updates any changes cause by curses
-        print("num of kicks", gameVar.CardDraw.door_attempts)
+        print("num of kicks", library.CardDraw.door_attempts)
 
     # def update_info(self): # may be redundant for TOOLS fluid_player_info just button link left
     #     """method to update a player info window with any changes ie halfbreed ect"""
@@ -497,6 +497,8 @@
 
     def fight(self):
         ### NEEDS CONTROL TO ASK WHICH MONSTER TO FIGHT IF MORE THATN ONE THEN WAY TO TURN ON ANY MONSTER METHODS, THINK TL WITH CB & CARD INFO
+        # method to select monster (radio button) and return it into play
+
         print("Fight button pressed")
         selfobj = app.frames[MainLoop]
         result = engine.fight() # helper may be added when sorting it
@@ -522,7 +524,7 @@
     def run(self):
         engine.card_method_activator("persistent", "on", table_card_index=0) # grabs the 1st card put on the table to run persistent method. TODO: change card_num for a card selector
 
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
         if player.run_away: # checks ability to run from player attrib
             result = engine.run()
             if result == "success":
@@ -531,81 +533,81 @@
                 self.run_away_button.config(state="disabled")  # run
                 self.canvas.delete("all")  # clears the canvas, not quite right as will remove all cards TAG maybe?
             else:
-                gameVar.GameObjects.message = "You are trapped! All that is left is to fight!"
+                library.GameObjects.message = "You are trapped! All that is left is to fight!"
                 app.update_message("show")
                 self.run_away_button.config(state="disabled")  # run
 
         else:
-            gameVar.GameObjects.message = "This is not a fight you can run from!"
+            library.GameObjects.message = "This is not a fight you can run from!"
             app.update_message("show")
             self.run_away_button.config(state="disabled")  # run
 
     def list_weapons(self):
         """ builds a list of cards that meet the the weapons criterion. List is bound to gameVar..selected_items """
-        gameVar.GameObjects.message = "Weapons list"
+        library.GameObjects.message = "Weapons list"
         app.update_message("show")
         engine.scrub_lists()
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
         player.inventory("type", "weapon") # key= 'type', value = 'weapon'
         # print(gameVar.GameObjects.selected_items)  list all items placed in list that meet the criteria above.
         OwnedItems("Weapons owned", "weap")
 
     def list_armor(self):
-        gameVar.GameObjects.message = "Armour list"
+        library.GameObjects.message = "Armour list"
         app.update_message("show")
         engine.scrub_lists()
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
         player.inventory("type", "armor") # load all weapons items into gamevar.selected_items
         OwnedItems("Armor Owned", "armor")
 
     def consumables(self):
-        gameVar.GameObjects.message = "Consumable items"
+        library.GameObjects.message = "Consumable items"
         app.update_message("show")
         engine.scrub_lists()
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
         player.inventory("type", "disposable")
         OwnedItems("One shot items", "consume")
 
     def list_sell(self):
         """builds toplevel with sellable items"""
-        gameVar.GameObjects.message = "Sell selected"
+        library.GameObjects.message = "Sell selected"
         app.update_message("show")
         engine.scrub_lists() # resets all lists for next action
-        player = gameVar.GameObjects.active_player # gets current player
+        player = library.GameObjects.active_player # gets current player
         player.item_by_key("sell") # generates list of sellable cards passed on to gameVar.selected_items
         # print(gameVar.StartVariables.selected_items) # call method that in gamefile that creates zip
         OwnedItems("Sellable Items", "sell") # calls toplevel with window title
 
     def hand(self):
-        gameVar.GameObjects.message = "Hidden items selected"
+        library.GameObjects.message = "Hidden items selected"
         app.update_message("show")
         engine.scrub_lists()
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
         player.inventory("category", "door")
         OwnedItems("Hidden Items", "hidden")
 
     def interfere(self): #will link to player select toplvl window that then add an action . may need to look at card_matcher to be more flexible
-        gameVar.GameObjects.message = "Toplevel window where another player can interfere with play\n NOT SET UP"
+        library.GameObjects.message = "Toplevel window where another player can interfere with play\n NOT SET UP"
         app.update_message("show")
 
     def ask_for_help(self): #mot set
-        gameVar.GameObjects.message = "Toplevel window where another player can help... for a price.."
+        library.GameObjects.message = "Toplevel window where another player can help... for a price.."
         app.update_message("show")
         Table_Target_Selector()
 
     def list_sack(self):
         """shows all items in sack"""
-        gameVar.GameObjects.message = "The contents of sack:"
+        library.GameObjects.message = "The contents of sack:"
         app.update_message("show")
         engine.scrub_lists()
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
         player.inventory("category", "treasure")
         OwnedItems("Sack Items")
 
     def list_equipped(self):
         """list showing all items that are equipped"""
         engine.scrub_lists()
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
         player.equipped_items("list_equipped")
         OwnedItems("Equipped Items", "remove")
 
@@ -624,7 +626,7 @@
         self.set_but = set_but
         # print(f"Top level self: {self}")
 
-        if not gameVar.GameObjects.selected_items: # if nothing in list display a label message
+        if not library.GameObjects.selected_items: # if nothing in list display a label message
             fm = tk.Frame(self)
             fm.pack(side="top", expand=True)
             tk.Label(fm, text="No cards to show").pack(side='top')
@@ -647,7 +649,7 @@
 
             # specific labels and tk variable
             set_row = 1 # row incrementor for loop
-            for card in gameVar.GameObjects.selected_items: # for each card in the selected items
+            for card in library.GameObjects.selected_items: # for each card in the selected items
                 status = tk.IntVar() # for keeping track of check buttons, 1 per loop ### TODO can i change to bool? will loose list then
                 tk.Label(f, text=card['name']).grid(row=set_row, column=0, sticky="nw")
                 tk.Label(f, text=card['type']).grid(row=set_row, column=1, sticky="nw")
@@ -659,8 +661,8 @@
                     tk.Checkbutton(f, text=" ", variable=status).grid(row=set_row, column=3, sticky="nw")
                 tk.Button(f, text="Info", command=lambda c=card["id"]: self.showcard(c)).grid(row=set_row, column=4)
 
-                gameVar.GameObjects.check_but_intvar_gen.append(status) # creates list of IntVars for each item in list
-                gameVar.GameObjects.check_but_card_ids.append(card["id"]) # sends card ids int to list
+                library.GameObjects.check_but_intvar_gen.append(status) # creates list of IntVars for each item in list
+                library.GameObjects.check_but_card_ids.append(card["id"]) # sends card ids int to list
                 set_row += 1
 
         # specific buttons
@@ -716,8 +718,8 @@
         self.title('Target Selector')
         self.frame = tk.Frame()
 
-        self.player = gameVar.GameObjects.active_player
-        self.all_players = gameVar.GameObjects.session_players
+        self.player = library.GameObjects.active_player
+        self.all_players = library.GameObjects.session_players
 
         self.frame.pack(fill='both', expand=True)
         # print(self.all_players)
@@ -759,20 +761,20 @@
         """class for showing individual player info ie klass2 race2"""
         selfid = app.frames[MainLoop]  # simplifies attachment to value for direct access.
 
-        if not gameVar.GameObjects.active_player.race_unlock:
+        if not library.GameObjects.active_player.race_unlock:
             selfid.race2_option.grid_forget()
             selfid.race2_optionb.grid_forget()
         else:
             selfid.race2_option.grid(row=8, column=1, sticky='nsew')
             selfid.race2_optionb.grid(row=8, column=2, sticky='nsew')
-        if not gameVar.GameObjects.active_player.klass_unlock:
+        if not library.GameObjects.active_player.klass_unlock:
             selfid.klass2_option.grid_forget()
             selfid.klass2_optionb.grid_forget()
         else:
             selfid.klass2_option.grid(row=9, column=1, sticky='nsew')
             selfid.klass2_optionb.grid(row=9, column=2, sticky='nsew')
 
-        engine.player_attrib_ipc_updater(gameVar.GameObjects.active_player) # ensures all player info is up to
+        engine.player_attrib_ipc_updater(library.GameObjects.active_player) # ensures all player info is up to
         # date and sent to gameVar
         app.update_atrib_frame() # updates the GUI with the new player info
         engine.scrub_lists() # clears all the lists for zipper ect for fresh search
Index: Munchkin/bin/engine/game_loop_v3.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/engine/game_loop_v3.py b/Munchkin/bin/engine/controller.py
rename from Munchkin/bin/engine/game_loop_v3.py
rename to Munchkin/bin/engine/controller.py
--- a/Munchkin/bin/engine/game_loop_v3.py	(revision df7008cb24f4d02549b37b4a5e8f0fb166521d60)
+++ b/Munchkin/bin/engine/controller.py	(date 1650359625477)
@@ -1,4 +1,6 @@
-"""Initiates player personalisation and runs game cycle for each player fetching cards and initiation
+"""
+Controller provudes backend logic to the view script and makes changes to variable library
+Initiates player personalisation and runs game cycle for each player fetching cards and initiation
 each scene of play
 
 Contents functions:
@@ -16,7 +18,7 @@
 # from Munchkin.bin.engine import cut_scenes as cs
 from Munchkin.bin.all_cards.table import cards, dice
 from random import randint, choice
-import bin.GUI.gui_variables as gameVar
+import bin.GUI.variables_library as library
 from itertools import cycle
 
 from time import sleep
@@ -40,23 +42,23 @@
     def select_players(self): # slices num of available players with gui entry
         """called from gui (playersetter method) takes gameVar int and uses to slice list of player instances and binds to new gameVar (active_players).
          deal_handler is called to provide starting number of cards for each player"""
-        num_of_players = gameVar.StartVariables.new_players # get int representing num of players in current session (from spinbox)
+        num_of_players = library.StartVariables.new_players # get int representing num of players in current session (from spinbox)
         print(f"Number of players in session: {num_of_players}") ## GUI test for number acceptance# remove at end. calls __repr__ for each instance
-        gameVar.GameObjects.session_players = gameVar.StartVariables.players_available[:num_of_players] # slice creates new list of players in
+        library.GameObjects.session_players = library.StartVariables.players_available[:num_of_players] # slice creates new list of players in
         # session binding to new variable gamevar
         self.deal_handler("start") # Deals cards to all players. results in putting in player.sack. Does not bind to gameVar
 
     def player_name_gender(self, playerindex): # gui attrib, passes session_players index identifying specific instance
         """Gets player with list index and Sets name and gender to that player instance."""
-        player = gameVar.GameObjects.session_players[playerindex] #references a player objects from session_players
+        player = library.GameObjects.session_players[playerindex] #references a player objects from session_players
         player.char_setup() # call to set name and gender of player instance.
 
     def set_random_player(self):
         """Selects random player to start from session_players list. Binds player as active_player and calls
         method to load all attributes of the player (player_attrib_ipc_updater(). parameter is optional but explicit)"""
-        player = choice(gameVar.GameObjects.session_players) # selects random player from list of players
-        gameVar.GameObjects.active_player = player # assigns the selected player to active player in gamevar for gui to see
-        gameVar.GameObjects.message = f"The dice has been rolled. Random player selected is {player.name.title()}"
+        player = choice(library.GameObjects.session_players) # selects random player from list of players
+        library.GameObjects.active_player = player # assigns the selected player to active player in gamevar for gui to see
+        library.GameObjects.message = f"The dice has been rolled. Random player selected is {player.name.title()}"
         self.player_attrib_ipc_updater(player) # arg not needed. Calls method to set all attribs in in gamevar of player
 
 # class Game_Play:
@@ -65,46 +67,46 @@
         """Triggered at end of turn. Note 1st player was random and assigned to active_player after player creation.
         Current_player = active player"""
         play = True # win condition need method that will check all players
-        player_gen = cycle(gameVar.GameObjects.session_players) # generator function that cycles a list indefinitely
+        player_gen = cycle(library.GameObjects.session_players) # generator function that cycles a list indefinitely
         y = next(player_gen) # yields players from the list, at start this would be first item = p1.
         while play:
             if current_player == y and current_player.alive: # conditions to see if x==y (x= player, y=list item)
                 print(f"Current player {current_player.name} turn ended\n")
-                gameVar.GameObjects.active_player = next(player_gen) # binds next player to rand_player, (changes x)
-                self.player_attrib_ipc_updater(gameVar.GameObjects.active_player) #  binds new player
-                print(f"{gameVar.GameObjects.active_player.name} has been binded")
+                library.GameObjects.active_player = next(player_gen) # binds next player to rand_player, (changes x)
+                self.player_attrib_ipc_updater(library.GameObjects.active_player) #  binds new player
+                print(f"{library.GameObjects.active_player.name} has been binded")
                 break
-            elif current_player == y and not current_player.alive and not gameVar.Options.perm_death:
+            elif current_player == y and not current_player.alive and not library.Options.perm_death:
                 print(f"print player {current_player} is dead") # move in to conditional for perm-a-death
                 current_player.alive = True # resets player status ##########need per-a-death bit here
-                gameVar.GameObjects.active_player = next(player_gen) # changes x without binding and moves to next player
+                library.GameObjects.active_player = next(player_gen) # changes x without binding and moves to next player
                 continue
             else:
                 print(f"{y.name.title()} did not match. Searching for player in list")
                 y = next(player_gen) # changes y to find commonality to x
 
-        gameVar.GameObjects.message = f"{gameVar.GameObjects.active_player.name.title()}'s turn..."
+        library.GameObjects.message = f"{library.GameObjects.active_player.name.title()}'s turn..."
 
-    def player_attrib_ipc_updater(self, playerinst=gameVar.GameObjects.active_player): # defaults to gamevar active_player player
+    def player_attrib_ipc_updater(self, playerinst=library.GameObjects.active_player): # defaults to gamevar active_player player
         """Binds all player atribs to gameVar for current player activity. Can take param of a player or grab active_player."""
-        gameVar.PlayerAtribs.player_name = playerinst.name.title()
-        gameVar.PlayerAtribs.player_gender = playerinst.gender.title()
-        gameVar.PlayerAtribs.player_level = playerinst.level
-        gameVar.PlayerAtribs.player_bonus = playerinst.bonus
-        gameVar.PlayerAtribs.player_wallet = playerinst.wallet
-        gameVar.PlayerAtribs.player_race = playerinst.race.title()
-        gameVar.PlayerAtribs.player_race2 = playerinst.race2.title()
-        gameVar.PlayerAtribs.player_klass = playerinst.klass.title()
-        gameVar.PlayerAtribs.player_klass2 = playerinst.klass2.title()
-        gameVar.PlayerAtribs.player_sack = playerinst.sack
-        gameVar.PlayerAtribs.player_l_hand = playerinst.update_bindings("L_hand")
-        gameVar.PlayerAtribs.player_r_hand = playerinst.update_bindings("R_hand")
-        gameVar.PlayerAtribs.player_two_hand = playerinst.update_bindings("two_hand")
-        gameVar.PlayerAtribs.player_headgear = playerinst.update_bindings("headgear")
-        gameVar.PlayerAtribs.player_armor = playerinst.update_bindings("armor")
-        gameVar.PlayerAtribs.player_knees = playerinst.update_bindings("knees")
-        gameVar.PlayerAtribs.player_footgear = playerinst.update_bindings("footgear")
-        gameVar.PlayerAtribs.player_necklace = playerinst.update_bindings("necklace")
+        library.PlayerAtribs.player_name = playerinst.name.title()
+        library.PlayerAtribs.player_gender = playerinst.gender.title()
+        library.PlayerAtribs.player_level = playerinst.level
+        library.PlayerAtribs.player_bonus = playerinst.bonus
+        library.PlayerAtribs.player_wallet = playerinst.wallet
+        library.PlayerAtribs.player_race = playerinst.race.title()
+        library.PlayerAtribs.player_race2 = playerinst.race2.title()
+        library.PlayerAtribs.player_klass = playerinst.klass.title()
+        library.PlayerAtribs.player_klass2 = playerinst.klass2.title()
+        library.PlayerAtribs.player_sack = playerinst.sack
+        library.PlayerAtribs.player_l_hand = playerinst.update_bindings("L_hand")
+        library.PlayerAtribs.player_r_hand = playerinst.update_bindings("R_hand")
+        library.PlayerAtribs.player_two_hand = playerinst.update_bindings("two_hand")
+        library.PlayerAtribs.player_headgear = playerinst.update_bindings("headgear")
+        library.PlayerAtribs.player_armor = playerinst.update_bindings("armor")
+        library.PlayerAtribs.player_knees = playerinst.update_bindings("knees")
+        library.PlayerAtribs.player_footgear = playerinst.update_bindings("footgear")
+        library.PlayerAtribs.player_necklace = playerinst.update_bindings("necklace")
 
 # card handling class:
 
@@ -113,11 +115,11 @@
         Deal_amount defines how many of the cards are to be returned to a player.
         """
 
-        playerinst = gameVar.GameObjects.active_player # gets current player, at start this is none.
+        playerinst = library.GameObjects.active_player # gets current player, at start this is none.
 
         if option == "start": # initial play selector to deal cards to each player. NO GOOD FOR RESURRECT OPTION as deals to all players
-            for player in gameVar.GameObjects.session_players: #loops over each player in session_players
-                player.sack = cards.card_sop.deal_cards(option, cardnum=gameVar.Options.cards_dealt) # deals cards with params "start" & num of cards to deal)
+            for player in library.GameObjects.session_players: #loops over each player in session_players
+                player.sack = cards.card_sop.deal_cards(option, cardnum=library.Options.cards_dealt) # deals cards with params "start" & num of cards to deal)
 
         elif option == "door": # Standard gameplay loop on door kick
             print("In deal_handler, retrieving door card & determining fate of card")  # test location
@@ -130,8 +132,8 @@
             playerinst.sack = playerinst.sack + add_treasure # DUMPS ALL IN THE ACTIVE_PLAYER.....TODO::Sort how treasure is handled when used as currency for another players help
 
         elif option == "resurrect":
-            if gameVar.Options.perm_death:
-                playerinst.sack = cards.card_sop.deal_cards("start", cardnum=gameVar.Options.cards_dealt)
+            if library.Options.perm_death:
+                playerinst.sack = cards.card_sop.deal_cards("start", cardnum=library.Options.cards_dealt)
             else:
                 print(f"Game over for {playerinst.name}, BUMMER!")
 
@@ -143,20 +145,20 @@
         Cards have different fates dependent upon the type of card it is ie: monster, curse, other and the number of
         times the door button is clicked. Also update the message dependent on action
         """
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
 
         if door_attempts: #On first kick of the door. Decides what to do with the cards dependent on situation
 
             # if monster, put on table ready to fight
             if card.get("type") == "monster": # if the cards a monster #1st/2nd kicks covered
-                gameVar.GameObjects.message = f"{card.get('name')} placed on table, Level {card.get('lvl')}"
+                library.GameObjects.message = f"{card.get('name')} placed on table, Level {card.get('lvl')}"
                 cards.in_play.append(card) # places card on table. functionality returned to gui. TODO this is where to create lol on table, need downstream processing changed
                 print("This is the card in play;", cards.in_play)
 
 
             # WORK REQUIRED!!     if curse, activate effects. need check to see if conditions in place to stop cursing ie ork/ wishing ring.
             elif card.get("type") == "curse": # if the cards a monster #1st/2nd kicks covered
-                gameVar.GameObjects.message = f"The room you have entered has a curse {card.get('name').title()}.\n Lets hope you have protection!"
+                library.GameObjects.message = f"The room you have entered has a curse {card.get('name').title()}.\n Lets hope you have protection!"
                 print("In curse::", player.active_curses)
                 # ~~~~~~~~~~~~~TODO  curse checker method required ie tin hat, ork ect
                 if card.get("duration") == "persistent": # for constant effect curse
@@ -167,7 +169,7 @@
                     cards.burn_pile.append(card) # disposes of to burn pile
                     print(f"card duration is one_shot, added to burn pile check:\nBurn pile {cards.burn_pile}")
                 elif card.get("duration") == "timed": ########## for time dependent effect
-                    gameVar.GameObjects.message = f"timed curse card not configured yet" # overrides top message
+                    library.GameObjects.message = f"timed curse card not configured yet" # overrides top message
                     #TODO meth for timed
                     cards.burn_pile.append(card) # disposes of to burn pile
                     print(f"card status is passive, should be added to burn pile!\nBurn pile {cards.burn_pile}")
@@ -175,20 +177,20 @@
             else: # for all other cards that have no direct effect or influence.
                 print(f"Adding {card['name']}to sack.")
                 player.sack.append(card)  # adds card to player's items
-                gameVar.GameObjects.message = f"Adding 2nd draw to sack." # need to be removed dont want to broadcast what other player gets
+                library.GameObjects.message = f"Adding 2nd draw to sack." # need to be removed dont want to broadcast what other player gets
                 return card  # to show if first time only 2nd it hides
 
         else:
             "2nd kick of door (looting room). Will need condition statement if player wants to fight mon from hand, rather than std flow to sack"
             print("adding to sack")
-            gameVar.GameObjects.message = "2nd kck, Adding card to sack"  # 2nd kick
+            library.GameObjects.message = "2nd kck, Adding card to sack"  # 2nd kick
             player.sack.append(card)  # adds to player sack
 
     def card_method_activator(self, scenario, action, table_card_index): # will need to be a selector
         """method to activate a card dependent upon the scenario of having a specific monster/ curse/ item in play and action to
         switch on or off the condition"""
         card = cards.in_play[int(table_card_index)] # selects the monster in the fight on the table
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
         if scenario == "persistent":
             player.card_meths(card, 'static', action)  ######## will cause probs with monster individuality ######################
 
@@ -198,26 +200,26 @@
     def zipper(self, action):
         """zips card id's to checkbox bools from selected_list. Used for all card sorting regardless of card type.
         action is conduit for card_matcher"""
-        gameVar.GameObjects.zipped_tup.clear()  # clears tup list ready for new entry. not working...................
-        for status in gameVar.GameObjects.check_but_intvar_gen: # gets attribute from object then from the attribute which is an object gets the value stored (list>intvar>get()>1 or 0)
-            gameVar.GameObjects.check_but_boo.append(status.get()) # creates a list of 1s & 0s from check buttons status
-            x, y = gameVar.GameObjects.check_but_card_ids, gameVar.GameObjects.check_but_boo
-            gameVar.GameObjects.zipped_tup = list(zip(x, y)) # result [(card_id,  bool), (card_id, bool)]
+        library.GameObjects.zipped_tup.clear()  # clears tup list ready for new entry. not working...................
+        for status in library.GameObjects.check_but_intvar_gen: # gets attribute from object then from the attribute which is an object gets the value stored (list>intvar>get()>1 or 0)
+            library.GameObjects.check_but_boo.append(status.get()) # creates a list of 1s & 0s from check buttons status
+            x, y = library.GameObjects.check_but_card_ids, library.GameObjects.check_but_boo
+            library.GameObjects.zipped_tup = list(zip(x, y)) # result [(card_id,  bool), (card_id, bool)]
         # print("moving to player script", gameVar.GameObjects.zipped_tup) # checker shows all cleared lists
         self.card_matcher(action)
 
     def card_matcher(self, action):
         """compares tuple to selected_items searching for matching card ids and only passes on cards that contain
         a tuple with the boolean true. Action determines the whats happening to the cards next. """
-        for card in gameVar.GameObjects.selected_items: # for every card in selected_items
-            for tup in gameVar.GameObjects.zipped_tup: # go over every tuple in  zipped_tup. (card_id, bool tuples).
+        for card in library.GameObjects.selected_items: # for every card in selected_items
+            for tup in library.GameObjects.zipped_tup: # go over every tuple in  zipped_tup. (card_id, bool tuples).
                 if tup[0] == card["id"] and tup[1]: # if tup id matches card fid from selected items and bool is True from the checkbox
                     if action == "sell":
-                        gameVar.GameObjects.active_player.sell_item(card)
+                        library.GameObjects.active_player.sell_item(card)
                     elif action in "equip, disposable ,use": # equip/disposable will be treasures
                         self.tri_qualifier(card) # test ~~ok~~
                     elif action == "remove":
-                        player = gameVar.GameObjects.active_player
+                        player = library.GameObjects.active_player
                         player.equipped_items("removal", card)
 
     def tri_qualifier(self, card):
@@ -225,7 +227,7 @@
         1st: checks card for a specific restriction that would count against a player due to a specific attrib, ie if u are human u cant use this card.
         2nd part: """
 
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
 
         checks = {player.race: "race_requirement", player.race2: "race_requirement", player.klass: "klass_requirement",
                   player.klass2: "klass_requirement", player.gender: "gender_requirement"} # card specific requirements to use
@@ -254,7 +256,7 @@
                     print(f"{player_attribs} - Dev path")
                     continue
                 else:
-                    gameVar.GameObjects.message = f"You cant use this card, {card_requirement}"
+                    library.GameObjects.message = f"You cant use this card, {card_requirement}"
                     flag = 0
                     # gameVar.StartVariables.message = f"{card.get('name')} can not be quipped: {val}." # not working
                     break
@@ -267,7 +269,7 @@
 
     def player_treasure_cards(self, card):
         """method to sort the locations of treasure cards that the player has selected"""
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
         if card.get("type") == "armor":
             player.equip_armor(card)  # leads to player meth for placing in right place
         elif card.get("type") == "weapon":
@@ -278,32 +280,32 @@
             pass # for all other cards ie steeds
 
     def player_door_cards(self, card): #card meth#####################################################
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
         player.card_meths(card, "method", "on")  # link to player to card meths.
         print(player.klass_unlock, player.race_unlock)  # only shows at end of turn due to meth restriction in class,
         # meths added at end_turn
 
     def scrub_lists(self):
         """Clears all appended list that are not capable of clearing."""
-        gameVar.GameObjects.selected_items.clear()  # clears the card objects list
-        gameVar.GameObjects.check_but_intvar_gen.clear()  # clears list of intVar objects from check buttons
-        gameVar.GameObjects.check_but_boo.clear()  # clears boolean list
-        gameVar.GameObjects.check_but_card_ids.clear()  # clears card id list
-        gameVar.GameObjects.zipped_tup.clear()  # clears tup list
+        library.GameObjects.selected_items.clear()  # clears the card objects list
+        library.GameObjects.check_but_intvar_gen.clear()  # clears list of intVar objects from check buttons
+        library.GameObjects.check_but_boo.clear()  # clears boolean list
+        library.GameObjects.check_but_card_ids.clear()  # clears card id list
+        library.GameObjects.zipped_tup.clear()  # clears tup list
 
 ##################################################################
     def fight(self, helper=0, additional=0):# helper would be other player interactions. additional is anything else
         """for cards that are monsters and placed on the table"""
         print("In the fight!")
         card = cards.in_play.pop() # end of cards on table
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
         player.card_meths(card, 'static', 'on') # turns on card static content for fight TODO change to something more relevant than "static"
-        if player.bonus + player.level + helper + gameVar.Fight_enhancers.player_aid \
-                >= card["lvl"] + gameVar.Fight_enhancers.monster_aid: # consideration required for player consumables and enhancers
+        if player.bonus + player.level + helper + library.Fight_enhancers.player_aid \
+                >= card["lvl"] + library.Fight_enhancers.monster_aid: # consideration required for player consumables and enhancers
             print("Player wins!")
             reward = card['treasure']
             self.deal_handler('treasure', deal_amount=reward) # fetches treasure for player
-            gameVar.GameObjects.message = f"You win! You have found {reward} treasures for your trouble."
+            library.GameObjects.message = f"You win! You have found {reward} treasures for your trouble."
             player.level += card["level_up"]
             cards.burn_pile.append(card) # removes card
             player.card_meths(card, 'static', 'off') # turns off static card content
@@ -311,7 +313,7 @@
             return "win"
         # need action to go up lvl note some cards do more than one level!
         else:
-            gameVar.GameObjects.message = "Fight lost"
+            library.GameObjects.message = "Fight lost"
             print("Fight lost")
             player.card_meths(card, 'method', 'on') # calls card bad stuff
             player.card_meths(card, 'static', 'off') # turns off static effect of card in play
@@ -319,7 +321,7 @@
 
     def run(self):
         roll = dice.dice_sop.roll()
-        player = gameVar.GameObjects.active_player
+        player = library.GameObjects.active_player
         print(f"You rolled a {roll}.")
         if roll >= player.run:
             print(f"You rolled a {roll}. You out ran your pursuer.")
Index: Munchkin/bin/players/playersetup.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"Classes to define player/s and specific attributes and mechanics (\n\nConsiderations:\n    user name  ...............................Complete\n    gender ......................................Complete\n    play order, may be toplevel(engine)...........Complete, in engine!!\n    number of players ........................... Complete in engine\n\n\n    \"\"\"\n\nimport bin.GUI.gui_variables as gameVar\n\n\nclass P_tools():\n    \"\"\"Tools associated to the player class\"\"\"\n\n    # def equip(self, card): #recieves player instance and card dict #todo\n    #     # for name, component in card.items():\n    #     #     print(f\"{name}: {component}\n    #     print(f'{card[\"name\"]} to be equipped to {self.name}')\n    #     # if card[\"lvl\"]:\n    #     #     print(\"can not equip monster\")\n\n    # def card_options(self, card): # receives card object #todo missing veiw for all cards in player sack\n    #     \"\"\"Options for cards: Equip, Use, Sell and Charity\"\"\"\n    #     print(f\"You have chosen: {card}\")\n    #     sack_menu = input(\"Sack options:\\n1) Equip\\n2) Use\\n3) Sell\\n4) Charity\\n5) Back\\n>>> \")\n    #     if sack_menu.title() == \"1\" or \"Equip\":\n    #         # print(contents)\n    #         P_tools.equip(self, card)  # sends self and card to method\n    #\n    #     elif sack_menu.title() == \"2\" or \"Use\":\n    #         print(\"used up\")  # to method\n    #     elif sack_menu.title() == \"3\" or \"Sell\":\n    #         pass  # to method\n    #     elif sack_menu.title() == \"3\" or \"Charity\":\n    #         pass  # to method\n    #     elif sack_menu.title() == \"3\" or \"Back\":\n    #         print('returning back only')\n    #         return 'back',\n    #     else:\n    #         print(\"Unknown command\")\n\n\n    @classmethod\n    def gender(cls):\n        \"\"\"Sets gender\"\"\"\n        x = gameVar.PlayerAtribs.player_gender\n        return x\n\n    @classmethod\n    def name(cls):\n        \"\"\"Sets name\"\"\"\n        x = gameVar.PlayerAtribs.player_name\n        if x == \"rory\": # ......................................................................... dev mode\n            y = \"The_Creator\"\n            return y\n        return x\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/players/playersetup.py b/Munchkin/bin/players/playersetup.py
--- a/Munchkin/bin/players/playersetup.py	(revision df7008cb24f4d02549b37b4a5e8f0fb166521d60)
+++ b/Munchkin/bin/players/playersetup.py	(date 1650359625509)
@@ -9,7 +9,7 @@
 
     """
 
-import bin.GUI.gui_variables as gameVar
+import bin.GUI.variables_library as gameVar
 
 
 class P_tools():
Index: Munchkin/bin/players/playermodel.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nClass to build model players and assign new attributes associated with cards through gameplay.\n\nConsider what the player class is responsible for...\n\nConsiderations:\n    Player model\n    player setup name & gender\n    Death and reset\n    accessing player and changing player resources\n    save -- most likely shelve objects\n    stats access\n\n\"\"\"\n\n\nfrom Munchkin.bin.all_cards.table import Table # most likely not used here (pos for cross talk bypassing circular\n# import but may require for adding to player inventory and stats (note same card in engine will return here)\nfrom Munchkin.bin.all_cards.treasure_cards.treasurecards import Treasure\n\nfrom Munchkin.bin.players.playersetup import P_tools # OF LITTLE USE. Methods name/gender moved to this script.\nimport bin.GUI.gui_variables as gameVar\nfrom bin.all_cards.table import cards\nfrom bin.all_cards.door_cards.doorcards import MonTools\nfrom bin.all_cards.treasure_cards.treasurecards import T_tools\nfrom itertools import cycle\n\n\"\"\"This is the player class. It will have all setting to configure players and modify attributes that are set to that\nplayer. It will inherit from moncurse and treasure so that a player can add items to their attributes and modify\nattributes based on action outcomes.\"\"\"\n\n#####################################################################\n# MAIN PLAYER CLASS\n#####################################################################\n\nclass Player(MonTools, T_tools):\n    \"\"\"Main player class, inherits off card methods making changes to the player.\"\"\"\n\n    def __init__(self, ref):\n        self.ref = ref # simple form to keep track of players\n        self.name = \"\"\n        self.gender = \"male\" # default required..dont think it works like this...\n        self.level = 1 # win lvl 10, make changeable so edit score to win\n        self.bonus = 0\n        self.wallet = 0\n        self.race = \"human\" # string eval to True so will show\n        self.race2 = \"\"\n        self.race_unlock = False # DEFAULT = False method by halfbread triggers this a True state (method to be added)\n        self.klass = \"No class\"\n        self.klass2 = \"\"\n        self.klass_unlock = False # method by supermunchkin triggers this a True state\n        self.big = \"\" # can carry only 1 big item\n        self.big2 = []\n        self.big_unlock = False\n        self.weapons = {\"L_hand\": \"\", \"R_hand\": \"\", \"two_hand\": \"\"} # values will be cards\n        self.weapon_count = 2  # 1 per hand, can add to with cheat. adding +=, removal -=.\n        self.armor = {\"headgear\": \"\", \"armor\": \"\", \"knees\": \"\", \"footgear\": \"\",\n                      \"necklace\": \"\", \"ring\": \"\", \"ring2\": \"\"}\n        self.sack = [] # 5 max, editable in options\n        self.hireling = []\n        # self.unsorted = [] # Old! list of all cards that are used to by sorting\n        self.alive = True\n        self.longevity = 0 # counts cycles alive, if 0 player misses go\n        self.cheat = 0 # set to false\n        self.cheat_card = 0 # card the player is cheating with\n        self.enhancer_cards = []  # cards that elicit an effect ie supermunch/class card, ect. card lexical must be added to enhancer lexical\n        self.enhancers_lexical = set() # all positive effects strings for comparative evaluation. only added when card installed on player.\n        self.active_curses = []  # place to store all curse cards effecting player. card remove meth should reverse player change\n        self.negative_lexical = set() # all negative effects strings for comparative evaluation. only added when card installed on player.\n        self.run = 4 # ability to run, manipulable. note elf must change this. !!! use as bool and escape value!\n        self.run_away = True # locks ability toi run or not dependent on some monsters\n\n    def __repr__(self):\n        \"\"\"developer aid\"\"\"\n        return f\"\\nPLAYER REF:{self.ref}\\nName:{self.name}\\ngender:{self.gender}\\nLevel:{self.level}\" \\\n               f\"\\nBonus:{self.bonus}\\nSack:{self.wallet}\\n\"\n\n    # def __str__(self):\n    #     \"\"\"developer aid\"\"\"\n    #     return f\"\\nPLAYER INFO:\\nName:{self.name}\\ngender:{self.gender}\\nLevel:{self.level}\" \\\n    #            f\"\\nBonus:{self.bonus}\\n\"\n\n    @classmethod\n    def gender(cls):\n        \"\"\"Sets gender\"\"\"\n        x = gameVar.PlayerAtribs.player_gender # grabs string stored in in game var\n        return x\n\n    @classmethod\n    def name(cls):\n        \"\"\"Sets name\"\"\"\n        x = gameVar.PlayerAtribs.player_name\n        if x == \"rory\":  # ......................................................................... dev mode\n            y = \"The_Creator\"\n            return y\n        return x\n\n    def update_bindings(self, carried):\n        \"\"\"just gets whats attached to the player\"\"\"\n        category = [self.weapons, self.armor]  # locations to search\n        for sub_cat in category:  # is the dict as a whole\n            for key in sub_cat:\n                if isinstance(sub_cat[key], dict) and key == carried:\n                    # gameVar.GameObjects.message = f'{sub_cat.get(key).get(\"name\")} has been bound to {key}'\n                    return sub_cat.get(key).get(\"name\")\n\n    def char_setup(self):\n        # complete, prints to be removed\n        \"\"\"sets up name and gender in gameVar and player instance when called\"\"\"\n        na = Player.name() # method to set name\n        self.name = na  # makes change to player\n        xy = Player.gender()\n        self.gender = xy\n\n        if self.name == \"The_Creator\": # ................................................................... dev mode\n            self.gender = \"bob\"\n            self.bonus = 200\n            self.wallet = 20000\n            gameVar.PlayerAtribs.player_gender = self.gender\n            gameVar.GameObjects.message2 = f\"{self.name} is in play, a god among mer mortals!\"\n\n        #~~~~~~~~~~~~ info\n        print(f\"The player {self.name.title()} with the gender {self.gender.title()} has been created.\")\n        # ~~~~~~~~~~~~\n\n    def inventory(self, key, cardtype): # called from GUI on button press\n        \"\"\"Returns list of dict from player sack cards that have a specific key and specific value.\n        (ie sub_type == armour). returns all sub_types with the val of armor\"\"\"\n        gameVar.GameObjects.selected_items = [obj for obj in self.sack if obj[key] == cardtype]\n\n    def item_by_key(self, key):# generalised meth for key search\n        \"\"\"Returns list of cards form player sack list that contain the key x. (ie \"sell\").\n        This is generalised meth for key search \"\"\"\n        gameVar.GameObjects.selected_items = [obj for obj in self.sack if obj.get(key)]\n\n    def sell_item(self, card): # called by player.sell_item so self bound to player\n        \"\"\"Call from zipper to sell items, remove cards, reset gameVars and call to add to burn pile\"\"\"\n        self.wallet += card[\"sell\"] #adds worth of card to player\n        gameVar.GameObjects.message = f\"Selling sack {card['name']}, Card added to burn pile. Depth: {len(cards.burn_pile)}\"\n        x = self.sack.pop(self.sack.index(card)) # removes card from player sack deck\n        cards.add_to_burn(x)# adds card to burn pile on table\n        gameVar.GameObjects.message = f\"Selling sack {card['name']}, \" \\\n                                      f\"\\nCard added to burn pile. Depth: {len(cards.burn_pile)}\"\n        # print(\"tup list: \", gameVar.GameObjects.zipped_tup)\n\n    def sum_of_bonuses(self): # pos multi usage and use as player item searcher. limited by equipped_items as caller\n        \"\"\" Adds up all bonuses and bind to player in weapons and armour\"\"\"\n        tot_bonus = 0\n        locations = [self.weapons, self.armor] #locations to search\n        for obj in locations: # looks at each object in list\n            for sub_menu in obj:\n                if isinstance(obj[sub_menu], dict): #checks submenu for card attachment in the form of a dict\n                    # print(obj.get(sub_menu, \"No sub menu\").get(\"bonus\", \"No bonus found\"))\n                    tot_bonus += obj.get(sub_menu, \"\").get(\"bonus\", \"Problem getting bonus\")\n                    continue\n        if self.name == \"The_Creator\":\n            tot_bonus = 200 + tot_bonus\n        self.bonus = tot_bonus\n\n    def equipped_items(self, action, my_cards=None, card_id=None): # in use by gui list_equipped meth\n        \"\"\"Shows all items that have been equipped to the player. If remove, Sorts through equipped items,\n        removing items that have been selected\"\"\"\n        locations = [self.weapons, self.armor]  # locations to search\n        for obj in locations:  # looks at each object in list. obj is the dict of all the poss locations as seen in player attrbs\n            for sub_menu in obj:  # sub_menu is the keys which link to the card is placed in: armor = {}\n                if isinstance(obj[sub_menu], dict):  # checks submenu for card attachment in the form of a dict\n                    card = obj.get(sub_menu) # x is the card object\n                    if action == \"list_equipped\":\n                        gameVar.GameObjects.selected_items.append(card) #adds cards to selected_items list in gameVar\n                        continue\n                    elif action == \"removal\":\n                        if card[\"id\"] == my_cards[\"id\"]:\n                            self.sack.append(card) # adds card back to player inventory\n                            obj[sub_menu] = \"\" # resets player atrib location\n                            self.sum_of_bonuses() # recalculates bonuses\n                            self.weapon_count += card.get(\"hold_weight\", 0) # adds the cards carry_weight for available hands, if available.\n                            continue\n                    elif action == \"curse\": # not tested\n                        print(\"In equipped items remove cursed item\")\n                        pass\n\n    def equip_armor(self, card):\n        \"\"\" Equips armor to the player\"\"\"\n        location = self.armor\n        print(\"in armor\")\n        for sub_type in location.keys():\n            if card[\"sub_type\"] == sub_type:  # matches card[\"sub_type] to list\n                occupied = isinstance(self.armor[sub_type], dict)\n                if not occupied:\n                    x = self.sack.pop(self.sack.index(card))  # removes cards from sack list\n                    self.armor[sub_type] = x  # adds to player's attribs\n                    break\n                elif occupied:\n                    card_removed = self.armor.pop(sub_type)  # removing card from player's attrib\n                    self.sack.append(card_removed)\n                    x = self.sack.pop(self.sack.index(card))  # removes cards from sack list\n                    self.armor[sub_type] = x  # binds now card to player attribute\n                    break\n        gameVar.GameObjects.message = f\"Equipping {card['name']}\"\n        self.sum_of_bonuses()\n\n    def equip_weapon(self, card):\n        \"\"\"New simplified model. Checks L/R hands to see if full, equipping if not.\n        Two hand items will not work when other hands full. \"\"\"\n        if self.weapon_count > 0:\n            if card[\"sub_type\"] == \"1hand\" and not isinstance(self.weapons[\"L_hand\"], dict): # if 1handed weap and no card in players left hand...\n                added_card = self.sack.pop(self.sack.index(card)) # gets list index for pop by calling index() on object thus returning index\n                self.weapons[\"L_hand\"] = added_card\n                self.weapon_count -= card.get(\"hold_weight\")\n                gameVar.GameObjects.message = f\"Equipping {card['name']} to left hand\"\n            elif card[\"sub_type\"] == \"1hand\" and not isinstance(self.weapons[\"R_hand\"], dict): # not equipped\n                gameVar.GameObjects.message = f\"Equipping {card['name']} to right hand\"\n                added_card = self.sack.pop(self.sack.index(card))\n                self.weapons[\"R_hand\"] = added_card\n                self.weapon_count -= card.get(\"hold_weight\")\n            elif card[\"sub_type\"] == \"2hand\" and not isinstance(self.weapons[\"two_hand\"], dict):\n                if isinstance(self.weapons[\"L_hand\"], dict) or isinstance(self.weapons[\"R_hand\"], dict):\n                    gameVar.GameObjects.message = \"You can not equip this item while you have items in your other hands\"\n                elif not isinstance(self.weapons[\"L_hand\"], dict) and not isinstance(self.weapons[\"R_hand\"], dict):\n                    gameVar.GameObjects.message = f\"Equipping {card['name']} to both hands\"\n                    added_card = self.sack.pop(self.sack.index(card))\n                    self.weapons[\"two_hand\"] = added_card\n                    self.weapon_count -= card.get(\"hold_weight\")\n            else: # cheat card section/ big item\n                pass\n        else:\n            gameVar.GameObjects.message = \"You are at max capacity. Remove some weapons to attach others!\"\n        print(\"capacity count\", self.weapon_count)\n        self.sum_of_bonuses()\n\n    def card_meths(self, card, calltype=None, action=None): # calltype = method or static, action on or off,\n        \"\"\"link to card methods for active effect on player action =add, conditions or remove\"\"\"\n        print(f\"In player card_meth. Calltype: {calltype}, Action: {action}\") # info on meth used and status\n        \"\"\"will use add/remove suited to door cards, loose cases and curse canceling\"\"\"\n        for key, val in MonTools.method_types.items(): # look up methods associated to all cards in doorcards.py\n            if key == card.get(calltype): # key = \"loose_footgear\", if the key matches the value of the cards ie method: \"loose_footgear\" method is to be called\n                print(f\"the key is {key}\")\n                val(self, action) # action is on or off\n\n\n\"\"\"\ncard meth to handle curse, monsters ect. must handle both a static action and methods associated to add and remove.\ncalls required from; player select card, door kick for static ie no run, and loose scenario  \n\n\n\"\"\"\n\n\np1 = Player(1) #passes reference (ref)\np2 = Player(2)\np3 = Player(3)\np4 = Player(4)\np5 = Player(5)\np6 = Player(6)\np7 = Player(7)\np8 = Player(8)\np9 = Player(9)\np10 = Player(10)\n# p1.get_treasure()\n\n\n\nif __name__ == '__main__':\n    p1 = Player(1)\n    print(p1)\n    # p1.get_treasure() # duplicate val is print state from Handler class method (note is same: GOOD)\n    # p1.char_setup() # calls player name/gender setup, to be called after player number select\n    # p1.inventory() # shows inventory of new built char\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/players/playermodel.py b/Munchkin/bin/players/playermodel.py
--- a/Munchkin/bin/players/playermodel.py	(revision df7008cb24f4d02549b37b4a5e8f0fb166521d60)
+++ b/Munchkin/bin/players/playermodel.py	(date 1650359625497)
@@ -19,7 +19,7 @@
 from Munchkin.bin.all_cards.treasure_cards.treasurecards import Treasure
 
 from Munchkin.bin.players.playersetup import P_tools # OF LITTLE USE. Methods name/gender moved to this script.
-import bin.GUI.gui_variables as gameVar
+import bin.GUI.variables_library as gameVar
 from bin.all_cards.table import cards
 from bin.all_cards.door_cards.doorcards import MonTools
 from bin.all_cards.treasure_cards.treasurecards import T_tools
Index: Munchkin/old/gui_v3.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\" New format gui\nimports all scripts\n\nMain tasks:\n    create main start/exit window\n    create player select toplevel\n    create player name/sex entery toplevel\n    create main toplevel window with 3 main frames(nav, player info, action window)\n\n\nsub tasks:\n    save/load capability\n\n\n\"\"\"\n\nimport tkinter as tk\nimport tkinter.ttk as ttk\nimport bin.engine.game_loop_v3 as engine\nimport bin.engine.cut_scenes as cs\nimport bin.GUI.gui_variables as gameVar\nfrom PIL import Image, ImageTk\n# import bin.players.playermodel as contestant\n\n\n\nclass Main(tk.Tk):\n    def __init__(self, *args, **kwargs):\n        tk.Tk.__init__(self, *args, **kwargs)\n        self.geometry(\"300x200\")\n        self.title(\"Munchkin Dungeon\")\n        # self.iconbitmap('')\n\n\n        ## for background image on main start win\n        # self.canvas = tk.Canvas(self, width=300, height=400)\n        # self.canvas.pack()\n        # self.img = ImageTk.PhotoImage(Image.open().resize((WIDTH, HEIGTH), Image.ANTIALIAS))\n        # self.canvas.background = self.img  # Keep a reference in case this code is put in a function.\n        # self.bg = self.canvas.create_image(0, 0, anchor=tk.NW, image=self.img)\n        # button_window = self.canvas.create_window(10, 10, anchor=tk.NW, window=self.start)\n        # label_window = self.canvas.create_window(10, 10, anchor=tk.NW, window=self.self.welcome)\n\n        self.welcome = tk.Label(self, text=f\"{cs.start()}\").pack()\n\n        self.start = tk.Button(self, text=\"Start\", command=self.launch).pack()\n\n        # game variables .to be called by export\n        self.NumOfPlayers = tk.IntVar()\n        self.player_name = tk.StringVar()\n        self.player_gender = tk.StringVar()\n\n    def setplayers(self):\n        print(f'player from setplayers: {self.NumOfPlayers.get()}')\n        engine.gui_num_of_players = self.NumOfPlayers.get() # sets the num of players in engine script\n        gameVar.StartVariables.new_players = self.NumOfPlayers.get() # sets in gui_variables\n        engine.PlayerSetUp() # calls class in engine scrip setting up all class attribs  #####################\n        self.player_setup()\n\n    def launch(self):\n        self.player_select = tk.Toplevel(self)\n        # player_select.attributes('-fullscreen', True) # makes full screen\n        self.player_select.geometry(\"600x600\")\n        self.player_select.title(\"Player Select\")\n\n        tk.Label(self.player_select, text=\"Please select number of players\").pack()\n        l1 = ttk.Spinbox(self.player_select, from_=1, to=10, increment=1, textvariable=self.NumOfPlayers)\n        l1.focus()\n        l1.set(1)\n        l1.pack()\n        tk.Button(self.player_select, text='Confirm', command=self.setplayers).pack()  ##### move val\n\n\n    def player_setup(self):\n        advance = True\n        self.player_select.destroy() # destroys old toplevel window\n        self.player_set = tk.Toplevel(self)\n        # player_set.attributes('-fullscreen', True) # makes full screen\n        self.player_set.focus_set() # focuses on window\n        # player_set.attributes('-fullscreen', True) # makes full screen\n        self.player_set.geometry(\"600x600\")\n        self.player_set.title(\"Player Info\")\n\n        def advancing():\n            print('binding info to player')\n\n\n        # for player in range(self.NumOfPlayers.get()):\n        #     \"\"\"need mechanism for waiting for individual person data. current not working\"\"\"\n        #     ttk.Label(self.player_set, text='What is your name?').pack()\n        #     ttk.Entry(self.player_set, textvariable=self.player_name).pack()\n        #     ttk.Label(self.player_set, text='What is your gender?').pack()\n        #     ttk.Combobox(self.player_set, textvariable=self.player_gender, values=[\"Male\", \"Female\"]).pack()\n        #     tk.Button(self.player_set, text=\"Next\", command=advancing).pack()\n        #     # need to pause before moving on\n        #     tk.Label(self.player_set, text=\"Press Return for next player\").pack()\n        #     # transfer of the Vars is required to specific player\n        print(self.player_name.get(), self.player_gender.get())\n\n# app = Main() # having this will run the script twice. in any other script it will cause them to trigger when imported!!\n\n\n\nif __name__ == '__main__':\n    app = Main()\n    app.mainloop()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/old/gui_v3.py b/Munchkin/old/gui_v3.py
--- a/Munchkin/old/gui_v3.py	(revision df7008cb24f4d02549b37b4a5e8f0fb166521d60)
+++ b/Munchkin/old/gui_v3.py	(date 1650359625505)
@@ -16,9 +16,9 @@
 
 import tkinter as tk
 import tkinter.ttk as ttk
-import bin.engine.game_loop_v3 as engine
+import bin.engine.controller as engine
 import bin.engine.cut_scenes as cs
-import bin.GUI.gui_variables as gameVar
+import bin.GUI.variables_library as gameVar
 from PIL import Image, ImageTk
 # import bin.players.playermodel as contestant
 
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"e89d33e8-f65b-4c0f-9d3f-1de9856c0ba0\" name=\"Changes\" comment=\"docs\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Python Script\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"ProjectId\" id=\"228V1szxqWwIqe83W3F9S3jTuGo\" />\n  <component name=\"ProjectLevelVcsManager\">\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\n  </component>\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">\n    <property name=\"ASKED_ADD_EXTERNAL_FILES\" value=\"true\" />\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$/../Learning_files\" />\n  </component>\n  <component name=\"RunManager\" selected=\"Python.game_loop_v3\">\n    <configuration name=\"controller\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/bin/GUI/controller.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"doorcards\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards/doorcards.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"funct_trial\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/funct_trial.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"game_loop_v3\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/bin/engine\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/bin/engine/game_loop_v3.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"general_tests\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"MyPackages\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Munchkin/Tests\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Munchkin/Tests/general_tests.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"Python.game_loop_v3\" />\n        <item itemvalue=\"Python.doorcards\" />\n        <item itemvalue=\"Python.controller\" />\n        <item itemvalue=\"Python.general_tests\" />\n        <item itemvalue=\"Python.funct_trial\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"e89d33e8-f65b-4c0f-9d3f-1de9856c0ba0\" name=\"Changes\" comment=\"\" />\n      <created>1639218994311</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1639218994311</updated>\n      <workItem from=\"1639218997657\" duration=\"35269000\" />\n      <workItem from=\"1639735508330\" duration=\"18975000\" />\n      <workItem from=\"1640013914970\" duration=\"13331000\" />\n      <workItem from=\"1640513559951\" duration=\"433000\" />\n      <workItem from=\"1640952454199\" duration=\"648000\" />\n      <workItem from=\"1649103067776\" duration=\"360000\" />\n      <workItem from=\"1649237457571\" duration=\"2195000\" />\n      <workItem from=\"1649273824130\" duration=\"6676000\" />\n      <workItem from=\"1649938477233\" duration=\"1987000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"update to card date structure\">\n      <created>1639844962852</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1639844962852</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"changes image recall file structure to handle different os with pathlib module\">\n      <created>1649255260546</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1649255260546</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"changes image recall file structure to handle different os with pathlib module\">\n      <created>1649273835279</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1649273835279</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"docs\">\n      <created>1649280322103</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1649280322103</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"docs\">\n      <created>1649619777519</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1649619777519</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"6\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <option name=\"ADD_EXTERNAL_FILES_SILENTLY\" value=\"true\" />\n    <MESSAGE value=\"update to card date structure\" />\n    <MESSAGE value=\"changes image recall file structure to handle different os with pathlib module\" />\n    <MESSAGE value=\"docs\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"docs\" />\n  </component>\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\n    <SUITE FILE_PATH=\"coverage/Munch$game_loop_v3.coverage\" NAME=\"game_loop_v3 Coverage Results\" MODIFIED=\"1649605889035\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/engine\" />\n    <SUITE FILE_PATH=\"coverage/Munch$controller.coverage\" NAME=\"controller Coverage Results\" MODIFIED=\"1649254694799\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\n    <SUITE FILE_PATH=\"coverage/MyPackages$doorcards.coverage\" NAME=\"doorcards Coverage Results\" MODIFIED=\"1639811290752\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards\" />\n    <SUITE FILE_PATH=\"coverage/Munch$general_tests.coverage\" NAME=\"general_tests Coverage Results\" MODIFIED=\"1649253557839\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/Tests\" />\n    <SUITE FILE_PATH=\"coverage/Munch$doorcards.coverage\" NAME=\"doorcards Coverage Results\" MODIFIED=\"1649279228321\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards\" />\n    <SUITE FILE_PATH=\"coverage/MyPackages$funct_trial.coverage\" NAME=\"funct_trial Coverage Results\" MODIFIED=\"1640266776710\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\n    <SUITE FILE_PATH=\"coverage/MyPackages$controller.coverage\" NAME=\"controller Coverage Results\" MODIFIED=\"1640513926303\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Munchkin/bin/GUI\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision df7008cb24f4d02549b37b4a5e8f0fb166521d60)
+++ b/.idea/workspace.xml	(date 1650360408359)
@@ -3,6 +3,13 @@
   <component name="ChangeListManager">
     <list default="true" id="e89d33e8-f65b-4c0f-9d3f-1de9856c0ba0" name="Changes" comment="docs">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Munchkin/bin/GUI/controller.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/GUI/view.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Munchkin/bin/GUI/gui_variables.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/GUI/variables_library.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Munchkin/bin/engine/game_loop_v3.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/engine/controller.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Munchkin/bin/players/playermodel.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/players/playermodel.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Munchkin/bin/players/playersetup.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/bin/players/playersetup.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Munchkin/old/gui_v3.py" beforeDir="false" afterPath="$PROJECT_DIR$/Munchkin/old/gui_v3.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/run.py" beforeDir="false" afterPath="$PROJECT_DIR$/run.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -34,7 +41,7 @@
     <property name="WebServerToolWindowFactoryState" value="false" />
     <property name="last_opened_file_path" value="$PROJECT_DIR$/../Learning_files" />
   </component>
-  <component name="RunManager" selected="Python.game_loop_v3">
+  <component name="RunManager" selected="Python.view">
     <configuration name="controller" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="MyPackages" />
       <option name="INTERPRETER_OPTIONS" value="" />
@@ -43,12 +50,12 @@
         <env name="PYTHONUNBUFFERED" value="1" />
       </envs>
       <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/Munchkin/bin/GUI" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/Munchkin/bin/engine" />
       <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
       <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
-      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Munchkin/bin/GUI/controller.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Munchkin/bin/engine/controller.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
@@ -101,7 +108,7 @@
       <option name="INPUT_FILE" value="" />
       <method v="2" />
     </configuration>
-    <configuration name="game_loop_v3" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+    <configuration name="general_tests" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="MyPackages" />
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
@@ -109,12 +116,12 @@
         <env name="PYTHONUNBUFFERED" value="1" />
       </envs>
       <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/Munchkin/bin/engine" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/Munchkin/Tests" />
       <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
       <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
-      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Munchkin/bin/engine/game_loop_v3.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Munchkin/Tests/general_tests.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
@@ -123,7 +130,7 @@
       <option name="INPUT_FILE" value="" />
       <method v="2" />
     </configuration>
-    <configuration name="general_tests" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+    <configuration name="view" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="MyPackages" />
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
@@ -131,12 +138,12 @@
         <env name="PYTHONUNBUFFERED" value="1" />
       </envs>
       <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/Munchkin/Tests" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/Munchkin/bin/GUI" />
       <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
       <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
-      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Munchkin/Tests/general_tests.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Munchkin/bin/GUI/view.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
@@ -147,9 +154,9 @@
     </configuration>
     <recent_temporary>
       <list>
-        <item itemvalue="Python.game_loop_v3" />
+        <item itemvalue="Python.view" />
+        <item itemvalue="Python.controller" />
         <item itemvalue="Python.doorcards" />
-        <item itemvalue="Python.controller" />
         <item itemvalue="Python.general_tests" />
         <item itemvalue="Python.funct_trial" />
       </list>
@@ -171,7 +178,9 @@
       <workItem from="1649103067776" duration="360000" />
       <workItem from="1649237457571" duration="2195000" />
       <workItem from="1649273824130" duration="6676000" />
-      <workItem from="1649938477233" duration="1987000" />
+      <workItem from="1649938477233" duration="3460000" />
+      <workItem from="1650186432790" duration="86000" />
+      <workItem from="1650358872825" duration="1535000" />
     </task>
     <task id="LOCAL-00001" summary="update to card date structure">
       <created>1639844962852</created>
@@ -208,7 +217,14 @@
       <option name="project" value="LOCAL" />
       <updated>1649619777519</updated>
     </task>
-    <option name="localTasksCounter" value="6" />
+    <task id="LOCAL-00006" summary="docs">
+      <created>1649968434840</created>
+      <option name="number" value="00006" />
+      <option name="presentableId" value="LOCAL-00006" />
+      <option name="project" value="LOCAL" />
+      <updated>1649968434840</updated>
+    </task>
+    <option name="localTasksCounter" value="7" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -239,6 +255,7 @@
     <SUITE FILE_PATH="coverage/MyPackages$doorcards.coverage" NAME="doorcards Coverage Results" MODIFIED="1639811290752" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards" />
     <SUITE FILE_PATH="coverage/Munch$general_tests.coverage" NAME="general_tests Coverage Results" MODIFIED="1649253557839" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/Tests" />
     <SUITE FILE_PATH="coverage/Munch$doorcards.coverage" NAME="doorcards Coverage Results" MODIFIED="1649279228321" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/bin/all_cards/door_cards" />
+    <SUITE FILE_PATH="coverage/Munch$view.coverage" NAME="view Coverage Results" MODIFIED="1650359859106" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/bin/GUI" />
     <SUITE FILE_PATH="coverage/MyPackages$funct_trial.coverage" NAME="funct_trial Coverage Results" MODIFIED="1640266776710" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/MyPackages$controller.coverage" NAME="controller Coverage Results" MODIFIED="1640513926303" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Munchkin/bin/GUI" />
   </component>
Index: run.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\" calling this will trigger the game to start\"\"\"\n\n\nfrom Munchkin.bin.GUI.controller import Main\n\n\napp = Main()\napp.mainloop()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/run.py b/run.py
--- a/run.py	(revision df7008cb24f4d02549b37b4a5e8f0fb166521d60)
+++ b/run.py	(date 1650358959203)
@@ -1,7 +1,7 @@
 """ calling this will trigger the game to start"""
 
 
-from Munchkin.bin.GUI.controller import Main
+from Munchkin.bin.GUI.view import Main
 
 
 app = Main()
