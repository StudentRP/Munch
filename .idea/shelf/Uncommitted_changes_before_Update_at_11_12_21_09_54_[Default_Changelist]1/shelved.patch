Index: Munchkin/old/game_loop_v2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"Initiates player personalisation and runs game cycle for each player fetching cards and initiation\r\neach scene of play\r\n\r\nConsiderations;\r\n    sets num of players                                         = = DONE\r\n    triggers player setup                                       = = DONE\r\n    triggers character play order                               = = DONE\r\n    starts game loop                                            = = DONE\r\n    triggers card calls                                         = = WORKING PROGRESS\r\n    correlation of player vs cards                              = = move to game logic\r\n    player intervention mechanics                               = = move to game logic\r\n    exports treasure/curse objects to player self               = = move to game logic\r\n\r\n\r\n\"\"\"\r\n\r\n\r\nfrom Munchkin.bin.players.playermodel import p1, p2, p3, p4, p5, p6, p7, p8, p9, p10\r\nfrom Munchkin.bin.engine.game_logic import start_choice\r\nfrom Munchkin.bin.all_cards.table import Dealer\r\nfrom Munchkin.bin.engine import cut_scenes as cs\r\nfrom random import randint\r\nfrom time import sleep\r\n\r\n\r\n##################################################################\r\n# main loop\r\n##################################################################\r\n\r\n\"\"\" V2.0  \"\"\"\r\n\r\n\r\nclass NumberOfPlayers:\r\n    \"\"\"class to determine number of players and hand to player order\"\"\"\r\n\r\n    def __init__(self):\r\n        self.players_available = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10]\r\n        self.new_players = []\r\n        self.cycle = 0\r\n\r\n    def player_order(self, instance):\r\n        \"\"\"Main game loop, triggers events and cycles players from a list\"\"\"\r\n        index = 0\r\n        play = True\r\n\r\n        while self.cycle <= 4: # test scenario, to be removed (replace with play for game exit)\r\n            try:\r\n                \"main game loop\"\r\n                if instance == self.new_players[index] and instance.alive: #checks instance against index if player alive\r\n                    \"Main pathway logic\"\r\n                    print(f\"{instance.name} Turn.\")\r\n                    # ..................... code calls for loop...............................\r\n                    start_choice(instance, self.new_players) # triggers Kick Door and Inventory (1st step), passes on self and list of instances\r\n\r\n\r\n                    # .sack vol check/charity\r\n                    # ... end game loop\r\n                    index += 1\r\n                    instance = self.new_players[index]  # changes player, if index error does not execute below\r\n                    continue\r\n                elif instance != self.new_players[index]:\r\n                    \"Logic to increment index in search for player\"\r\n                    print(f\"Seeking index for {instance.name, instance.ref}\")\r\n                    index += 1\r\n                    continue\r\n                elif instance == self.new_players[index] and not instance.alive:\r\n                    \"Logic for player skip turn\"\r\n                    print(f\"You are dead {instance.name}, your items have been looted!\")\r\n                    instance.alive = True\r\n                    index += 1\r\n                    instance = self.new_players[index] # changes player\r\n                    continue\r\n                else:\r\n                    \"Catch eventuality\"\r\n                    print('ERROR: Something has gone seriously wrong!')\r\n                    break\r\n            except IndexError:\r\n                \"Looping logic\"\r\n                index = 0\r\n                instance = self.new_players[index]  # changes player\r\n                print(f\"Resetting index {index}, next player is: {instance.name}\")\r\n                print(\"\\n######################## Cycle number:\", self.cycle, \"########################\")\r\n                self.cycle += 1 # test scenario, to be removed\r\n                continue\r\n\r\n    def select_players(self):\r\n        \"\"\"Setup for instances, names/gender and first deal\"\"\"\r\n        print(cs.start())\r\n        try:\r\n            playersselect = int(input(\"Please select number of players 1 - 10.\\n>>> \")) # throws error with str, need catch\r\n            if playersselect < 1 or playersselect > 10: # out of num of player parameters\r\n                print(cs.invalid())\r\n                self.select_players() # restarts loop\r\n            elif playersselect:\r\n                self.new_players = self.players_available[:playersselect]\r\n                for player in self.new_players:\r\n                    player.char_setup() # sets up players before game\r\n                    print(\"\\nGetting cards from dealer\\n\")\r\n                    player.sack = Dealer.deal_cards(player, \"start\") # add stating cards to player sack\r\n                print(\"Dice rolled to see who goes first!\\n\")\r\n                randomise = randint(0, len(self.new_players) - 1) # index correction\r\n                gofirst = self.new_players[randomise] #gets instance at position[x]\r\n                # print(self.new_players) # check to see if passing object and rand number\r\n                self.player_order(gofirst) #passes instance to player_order()\r\n        except ValueError:\r\n            print(\"Out of cards!\")\r\n            self.select_players()\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    NumberOfPlayers().select_players() # starts game\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/old/game_loop_v2.py b/Munchkin/old/game_loop_v2.py
--- a/Munchkin/old/game_loop_v2.py	
+++ b/Munchkin/old/game_loop_v2.py	
@@ -16,12 +16,10 @@
 
 
 from Munchkin.bin.players.playermodel import p1, p2, p3, p4, p5, p6, p7, p8, p9, p10
-from Munchkin.bin.engine.game_logic import start_choice
+from old.game_logic import start_choice
 from Munchkin.bin.all_cards.table import Dealer
 from Munchkin.bin.engine import cut_scenes as cs
 from random import randint
-from time import sleep
-
 
 ##################################################################
 # main loop
Index: Munchkin/old/gameCycle.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"Initiates player personalisation and runs game cycle for each player fetching cards and initiation\r\neach scene of play\r\n\r\nConsiderations;\r\n    sets num of players\r\n    triggers player setup\r\n    triggers character play order\r\n    starts game loop\r\n    triggers card calls\r\n    correlation of player vs cards\r\n    player intervention mechanics\r\n    exports treasure/curse objects to player self\r\n\r\n\r\n\"\"\"\r\n\r\n\r\nfrom Munchkin.bin.players.playermodel import p1, p2, p3, p4, p5, p6, p7, p8, p9, p10\r\nfrom Munchkin.bin.engine.game_logic import start_choice, deal_cards\r\nfrom Munchkin.bin.engine import cut_scenes as cs\r\nfrom random import randint\r\nfrom time import sleep\r\n\r\n\r\n##################################################################\r\n# main loop\r\n##################################################################\r\n\r\n\"\"\"prob build this as class passing instance as first arg\"\"\"\r\n\r\n\r\ndef game_cycle(start, num): # gCycle(instance, str(num_of_players))\r\n    \"\"\"game cycle very verbose. accepts args instance and num of players converting to int. Each instance has an if\r\n    statement. each if statement calls startChoice function that garbs door card    \"\"\"\r\n    num = int(num)\r\n    if start == p1 and start.alive or num <=1: # health represents dead/alive player\r\n        print(\"Player 1 mode\")\r\n        #startChoice(start) # kick door and inventory\r\n        deal_cards(start)# ...................................................Left off need to stop dupes remove from pack\r\n        start_choice(start) # kick door and inventory\r\n        # cycle options\r\n        if num ==\"01\": # check kick, check inventory\r\n            game_cycle(start, -1) # will cycle cards when kicking\r\n        start = p2\r\n        game_cycle(start, num)\r\n    elif start == p2 and start.alive: # health represents dead/alive player\r\n        print(\"Player 2 mode\")\r\n        start_choice(start)\r\n        if int(num) == 2:\r\n            start = p1\r\n            game_cycle(start, num)\r\n        else:\r\n            start = p3\r\n            game_cycle(start, num)\r\n    elif start == p3 and start.alive: # health represents dead/alive player\r\n        print(\"Player 3 mode\")\r\n        start.inventory()\r\n        if int(num) == 3:\r\n            start = p1\r\n            game_cycle(start, num)\r\n        else:\r\n            start = p4\r\n            game_cycle(start, num)\r\n    elif start == p4 and start.alive: # health represents dead/alive player\r\n        print(\"Player 4 mode\")\r\n        start.inventory()\r\n        if int(num) == 4:\r\n            start = p1\r\n            game_cycle(start, num)\r\n        else:\r\n            print(\"Fatal error\")\r\n\r\n###########################################################################\r\n# users to instances\r\n###########################################################################\r\n\r\n\r\ndef users():\r\n    \"\"\"assigns instances to players and links to gCycle(instance, numOfPlayers) All very verbose\"\"\"\r\n    num = str(input(\"Please select number of players \\n>>> \"))\r\n    if num == '1':\r\n        print(\"Not enough players. Please select number between 2-4\")\r\n        sleep(2.0)\r\n        users()\r\n    elif num == '2': # player 2 setup\r\n        p1.char_setup() # runs class method associated to p1 = Player()\r\n        p2.char_setup()\r\n        print(\"\\nA Player will be selected at random to go first!\\n\")\r\n        x = randint(1, 2) # random select of which player goes first\r\n        if x == 1:\r\n            return game_cycle(p1, num)\r\n        else:\r\n            return game_cycle(p2, num)\r\n    elif num == '3': # set up for 3 players\r\n        p1.char_setup()\r\n        p2.char_setup()\r\n        p3.char_setup()\r\n        print(\"\\nA Player will be selected at random to go first!\\n\")\r\n        x = randint(1, 3)\r\n        if x == 1:\r\n            return game_cycle(p1, num)\r\n        elif x == 2:\r\n            return game_cycle(p2, num)\r\n        else:\r\n            return game_cycle(p3, num)\r\n    elif num == '4': # setup for 4 players\r\n        p1.char_setup()\r\n        p2.char_setup()\r\n        p3.char_setup()\r\n        p4.char_setup()\r\n        print(\"\\nA Player will be selected at random to go first!\\n\")\r\n        x = randint(1, 4)\r\n        if x == 1:\r\n            return game_cycle(p1, num)\r\n        elif x == 2:\r\n            return game_cycle(p2, num)\r\n        elif x == 3:\r\n            return game_cycle(p3, num)\r\n        else:\r\n            return game_cycle(p4, num)\r\n    elif num == \"01\": # ............................................................................. dev mode\r\n        print(\"Entering Developer mode\")\r\n        p1.char_setup()\r\n        return game_cycle(p1, num)\r\n        #assign 4 cards from each set\r\n    else:\r\n        print(\"Please enter valid number between 2-4.\")\r\n        users()\r\n\r\n\r\n\r\n###################################################################################################\r\n\r\n\"\"\" V2  \"\"\"\r\n\r\nclass NumberOfPlayers:\r\n    \"\"\"class to determine number of players and hand to player order\"\"\"\r\n\r\n    def __init__(self):\r\n        self.players_available = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10]\r\n        self.new_players = []\r\n        self.cycle = 0\r\n\r\n\r\n    def player_order(self, instance):\r\n        \"\"\"cycles player order and triggers next event\"\"\"\r\n        index = 0\r\n        play = True\r\n\r\n        while self.cycle <= 4: #test scenario, to be removed (replace with play for game exit)\r\n            try:\r\n                if instance == self.new_players[index] and instance.alive:\r\n                    print(f\"p{instance.ref} in game loop.\")\r\n                    print('index before;', index)\r\n                    #... code calls for loop\r\n                    if self.cycle == 0:\r\n                        instance.char_setup()\r\n\r\n                    index += 1\r\n                    instance = self.new_players[index]  # changes player, if index error does not execute below\r\n                    print('index after;', index, 'instance after change: p', instance.ref)\r\n                    continue\r\n                elif instance != self.new_players[index]:\r\n                    print('index;', index)\r\n                    print(f\"Wrong index for p{instance.ref}\")\r\n                    index += 1\r\n                    continue\r\n                elif instance == self.new_players[index] and not instance.alive:\r\n                    print(f\"you are dead p{instance.ref}, your items have been looted!\")\r\n                    # method for new cards\r\n                    instance.alive = True\r\n                    index += 1\r\n                    instance = self.new_players[index] # changes player\r\n                    continue\r\n                else:\r\n                    print('error')\r\n                    break\r\n            except IndexError:\r\n                index = 0\r\n                instance = self.new_players[index]  # changes player\r\n                print(f\"resetting index {index}, and starting player : p{instance.ref}\")\r\n                print(\"\\n######################## Cycle number:\", self.cycle, \"########################\")\r\n                self.cycle += 1 #test scenario, to be removed\r\n                continue\r\n\r\n\r\n\r\n\r\n\r\n\r\n    def select_players(self):\r\n        x = int(input(\"Please select number of players 1 - 10.\\n>>> \"))\r\n        if x < 1 or x > 10:\r\n            cs.invalid()\r\n            self.select_players()\r\n        elif x:\r\n            self.new_players = self.players_available[:x]\r\n            randomise = randint(0, len(self.new_players) - 1) # index correction\r\n            gofirst = self.new_players[randomise]\r\n            # print(self.new_players) # check to see if passing object and rand number\r\n            self.player_order(gofirst)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # print(cs.start())\r\n    # users()\r\n    NumberOfPlayers().select_players() # starts game\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/old/gameCycle.py b/Munchkin/old/gameCycle.py
--- a/Munchkin/old/gameCycle.py	
+++ b/Munchkin/old/gameCycle.py	
@@ -16,7 +16,7 @@
 
 
 from Munchkin.bin.players.playermodel import p1, p2, p3, p4, p5, p6, p7, p8, p9, p10
-from Munchkin.bin.engine.game_logic import start_choice, deal_cards
+from old.game_logic import start_choice, deal_cards
 from Munchkin.bin.engine import cut_scenes as cs
 from random import randint
 from time import sleep
Index: Munchkin/old/game_loop_v2.1.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"Initiates player personalisation and runs game cycle for each player fetching cards and initiation\r\neach scene of play\r\n\r\nConsiderations;\r\n    sets num of players                                         = = DONE\r\n    triggers player setup                                       = = DONE\r\n    triggers character play order                               = = DONE\r\n    starts game loop                                            = = DONE\r\n    triggers card calls                                         = = WORKING PROGRESS\r\n    correlation of player vs cards                              = = move to game logic\r\n    player intervention mechanics                               = = move to game logic\r\n    exports treasure/curse objects to player self               = = move to game logic\r\n    start GUI loop here and import from gui the inherited bits  = = to do\r\n\"\"\"\r\n\r\n\r\nfrom Munchkin.bin.players.playermodel import p1, p2, p3, p4, p5, p6, p7, p8, p9, p10\r\nfrom Munchkin.bin.engine.game_logic import start_choice as game_logic_start_choice\r\nfrom Munchkin.bin.all_cards.table import Dealer\r\nfrom Munchkin.bin.engine import cut_scenes as cs\r\nfrom random import randint\r\n# from Munchkin.bin.GUI.gui_v2 import TestWin, PlayerInfo, Main\r\n# from Munchkin.bin.GUI.gui_interface import Root\r\nfrom time import sleep\r\n# from Munchkin.bin.GUI.gui_v3 import app as gui_main # app.mainloop() will trigger gui\r\n\r\n\r\n##################################################################\r\n# main loop\r\n##################################################################\r\n\r\n\"\"\" V2.0  \"\"\"\r\n##globals for gui\r\n\r\ngui_num_of_players = 1 # changed by the gui\r\n\r\n\r\n\r\nclass NumberOfPlayers:\r\n    \"\"\"class to determine number of players and hand to player order\"\"\"\r\n\r\n    def __init__(self):\r\n        self.players_available = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10] # instances from Player class\r\n        self.new_players = []\r\n        self.cycle = 0\r\n        self.setup = self.select_players()\r\n\r\n    def player_order(self, instance):\r\n        \"\"\"Main game loop, triggers events and cycles players from a list\"\"\"\r\n        index = 0\r\n        play = True # for ending game thus loop\r\n\r\n        while self.cycle <= 4: #TODO test scenario 4 turn loops, to be edited (replace with play for game exit)\r\n            try:\r\n                \"main game loop\"\r\n                if instance == self.new_players[index] and instance.alive: # checks instance(x) against returned index in list\r\n                    # and if player alive (skips turn if not)\r\n                    \"Main pathway logic\"\r\n                    # instance.name = gui_main.player_name\r\n\r\n\r\n                    print(f\"{instance.name} Turn.\")\r\n                    # ..................... code calls for loop...............................\r\n                    game_logic_start_choice(instance, self.new_players) # triggers Kick Door and Inventory (1st step)\r\n\r\n\r\n                    # .sack vol check/charity\r\n                    # ... end game loop\r\n                    index += 1\r\n                    instance = self.new_players[index]  # changes player, if index error does not execute below\r\n                    continue\r\n                elif instance != self.new_players[index]:\r\n                    \"Logic to increment index in search for player, can strip allot of this put on finish\"\r\n                    print(f\"Seeking index for {instance.name, instance.ref}\")\r\n                    index += 1\r\n                    continue\r\n                elif instance == self.new_players[index] and not instance.alive:\r\n                    \"Logic for player skip turn\"\r\n                    print(f\"You are dead {instance.name}, your items have been looted!\")\r\n                    instance.alive = True\r\n                    index += 1\r\n                    instance = self.new_players[index] # changes player\r\n                    continue\r\n                else:\r\n                    \"Catch eventuality\"\r\n                    print('ERROR: Something has gone seriously wrong!')\r\n                    break\r\n            except IndexError:\r\n                \"Looping logic\"\r\n                index = 0\r\n                instance = self.new_players[index]  # changes player\r\n                print(f\"Resetting index {index}, next player is: {instance.name}\")\r\n                print(\"\\n######################## Cycle number:\", self.cycle, \"########################\")\r\n                self.cycle += 1 # test scenario, to be removed\r\n                continue\r\n\r\n    def select_players(self): # gui must call this passing the player num as a param\r\n        \"\"\"Setup for instances, names/gender and first deal. slices player instance list with new player list,\r\n         for each player set them up with cards, rand player to go first and sends to player_order function\"\"\"\r\n        # print(cs.start()) #' cut scene start message\r\n        print(gui_num_of_players) # global var changes by GUI script\r\n        #try:\r\n        maxplayers = gui_num_of_players\r\n        # if maxplayers < 1 or maxplayers > 10: # input limit checker # not required for gui as spinbox limits this\r\n        #     print(cs.invalid()) # message defining error\r\n        #     self.select_players() # restarts method loop\r\n        print(f\"number of players selected: {int(gui_num_of_players)}\") ### GUI test for number acceptance#######\r\n        self.new_players = self.players_available[:maxplayers] # slices players_avail list creating new list\r\n        print(self.new_players[0].ref)\r\n\r\n    def player_name_gender(self):\r\n            ############ ok up to here with gui ##################\r\n            for player in self.new_players: # sets each instance up with sets of cards to start\r\n                player.char_setup() # calls meth from Player setting up char name/sex before game\r\n                print(\"\\nGetting cards from dealer\\n\")\r\n                player.sack = Dealer.deal_cards(player, \"start\") # adds starting cards to player sack in Player class\r\n            print(\"Dice rolled to see who goes first!\\n\")\r\n            randomise = randint(0, len(self.new_players) - 1) # index correction\r\n            gofirst = self.new_players[randomise] # gets instance at position[random]\r\n            # print(self.new_players) # check to see if passing object and rand number\r\n            self.player_order(gofirst) #passes instance to player_order() function\r\n        # except ValueError:\r\n        #     print(\"Out of cards!\") # crude catch stemming from the ue of random card deals #TODO find better way\r\n        #     self.select_players()\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    NumberOfPlayers().select_players() # starts game by activating NOP building the objects, and activating select_players\r\n    # running wach line.\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/old/game_loop_v2.1.py b/Munchkin/old/game_loop_v2.1.py
--- a/Munchkin/old/game_loop_v2.1.py	
+++ b/Munchkin/old/game_loop_v2.1.py	
@@ -15,13 +15,11 @@
 
 
 from Munchkin.bin.players.playermodel import p1, p2, p3, p4, p5, p6, p7, p8, p9, p10
-from Munchkin.bin.engine.game_logic import start_choice as game_logic_start_choice
+from old.game_logic import start_choice as game_logic_start_choice
 from Munchkin.bin.all_cards.table import Dealer
-from Munchkin.bin.engine import cut_scenes as cs
 from random import randint
 # from Munchkin.bin.GUI.gui_v2 import TestWin, PlayerInfo, Main
 # from Munchkin.bin.GUI.gui_interface import Root
-from time import sleep
 # from Munchkin.bin.GUI.gui_v3 import app as gui_main # app.mainloop() will trigger gui
 
 
Index: Munchkin/bin/all_cards/table.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\" This will define classes for the fetching of cards from treasurecards and monstercurse,\r\nobject attributes and returning a object/s that is used in play.\r\n\r\nConsiderations:\r\nBurn pile, object o get cards\r\n\r\n\r\n\"\"\"\r\n\r\nfrom Munchkin.bin.all_cards.treasure_cards.treasurecards import Treasure\r\nfrom Munchkin.bin.all_cards.door_cards.doorcards import Moncurse\r\n# import Munchkin.bin.GUI.gui_variables as gameVar# creates circle import\r\nfrom random import randint\r\n\r\n\r\nclass Dice:\r\n    \"\"\"simulates a dice roll\"\"\"\r\n    def roll(self, max=6): # max added for methods that change the likelihood of running from a fight\r\n        roll = int(randint(1, max))\r\n        return roll\r\n\r\n\r\nclass Dealer:\r\n\r\n    def deal_cards(self, option=None, cardnum=4): # option = set card type, cardnum=number of cards to deal set by game  options\r\n        \"\"\"Method for dealing cards to players at start or during play. params: option selects the type/situation of\r\n        dealing specific cards cardnum specific to the start/resurrect determines the amount of cards to of each type\r\n        to deal players\"\"\"\r\n\r\n        print(f\"In deal cards. Num of cards in: \\nDoor stack: {len(Moncurse.door_cards)}\\nTreasure stack: {len(Treasure.treasure_cards)}\\n\"\r\n              f\"Burn pile: {len(cards.burn_pile)}\\nIn-play stack: {len(cards.in_play)}\\n\") # dev print\r\n\r\n        # Checks\r\n        if cardnum > len(Moncurse.door_cards):\r\n            print(f\"Not enough Door cards\\nRESTOCKING WITH {[x['name'] for x in cards.burn_pile]}\")\r\n            cards.restock()\r\n            print(f\"cards left in burn pile after restock {cards.burn_pile}\") # test for change\r\n        if cardnum > len(Treasure.treasure_cards):\r\n            print(f\"Not enough Treasure cards\\nRESTOCKING WITH {[x['name'] for x in cards.burn_pile]}\")\r\n            cards.restock()\r\n\r\n        # Main actions\r\n        try :\r\n            if option == \"start\":\r\n                \"\"\"called at start to deal specific number of cards to pass to player\"\"\"\r\n                starter_set = []\r\n                for i in range(cardnum): # takes attrib of number of loops for card dealing (set by gameVar.Options)\r\n                    dobj = Moncurse.door_cards.pop(randint(0, len(Moncurse.door_cards) - 1))\r\n                    starter_set.append(dobj) # adds door card to list\r\n                    tobj = Treasure.treasure_cards.pop(randint(0, len(Treasure.treasure_cards) - 1)) # gets card. better rand required\r\n                    starter_set.append(tobj) # adds treasure card to list,\r\n                    # print(f\" num of cards in pack:{len(Moncurse.door_cards)}, rand gen tres:{tpack} door:{dpack}\") # should go down\r\n                return starter_set # returns starter_set list to caller (player.unsorted)\r\n\r\n            elif option == \"door\":\r\n                \"\"\"Deal Door cards\"\"\" # will need condition for kicking door (placed on table) 2nd draw (player hand)\r\n                print('Dealing from Door pile:')\r\n                card = Moncurse.door_cards.pop(randint(0, len(Moncurse.door_cards) - 1))\r\n                print(f\"Your card is: {card['name']}\\nCards left in Door deck: {len(Moncurse.door_cards)}\\n\")\r\n                return card\r\n\r\n            elif option == \"treasure\":\r\n                \"\"\"Deal Treasure cards\"\"\"\r\n                print('Dealing from treasure pile')\r\n                card_list = []\r\n                for _amount in range(cardnum): # supplies a number of treasure\r\n                    card = Treasure.treasure_cards.pop(randint(0, len(Treasure.treasure_cards) - 1))\r\n                    print(f\"Treasure cards is: {card['name']}\\nCards left in Door deck: {len(Treasure.treasure_cards)}\\n\")\r\n                    card_list.append(card)\r\n                return card_list\r\n            else:\r\n                print(\"CARD ERROR!!!!!\")\r\n        except ValueError:\r\n            print(\"DECK EMPTY! NO CARDS AVAILABLE!!!!\")\r\n\r\n\r\nclass Table(Treasure, Moncurse): # inherits from\r\n    \"\"\"This is the table model and the attributes expected from the game tablel\"\"\"\r\n    def __init__(self):\r\n        self.card_sop = Dealer() # has-a dealer\r\n        self.burn_pile = []\r\n        self.in_play = []\r\n        self.dice_sop = Dice()\r\n\r\n    def add_to_burn(self, discard):\r\n        \"\"\"adding to burn pile\"\"\"\r\n        self.burn_pile.append(discard)\r\n\r\n    def remove_from_burn(self, pull_request):\r\n        \"\"\"digging through burn pile \"\"\"\r\n        try:\r\n            return self.burn_pile[:-pull_request]\r\n\r\n        except IndexError:\r\n            x = len(self.burn_pile) -1\r\n            return self.burn_pile[:x]\r\n\r\n    def restock(self):\r\n        for card in self.burn_pile: # cards is the instance\r\n            if card.get(\"category\") == \"door\":\r\n                Moncurse.door_cards.append(card)\r\n                print(Moncurse.door_cards)\r\n            else:\r\n                Treasure.treasure_cards.append(card)\r\n        print(\"Card decks refilled\", \"\\nmonster cards =\", len(Moncurse.door_cards),  \"\\nTreasure cards =\", len(Treasure.treasure_cards),\r\n              \"\\nBurn pile = \", len(self.burn_pile))\r\n\r\n\r\ncards = Table() # main instance to use - gives access to all card classes and methods.\r\ndice = Table()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    z = cards.card_sop.deal_cards() # to be called further up stream for sorting\r\n    # print(\"RETURNED VALUE:\", z)\r\n\r\n    print(dice.dice_sop.roll())\r\n\r\n\r\n    # print(f\"This is your treasure card:\\n{y}\")\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/all_cards/table.py b/Munchkin/bin/all_cards/table.py
--- a/Munchkin/bin/all_cards/table.py	
+++ b/Munchkin/bin/all_cards/table.py	
@@ -22,14 +22,13 @@
 
 class Dealer:
 
-    def deal_cards(self, option=None, cardnum=4): # option = set card type, cardnum=number of cards to deal set by game  options
+    def deal_cards(self, option=None, cardnum=4): # option = set card type, cardnum=number of cards to deal set by game options or drawing cards
         """Method for dealing cards to players at start or during play. params: option selects the type/situation of
         dealing specific cards cardnum specific to the start/resurrect determines the amount of cards to of each type
         to deal players"""
 
         print(f"In deal cards. Num of cards in: \nDoor stack: {len(Moncurse.door_cards)}\nTreasure stack: {len(Treasure.treasure_cards)}\n"
-              f"Burn pile: {len(cards.burn_pile)}\nIn-play stack: {len(cards.in_play)}\n") # dev print
-
+              f"Burn pile: {len(cards.burn_pile)}\nIn-play stack: {len(cards.in_play)}\n") # dev print out
         # Checks
         if cardnum > len(Moncurse.door_cards):
             print(f"Not enough Door cards\nRESTOCKING WITH {[x['name'] for x in cards.burn_pile]}")
@@ -40,7 +39,7 @@
             cards.restock()
 
         # Main actions
-        try :
+        try:
             if option == "start":
                 """called at start to deal specific number of cards to pass to player"""
                 starter_set = []
@@ -74,13 +73,13 @@
             print("DECK EMPTY! NO CARDS AVAILABLE!!!!")
 
 
-class Table(Treasure, Moncurse): # inherits from
-    """This is the table model and the attributes expected from the game tablel"""
+class Table(Treasure, Moncurse): # inherits from all card decks
+    """This is the table model and has attributes expected from a game table"""
     def __init__(self):
         self.card_sop = Dealer() # has-a dealer
-        self.burn_pile = []
-        self.in_play = []
-        self.dice_sop = Dice()
+        self.burn_pile = [] # place to store used cards
+        self.in_play = [] # card involved in the current fight
+        self.dice_sop = Dice() # has-a dice
 
     def add_to_burn(self, discard):
         """adding to burn pile"""
Index: Munchkin/bin/all_cards/door_cards/doorcards.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nContains all door cards.\r\nWill need a processing level\r\n\"\"\"\r\n\r\n\r\nclass MonTools:\r\n    \"\"\"methods for all cards associated to Door cards, self should be the player\r\n    *items/ will have add abd remove meth\r\n    * monsters have \"conditions\" ie -2 for theifs ect and \"badstuff\" ie event of loosing fight,  params\r\n    so far: 'add' = to add item from pack, 'remove' = bs outcome or curse\r\n\r\n    \"\"\"\r\n    def unknown(self, problem):\r\n        print(f\"Problem found in method {problem}\")\r\n\r\n    def level_up(self, action, value):\r\n        if action == \"on\": # add level\r\n            print(f\"Current player level{self.level}\", end=\" \")\r\n            self.level += value\r\n            print(f\"level changed to {self.level} increased by {value}\")\r\n        else: # remove level\r\n            print(self.level)\r\n            self.level -= value\r\n            print(f\"level changed to {self.level} decreased by {value}\")\r\n\r\n    def supermunch(self, action=None):\r\n        \"\"\"player class_unlock bool option;  ln 227 player_door_cards engine! \"\"\"\r\n        print(f\"In supermunchkin. action is {action}\") # location tester\r\n\r\n        if action == \"on\":\r\n            self.klass_unlock = True\r\n            print(\"class unlocked!!!\")\r\n        elif action == \"off\":\r\n            self.klass_unlock = False\r\n            print(\"return False\")\r\n        else:\r\n            self.unknown(\"SupperMunchkin\")\r\n\r\n    def half_breed(self, action=None):\r\n        print(\"in halfbreed\")\r\n        if action == \"on\":\r\n            self.race_unlock = True\r\n            print(\"race unlocked!!\")\r\n        elif action == \"off\":\r\n            self.race_unlock = False\r\n            print(\"return False\")\r\n        else:\r\n            self.unknown(\"half_breed\")\r\n\r\n    def klass_bonus(self, action=None, *args):\r\n        if isinstance(self.klass, dict):\r\n            if self.klass.get(\"name\") == \"thief\" or self.klass2.get(\"name\") == \"theif\":\r\n                print(\"in thief meth\")# location check\r\n                pass\r\n            elif self.klass.get(\"name\") == \"elf\" or self.klass2.get(\"name\") == \"elf\":\r\n                print(\"You are an Elf\")\r\n        elif not isinstance(self.klass, dict):\r\n            print(\"No class detected with player for static action\\n\")\r\n            print(self.klass)\r\n        else:\r\n            self.unknown(\"klass_bonus error\")\r\n\r\n    def race_bonus(self, action=None, *args):\r\n        if self.race.get(\"name\") == \"thief\":\r\n            pass\r\n\r\n    def no_run(self, action=None, *args):\r\n        print(\"monster method prevents run\")\r\n        if action == \"on\":\r\n            self.run_away = False\r\n            print(\"run disabled\")\r\n        else:\r\n            self.run_away = True\r\n            print(\"run enabled\")\r\n\r\n    # def shade(self, action=None, *args):\r\n    #     \"\"\"Not used \"\"\"\r\n    #     import bin.GUI.gui_variables as gameVar\r\n    #     if isinstance(self.klass, dict):\r\n    #         if self.klass.get(\"name\") == \"thief\":\r\n    #             gameVar.Fight_enhancers.player_aid = 2\r\n    #     else:\r\n    #         print(f\"not thief no bonus {gameVar.Fight_enhancers.player_aid}\")\r\n\r\n    def below_waist(self, action=None, *args):\r\n        print(\"in loose items below waist\")\r\n        pass #pos zipper meth\r\n\r\n    def sex_change(self, action):\r\n        print(\"curse change sex!\")\r\n        print(self.gender)\r\n        if self.gender == \"male\":\r\n            self.gender = \"female\"\r\n        elif self.gender == \"female\":\r\n            self.gender = \"male\"\r\n        else:\r\n            print(\"you are immune to sex change\")\r\n        print(f\"Your sex is now: {self.gender}\")\r\n\r\n    def loose_level(self, *args):\r\n        print(f\"Your level is {self.level}\")\r\n        if self.level > 1:\r\n            self.level -= 1\r\n            print(f\"Level removed. You are now {self.level}\")\r\n        else:\r\n            print(\"level not touched, not high enough\")\r\n\r\n\r\n    def loose_armor(self, action=None, *args):\r\n        print(\"in loose_armor\")\r\n        # self.equipped_items(\"curse\")\r\n\r\n    def loose_footgear(self, *args):\r\n        print(\"in loose_footgear\")\r\n        # self.equipped_items(\"curse\")\r\n\r\n    def loose_headgear(self, *args):\r\n        print(\"loose headgear meth to add\")\r\n\r\n    def monkey_business(self, *args):\r\n        \"\"\"looses_level, loose_small_item\"\"\"\r\n        print(f\"player level is : {self.level}\")\r\n        if self.level > 1:\r\n            self.level -= 1\r\n        print(f\"player level after is : {self.level}\")\r\n\r\n    method_types = {'level_up': level_up, 'supermunch': supermunch, 'half_breed': half_breed, \"below_waist\": below_waist,\r\n                    \"loose_level\": loose_level, \"monkey_business\": monkey_business, \"no_outrun\": no_run, \"sex_change\": sex_change,\r\n                    \"loose-armor\": loose_armor, 'loose_headgear': loose_headgear, 'loose_footgear': loose_footgear, \"shade\":klass_bonus}\r\n\r\n#may need to lambda these to pass args\r\n#####################################################################\r\n# MAIN MONCURS CLASS LISTING DOOR CARDS\r\n#####################################################################\r\n\r\n\r\n# class Moncurs(M_tools, C_tools, O_tools):\r\nclass Moncurse(MonTools):\r\n    \"\"\"class to list all monster and curse cards.\"\"\"\r\n\r\n    door_cards = [\r\n        ## monster cards:id, category,  type, name, lexical, level, treasure, level_up method = bs, static = conditions at start of fight ie cant run.\r\n        {'id': 300, \"category\": \"door\", 'type': 'monster', 'name': 'Crabs', 'lexical': ['Cant outrun'], 'lvl': 1, 'treasure': 1, \"level_up\":1, 'method': \"below_waist\", \"static\": \"no_outrun\"},\r\n        {'id': 301, \"category\": \"door\", 'type': 'monster', 'name': 'Large Angry Chicken', 'lexical': ['kill with fire levelup'], 'lvl': 2, 'treasure': 1, \"level_up\":1, 'method': \"loose_level\"},\r\n        {'id': 302, \"category\": \"door\", 'type': 'monster', 'name': 'Shade', 'lexical': ['undead -2 against thieves'], 'lvl': 3, 'treasure': 1, \"level_up\":1, 'method': \"loose_level\", \"static\":\"shade\"},\r\n        {'id': 303, \"category\": \"door\", 'type': 'monster', 'name': 'Barrel Of Monkeys', 'lexical': ['+ 2 to halflings'], 'lvl': 6, 'treasure': 2, \"level_up\":1, 'method': \"monkey_business\"},\r\n\r\n        ## Curse cards: id, category, type, status, name, method, (status = active or passive for const effect that need to be added to player)\r\n        # {'id': 401, \"category\": \"door\", 'type': 'curse', 'status': 'passive', 'name': 'Loose footgear', 'method': 'loose_footgear'},\r\n        # {'id': 402, \"category\": \"door\", 'type': 'curse', 'status': 'passive', 'name': 'Loose armor!', 'method': 'loose_armor'},\r\n        # {'id': 403, \"category\": \"door\", 'type': 'curse', 'status': 'passive', 'name': 'Loose level', 'method': 'loose_level'},\r\n        # {'id': 404, \"category\": \"door\", 'type': 'curse', 'status': 'passive', 'name': 'sex change', 'method': 'sex_change'},\r\n        # {'id': 405, \"category\": \"door\", 'type': 'curse', 'status': 'passive', 'name': 'Loose headgear', 'method': 'loose_headgear'},\r\n        # {'id': 406, \"category\": \"door\", 'type': 'curse', 'status': 'passive', 'name': 'Loose 1 small item', 'method': 'loose_small_item'},\r\n        # {'id': 407, \"category\": \"door\", 'type': 'curse', 'status': 'passive', 'name': 'income tax', 'method': 'income_tax'},\r\n\r\n        ## Monster Enhancers\r\n\r\n        ## player enhancers\r\n\r\n        ## Joining cards\r\n        # {'id': 500, \"category\": \"door\", 'type': 'super munchkin', 'name': 'Super Munchkin', \"method\": 'supermunch'},\r\n        # {'id': 501, \"category\": \"door\", 'type': 'super munchkin', 'name': 'Super Munchkin', \"method\": 'supermunch'},\r\n        # {'id': 502, \"category\": \"door\", 'type': 'super munchkin', 'name': 'Super Munchkin', \"method\": 'supermunch'},\r\n        # {'id': 503, \"category\": \"door\", 'type': 'super munchkin', 'name': 'Super Munchkin', \"method\": 'supermunch'},\r\n        # {'id': 504, \"category\": \"door\", 'type': 'super munchkin', 'name': 'Super Munchkin', \"method\": 'supermunch'},\r\n\r\n        # {'id': 600, \"category\": \"door\", 'type': 'half breed', 'name': 'Half Breed', \"method\": 'half_breed'},\r\n        # {'id': 601, \"category\": \"door\", 'type': 'half breed', 'name': 'Half Breed', \"method\": 'half_breed'},\r\n        # {'id': 602, \"category\": \"door\", 'type': 'half breed', 'name': 'Half Breed', \"method\": 'half_breed'},\r\n        # {'id': 603, \"category\": \"door\", 'type': 'half breed', 'name': 'Half Breed', \"method\": 'half_breed'},\r\n        # {'id': 604, \"category\": \"door\", 'type': 'half breed', 'name': 'Half Breed', \"method\": 'half_breed'},\r\n\r\n        # {'id': 701, \"category\": \"door\", 'type': 'wondering monster', 'name': 'Wondering Monster', \"method\": 'wandering'},\r\n        # {'id': 702, \"category\": \"door\", 'type': 'wondering monster', 'name': 'Wondering Monster', \"method\": 'wandering'},\r\n        # {'id': 703, \"category\": \"door\", 'type': 'wondering monster', 'name': 'Wondering Monster', \"method\": 7wandering'},\r\n        # {'id': 704, \"category\": \"door\", 'type': 'wondering monster', 'name': 'Wondering Monster', \"method\": 'wandering'},\r\n        # {'id': 705, \"category\": \"door\", 'type': 'wondering monster', 'name': 'Wondering Monster', \"method\": 7wandering'},\r\n        # {'id': 706, \"category\": \"door\", 'type': 'wondering monster', 'name': 'Wondering Monster', \"method\": 'wandering'},\r\n        # {'id': 707, \"category\": \"door\", 'type': 'wondering monster', 'name': 'Wondering Monster', \"method\": 'wandering'},\r\n        # {'id': 708, \"category\": \"door\", 'type': 'wondering monster', 'name': 'Wondering Monster', \"method\": 'wandering'},\r\n        # {'id': 709, \"category\": \"door\", 'type': 'wondering monster', 'name': 'Wondering Monster', \"method\": 'wandering'},\r\n\r\n    ]\r\n\r\n\r\n#############################################################\r\n# TEST SUITE\r\n#############################################################\r\n    @classmethod\r\n    def __repr__(cls):\r\n        \"\"\"Card test request check\"\"\"\r\n        return cls.door_cards[0][\"name\"] # list index, dict name\r\n\r\n    def card_meths(self, card, action=None, value=None):\r\n        \"\"\"Test of cards with key values that associated to methods within method_types list located within MonTools class\"\"\"\r\n        print(\"CARD METHOD TEST\")\r\n        test_type = \"static\" # card key. static, method,\r\n        if card.get(test_type, \"Method not in card\"):\r\n            value = card[test_type] # gets value stored at card key (test_type)\r\n            print(value)\r\n            list_method = MonTools.method_types[value] #returns inactive method #looks up method with key assigning inactive value\r\n            list_method(self, action, value) # action 'on' or 'off', value level to add/ remove\r\n\r\n    def __getattr__(self, item):\r\n        \"\"\"simulates player atribs for the instance m1\"\"\"\r\n        if item == \"level\": # catches m1.level (FROM CARD METHS) setting to 4 mimicking a player with a level of 4.\r\n            return 4 # provides m1 with player traits of level\r\n        elif item == \"gender\":\r\n            return \"male\" # change according to requirement\r\n        elif item == \"klass\" or item == \"klass2\":\r\n            return {\"name\": \"elf\"} # mock class card dict, Change elements according to the required class\r\n\r\nm1 = Moncurse()\r\nif __name__ == \"__main__\":\r\n    card = m1.door_cards[2] # draws specific card\r\n    print(card) # show card\r\n    m1.card_meths(card, action=\"on\") # for methods that require action to turn off or on.\r\n    # m1.card_meths(card, action=\"off\")\r\n    # print(dir(m1)) #shows all methods and inherited meths
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/all_cards/door_cards/doorcards.py b/Munchkin/bin/all_cards/door_cards/doorcards.py
--- a/Munchkin/bin/all_cards/door_cards/doorcards.py	
+++ b/Munchkin/bin/all_cards/door_cards/doorcards.py	
@@ -212,6 +212,7 @@
         elif item == "klass" or item == "klass2":
             return {"name": "elf"} # mock class card dict, Change elements according to the required class
 
+
 m1 = Moncurse()
 if __name__ == "__main__":
     card = m1.door_cards[2] # draws specific card
Index: Munchkin/bin/all_cards/treasure_cards/treasurecards.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\" Class to define all treasure cards\"\"\"\r\n\r\nfrom random import randint\r\n\r\n\r\n#x = randint(0, 6)\r\n\r\n\r\nclass T_tools:\r\n    \"\"\" Specific methods for Treasure cards\"\"\"\r\n    pass\r\n\r\n\r\n\r\n#####################################################################\r\n# MAIN TREASURE CLASS\r\n#####################################################################\r\n\r\n\r\nclass Treasure(T_tools):\r\n    \"\"\"Base class for treasure, required to hold all Treasure cards and return card/attribute objects to children\"\"\"\r\n\r\n    burn_card = [] # The use-only-once pile that can not be reused\r\n\r\n    stack = [] # Re-usable cards\r\n\r\n    \"\"\" special methods associated to cards\"\"\"\r\n    # special_list = {'once': T_tools.restriction, 'deflect': T_tools.deflect,\r\n    #                 'immune': T_tools.immune}\r\n\r\n\r\n    \"\"\"General order: id, type, name, description, bonus, sell, special/restriction/, Dict to loop\r\n    use only once, armour, weapons, \r\n    MAY NEED SOME FORM OF CATEGORY KEY FOR THE SORTER FUNCT REQUIRED WHEN DECIDING WHERE OR WHAT THE CARDS BELONG TOO.\r\n     \r\n    ALL items require bonus status\r\n    \"\"\"\r\n    treasure_cards = [\r\n        # type disposable #no 2 add!!\r\n        {\"id\": 1, \"category\": \"treasure\", \"name\": \"Electric Radioactive Acid Potion\", \"type\": \"disposable\", \"des\": \"Use during any combat. +5 to either side.\",\r\n         \"bonus\": 2, \"sell\": 200, 'restriction': \"once, any combat\"},\r\n        {\"id\": 3, \"category\": \"treasure\", \"name\": \"Flaming Poison Potion\", \"type\": \"disposable\", \"des\": \"Use during combat\", \"bonus\": 3, \"sell\": 100,\r\n         \"special\": \"fire\", 'restriction': \"once\"},\r\n        {\"id\": 4, \"category\": \"treasure\", 'name': \"Instant Wall\", \"type\": \"disposable\", 'des': 'Automatic escape for 1 or 2 players', 'sell': 300,\r\n         \"special\": \"auto escape 2 players\", 'restriction': \"once\", \"bonus\": 0},\r\n        {\"id\": 5, \"category\": \"treasure\", \"name\": \"Flask Of Glue\", \"type\": \"disposable\", \"des\": \"Use during combat, must re-roll escape even if auto last time\",\r\n         \"sell\": 100, \"special\": \"escape\", 'restriction': \"once, re-roll escape\", \"bonus\": 0},\r\n\r\n        #type armor/head, all should have: id, type, subtype, name, des, sell, bonus\r\n        {\"id\": 6, \"category\": \"treasure\", \"name\": \"The Occasionally Reliable Amulet\", \"type\": \"armor\", \"sub_type\": \"necklace\",\r\n         'des': 'chance to deflect curse', 'sell': 600, 'special': \"deflect\", \"bonus\": 0},\r\n        {\"id\": 7, \"category\": \"treasure\", \"name\": \"Tinfoil Hat\", \"type\": \"armor\", \"sub_type\": \"headgear\",\r\n         \"des\": \"Immune to curses when  curses by kicking down doors still effect\", \"bonus\": 0, \"sell\": 800,\r\n         \"special\": \"cast immune\"},\r\n        {\"id\": 8, \"category\": \"treasure\", \"name\": \"Pointy Hat Of Power\", \"type\": \"armor\", \"sub_type\": \"headgear\", \"des\": \"Usable by wizards only\",\r\n         \"bonus\": 3, \"sell\": 400, \"klass_restriction\": \"wizard\"},\r\n        {\"id\": 9, \"category\": \"treasure\", \"name\": \"Helm Of Peripheral Vision\", \"type\": \"armor\", \"sub_type\": \"headgear\",\r\n         \"des\": \"can not be back stabbed or stolen from by thief\", \"bonus\": 2, \"sell\": 600, \"special\": \"headgear\",\r\n         \"restriction\": \"no backstab, no steal\"},\r\n        {\"id\": 10, \"category\": \"treasure\", \"name\": \"Badass Bandanna\", \"type\": \"armor\", \"sub_type\": \"headgear\",\r\n         \"des\": \"Usable by humans only\", \"bonus\": 3, \"sell\": 400, \"race_restriction\": \"human\"},\r\n\r\n        # armor/armor (complete set)\r\n        {\"id\": 11, \"category\": \"treasure\", \"name\": \"Short Wide Armour\", \"type\": \"armor\", \"sub_type\": \"armor\", \"bonus\": 3, \"sell\": 400, \"race_restriction\": \"dwarfs\"},\r\n        {\"id\": 12, \"category\": \"treasure\", \"name\": \"Raincoat\", \"type\": \"armor\", \"sub_type\": \"armor\", \"sell\": 100, \"special\": \"over armor\",\r\n         \"restrictions\": \"loose with armour\", \"bonus\": 0},\r\n        {\"id\": 13, \"category\": \"treasure\", \"name\": \"Slimy Armour\", \"type\": \"armor\", \"sub_type\": \"armor\", \"bonus\": 1, \"sell\": 200},\r\n        {\"id\": 14, \"category\": \"treasure\", \"name\": \"Mithril Armor\", \"type\": \"armor\", \"sub_type\": \"armor\", \"bonus\": 3, \"sell\": 600, \"restriction\": \"big\"},\r\n        {\"id\": 15, \"category\": \"treasure\", \"name\": \"Budget Armour\", \"type\": \"armor\", \"sub_type\": \"armor\", \"bonus\": 1, \"sell\": 100},\r\n        {\"id\": 16, \"category\": \"treasure\", \"name\": \"Flaming Armour\", \"type\": \"armor\", \"sub_type\": \"armor\", \"bonus\": 2, \"sell\": 400},\r\n        {\"id\": 17, \"category\": \"treasure\", \"name\": \"Spudded Leather Armor\", \"type\": \"armor\", \"sub_type\": \"armor\", \"bonus\": 2, \"sell\": 400},\r\n        # {\"id\": 18, \"name\": \"Gnomex Suit\", \"type\": \"armor\", \"sub_type\": \"armor\", \"bonus\": 4, \"sell\": 600,\r\n        #  \"special\": \"over armor\", \"restrictions\": \"loose with armour\", \"race_restriction\": \"gnome\"},\r\n        {\"id\": 19, \"category\": \"treasure\", \"name\": \"Chainmail Bikini\", \"type\": \"armor\", \"sub_type\": \"armor\", \"bonus\": 3, \"sell\": 600},\r\n        {\"id\": 20, \"category\": \"treasure\", \"name\": \"Leather Armor\", \"type\": \"armor\", \"sub_type\": \"armor\", \"bonus\": 1, \"sell\": 200},\r\n\r\n\r\n        #armor/boots\r\n        {\"id\": 21, \"category\": \"treasure\", \"type\": \"armor\", \"sub_type\": \"footgear\", \"name\": \"Boots Of Running Really Fast\", \"des\": \"run_away + 2\",\r\n         \"bonus\": 0, \"sell\": 400},\r\n\r\n        #weapons: id, type, sub_type, name, des, bonus, klass_restriction, hold_weight, sell, asso_meth\r\n        {\"id\": 22, \"category\": \"treasure\", \"name\": \"Staff Of Napalm\", \"type\": \"weapon\", \"sub_type\": \"1hand\", \"hold_weight\": 1, \"des\": \"Usable by wizards only\",\r\n         \"bonus\": 5, \"sell\": 800, \"klass_restriction\": \"wizard\"},\r\n        # {\"id\": 23, \"name\": \"Blessed \", \"type\": \"enhancer\", \"subtype\": \"start\", \"des\": \"Usable by wizards only\", \"bonus\": 2,\r\n        #  \"sell\": 800, \"klass_restriction\": \"wizard\", meth_call:\"enhancer\"},\r\n        {\"id\": 24, \"category\": \"treasure\", \"name\": \"Broad Sword\", \"type\": \"weapon\", \"sub_type\": \"1hand\", \"hold_weight\": 1, \"des\": \"Not for females\",\r\n         \"bonus\": 3, \"sell\": 400, \"special\": \"\", \"klass_restriction\": \"male\"},\r\n        {\"id\": 25, \"category\": \"treasure\", \"name\": \"Sword Of Slaying Everything\\nExcept squid..\", \"type\": \"weapon\", \"sub_type\": \"1hand\",\r\n         \"hold_weight\": 1,  \"des\": \"long\", \"bonus\": 4, \"sell\": 800},\r\n        {\"id\": 26, \"category\": \"treasure\", \"name\": \"Vorpal Blade\", \"type\": \"weapon\", \"sub_type\": \"1hand\", \"hold_weight\": 1, \"des\": \"+10 with anything beginning with j\",\r\n         \"bonus\": 3, \"sell\": 400, \"special\": \"item enhancer\"},\r\n        {\"id\": 27, \"category\": \"treasure\", \"name\": \"Huge Rock\", \"type\": \"weapon\", \"sub_type\": \"2hand\", \"hold_weight\": 2, \"bonus\": 3, \"sell\": 0},\r\n        {\"id\": 28, \"category\": \"treasure\", \"name\": \"Board of Education\", \"type\": \"weapon\", \"sub_type\": \"1hand\", \"hold_weight\": 1, \"bonus\": 2, \"sell\": 500}\r\n    ]\r\n    \r\n    @classmethod\r\n    def __repr__(cls):\r\n        return cls.treasure_cards[0][\"name\"]\r\n\r\n#     def get_all(self):\r\n#         \"\"\"Gives all key/val associated to a specific card\"\"\"\r\n#         for key, value in self.treasure_cards[x].items():\r\n#             print(key, \":\", value)\r\n#\r\n#     def specific(self):\r\n#         \"\"\"Directory to special/type methods and card main pack removal\"\"\"\r\n#         for key, value in self.treasure_cards[x].items(): #searches for 'type' in dict\r\n#             if key == \"type\" and value == \"once\" or value == 'escape':\r\n#                 Treasure.burn_card.append(self.treasure_cards[x]) # adds current t_card to burn_cards list\r\n#                 Treasure.special_list[value]() #value becomes key for special_list calling value method.\r\n#                 del Treasure.treasure_cards[x] #del card from t_cards to stop reuse\r\n#             elif key == 'special':\r\n#                 try:\r\n#                     Treasure.special_list[value]()\r\n#                 except KeyError:\r\n#                     print(\"This has not been configured for armour and weapons yet\")\r\n#                     #call method to sort this section out for wep and armour\r\n#             else:\r\n#                 pass\r\n#\r\n#     def card_return(self):\r\n#         \"\"\"Returns card to caller for sorting\"\"\"\r\n#         print(f\"T{self.treasure_cards[x]} card has been returned to the caller.\")\r\n#         c = self.treasure_cards[x]\r\n#         return c\r\n#         # return self.treasure_cards[x]\r\n#\r\n#     @classmethod\r\n#     def formated(cls):\r\n#         \"\"\"provides liner view of card\"\"\"\r\n#         for key, value in cls.treasure_cards[x].items():\r\n#             print(key.title(), ':', value)\r\n#\r\n#     def set_card(self):\r\n#         pass\r\n#\r\n#\r\n#\r\n# \"\"\"reload import statement for random \"\"\"\r\n# y = int(len(Treasure.treasure_cards) - 1)\r\n#\r\n# x = randint(0, y)\r\n#\r\n# #instance\r\n# c1 = Treasure() # instance object is the vessel that contains other objects\r\n#\r\n#\r\n# \"\"\"Ensures tests below only run when script is run directly and not when imported\"\"\"\r\n# if __name__ == '__main__':\r\n#     # print(f\"Num of cards in pack: {y + 1}\")\r\n#     # print(c1.treasure_cards[x]['name'])\r\n#     # \"\"\"check to see card migration and removal\"\"\"\r\n#     # #print(Treasure.treasure_cards) #prints all cards\r\n#     # #print(c1.get_all())\r\n#     # c1.specific()\r\n#     # try:\r\n#     #     print(f\"The '{Treasure.burn_card[-1]['name']}' has been depleted.\") #if added to burn list will show card\r\n#     # except IndexError:\r\n#     #     print(f\"The '{c1.treasure_cards[x]['name']}' lives on!\")\r\n#     #\r\n#     #\r\n#     #\r\n#     # '''all silenced or will run when child runs.... problem solved by top __name__ == '__main__' statement'''\r\n#     # c1.card_return()# object to be sent to other classes need return statement\r\n#     # # c1.specific() #print statement executed from top methods\r\n#     # Treasure.formated() # card view test\r\n#     import class_tree\r\n#\r\n#     class_tree.instancetree(c1)\r\n\r\n\r\n\r\n\"\"\"\r\nNOTES:\r\n\r\nUse a lexicon scanner on des to determine action for player is 'wizards only', head gear,  ect. \r\nSet armour location (knees0)  under 'special', former under des,  \"\"\"
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/all_cards/treasure_cards/treasurecards.py b/Munchkin/bin/all_cards/treasure_cards/treasurecards.py
--- a/Munchkin/bin/all_cards/treasure_cards/treasurecards.py	
+++ b/Munchkin/bin/all_cards/treasure_cards/treasurecards.py	
@@ -10,8 +10,6 @@
     """ Specific methods for Treasure cards"""
     pass
 
-
-
 #####################################################################
 # MAIN TREASURE CLASS
 #####################################################################
Index: Munchkin/bin/players/playersetup.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"Classes to define player/s and specific attributes and mechanics (\r\n\r\nConsiderations:\r\n    user name  ...............................Complete\r\n    gender ......................................Complete\r\n    play order, may be toplevel(engine)...........Complete, in engine!!\r\n    number of players ........................... Complete in engine\r\n\r\n\r\n    \"\"\"\r\n\r\nimport bin.GUI.gui_variables as gameVar\r\n\r\n\r\nclass P_tools():\r\n    \"\"\"Tools associated to the player class\"\"\"\r\n\r\n    # def equip(self, card): #recieves player instance and card dict #todo\r\n    #     # for name, component in card.items():\r\n    #     #     print(f\"{name}: {component}\r\n    #     print(f'{card[\"name\"]} to be equipped to {self.name}')\r\n    #     # if card[\"lvl\"]:\r\n    #     #     print(\"can not equip monster\")\r\n\r\n    # def card_options(self, card): # receives card object #todo missing veiw for all cards in player sack\r\n    #     \"\"\"Options for cards: Equip, Use, Sell and Charity\"\"\"\r\n    #     print(f\"You have chosen: {card}\")\r\n    #     sack_menu = input(\"Sack options:\\n1) Equip\\n2) Use\\n3) Sell\\n4) Charity\\n5) Back\\n>>> \")\r\n    #     if sack_menu.title() == \"1\" or \"Equip\":\r\n    #         # print(contents)\r\n    #         P_tools.equip(self, card)  # sends self and card to method\r\n    #\r\n    #     elif sack_menu.title() == \"2\" or \"Use\":\r\n    #         print(\"used up\")  # to method\r\n    #     elif sack_menu.title() == \"3\" or \"Sell\":\r\n    #         pass  # to method\r\n    #     elif sack_menu.title() == \"3\" or \"Charity\":\r\n    #         pass  # to method\r\n    #     elif sack_menu.title() == \"3\" or \"Back\":\r\n    #         print('returning back only')\r\n    #         return 'back',\r\n    #     else:\r\n    #         print(\"Unknown command\")\r\n\r\n\r\n    @classmethod\r\n    def gender(cls):\r\n        \"\"\"Sets gender\"\"\"\r\n        x = gameVar.PlayerAtribs.player_gender\r\n        return x\r\n\r\n    @classmethod\r\n    def name(cls):\r\n        \"\"\"Sets name\"\"\"\r\n        x = gameVar.PlayerAtribs.player_name\r\n        if x == \"rory\": # ......................................................................... dev mode\r\n            y = \"The_Creator\"\r\n            return y\r\n        return x\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/players/playersetup.py b/Munchkin/bin/players/playersetup.py
--- a/Munchkin/bin/players/playersetup.py	
+++ b/Munchkin/bin/players/playersetup.py	
@@ -42,18 +42,18 @@
     #     else:
     #         print("Unknown command")
 
-
-    @classmethod
-    def gender(cls):
-        """Sets gender"""
-        x = gameVar.PlayerAtribs.player_gender
-        return x
-
-    @classmethod
-    def name(cls):
-        """Sets name"""
-        x = gameVar.PlayerAtribs.player_name
-        if x == "rory": # ......................................................................... dev mode
-            y = "The_Creator"
-            return y
-        return x
+    #
+    # @classmethod
+    # def gender(cls):
+    #     """Sets gender"""
+    #     x = gameVar.PlayerAtribs.player_gender
+    #     return x
+    #
+    # @classmethod
+    # def name(cls):
+    #     """Sets name"""
+    #     x = gameVar.PlayerAtribs.player_name
+    #     if x == "rory": # ......................................................................... dev mode
+    #         y = "The_Creator"
+    #         return y
+    #     return x
Index: Munchkin/docs/algorthum_mapper
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>MUNCHKIN\r\n\r\ncontents:\r\n    SCRIP DEPENDENCIES\r\n    PLAY CYCLE\r\n    CLASSES METHODS AND LOGIC\r\n    ALGORITHM MAPPER\r\n    PLANNED CHANGES\r\n\r\n****************************************************************************************************\r\n**************************************** GAME GENERAL ************************************\r\n****************************************************************************************************\r\n\r\n######################################################\r\n# SCRIP DEPENDENCIES\r\n######################################################\r\n\r\ncontroller.py: provides front end logic and building blocks for GUI\r\n\r\ngui_variables (referred to as game_var): acts as a IPC script that controller.py can interact with and game_loop.py\r\ncan change without creating conflicting imports and unclear values of return statements.\r\nThis create a clear uncomplicated area that values may be seen, like game options, or stored without obfuscation.\r\n\r\ngame_loop.py (referred to as engine): location of all the backend logic that called from the GUI, generic card methods\r\nfor sorting, player rotation, control of play and anything else that sits on top of the basic script logic.\r\nThis script imports table.py giving access to both doorcards.py & treasurercards.py and playermodel.py.\r\n\r\ntable.py: is modeled on a playing table and contains classes that relate to a dealer, dice and table. dealer will fetch\r\ncards from both doorcards.py & treasurercards.py returning the card back to the caller (usually game_loop).\r\nDuring a fight or when cards are discarded they go to the table. Recovery of cards from the burn pile is controlled\r\nby dealer.\r\n\r\nplayermodel.py: with set number of instances to prevent card shortage, this class creates the fundamental player.\r\nMethods in this class are indicative of those that cause change to the players individual info or relate to the player\r\nsome way. this calls inherits from  doorcards.MonCur so that method like curses can effect the player in question and\r\ntreasurecards.T_tools for methods associated to enchanted items. playersetup.py is also imported using the P-tools class.\r\nthis however has little functionality and may be absorbed into the player model.\r\n\r\ntreasurecards.py: contains all cards for the treasure deck. This is a list of nested ditcionaries containing all\r\ninformation relevent to any of the cards in question. treasurecards.py inherits from T_tools that contains a dictioanry of all\r\nmethods associated to a card as a value to the called key received from a card in or used during play.\r\n\r\n\r\n\r\n**********************************************************************************************\r\n****************************** play cycle *******************************\r\n**********************************************************************************************\r\n\r\n##################################################\r\nSTART\r\n##################################################\r\nstart gui (links to methods below)\r\nSelect number of players\r\nmenu options:\r\n    ### game options: number of cards in backpack, lvl to win, starting deal card number, permadeath.\r\n    ### start\r\nName of each player and gender\r\nDeal cards, 4 of each (changable in possible options)\r\nRandom player index\r\n\r\nEND RESULT: new list of player instances each with names, genders and set of cards.\r\n            random player selected from list and push to game loop\r\n            ### menu added\r\n\r\n################################################\r\nGAME LOOP:\r\n################################################\r\n\r\nCheck to see if player is alive (True), skip if False\r\nPlayer inventory actions, (gui selection process) = INVENTORY Method, Full access, (sell, equipment, use)\r\nPlayer initiates Door card to be drawn (on button press)\r\n\r\nCard is placed on table(visible) (outcomes A | B)\r\ncondition check outcomes\r\ninfo on outcome\r\n\r\n A: MONSTER: Menu Options (inspect, inventory, ask for help, fight, run, interfere)\r\n    INSPECT OPTION:\r\n        inspect all visible cards on table (players, monster)\r\n\r\n    INVENTORY OPTION:\r\n        player item select use item/s (implement effect) INVENTORY Method, Restricted access, NO equip!\r\n\r\n    HELP OPTION:\r\n        player ask others for aid, help(condition: gold/treasure)\r\n\r\n    INTERFERE option:\r\n        other player interference, selecting items to use for or against\r\n\r\n    FIGHT OPTION:\r\n        fight monster/s (first in list)\r\n\r\n        FIGHT OUTCOME:\r\n            Constant outcome:\r\n                any player specific objects used during fight removed from inventory (spent)\r\n                spent cards moved to Table burn_pile\r\n            Win specific:\r\n                any assisting players help condition met (if treasure distribute according to terms, gold transfer)\r\n                treasure distributed\r\n                level increase +1 per monster\r\n                END FIGHT\r\n\r\n            Death/BADSTUFF:\r\n                if Death:\r\n                    # check win condition death if True remove player from player list\r\n                    player alive flag set to false\r\n                    death method for player atrib stripping\r\n                    branch for dead players to be reset and cards re-delt\r\n                    END PLAYER TURN\r\n                If BADSTUFF:\r\n                    referer to Monster card as associated methods (require processor function)\r\n                    END FIGHT\r\n    RUN OPTION:\r\n       check run attempt condition true or false (cant run from same monmster unless item allows)\r\n       other player/s interference option\r\n       if run true remove card from table list (add to burn pile list)\r\n       run attempt from each monster on the table (alternate between run and fight)\r\n       if Fail set run condition to False (removes/greys_out run option button for current monster)\r\n       END FIGHT IF RUN SUCCESSFUL\r\n       RETURN TO FIGHT IF UNSUCCESSFUL\r\n\r\n B:\r\n    NON FIGHTING CARD\r\n        condition to check type of card\r\n            if not curse card\r\n                move card player sack\r\n                look for trouble (draw card from hand)\r\n                GO TO FIGHT Method called\r\n            else: cursed:\r\n                apply status\r\n                draw a face down card\r\n\r\n\r\nEND FIGHT / END TURN CLEAN UP\r\n    check player level if win END Game function\r\n    check player sack max\r\n    option to access pack Method equipping, selling, use\r\n    menu: (inspect table, end turn)\r\n    inspect table (all player visible cards)\r\n    end turn button\r\n\r\n#####################################################\r\nEND TURN\r\n#####################################################\r\n Next player\r\n condition check alive\r\n    if True\r\n        reset condition\r\n        END TURN\r\n\r\n######################################################\r\n\r\n\r\n\r\n######################################################\r\n# classes, methods and logic\r\n######################################################\r\n\r\nPlayer class:\r\nclass for specific setup\r\ninitialisation\r\n    player attributes\r\n        self.ref = ref # simple form to keep track of players ( MAY CHANGE TO self.__str__() )\r\n        self.name = None # to be set when called\r\n        self.sex = None\r\n        self.level = 1 # win lvl 10, make changeable so edit score to win\r\n        self.bonus = 0\r\n        self.wallet = 0\r\n        self.race = {'r1': True, 'r2': False} # string eval to True so will show\r\n        self.klass = {'c1': True, 'c2': False}\r\n        self.weapons = {\"L_hand\": None, \"R_hand\": None, \"big\": None, \"special_1\": None, \"special_2\": False}\r\n        self.armor = {\"headgear\": None, \"armor\": None, \"armor1\": False, \"armor2\": False, \"footgear\": None,\r\n                      \"special_1\": None, \"special_2\": False, \"special_3\": False}\r\n        self.sack = [] # volume to be monitored\r\n        self.visible_cards = [] # cards visible on the table that have value\r\n        self.hireling = []\r\n        self.undefined = [] # unclassified objects for all the things i want but dont know it\r\n        self.alive = True\r\n        self.longevity = 1 # counts cycles alive, if 0 player misses go\r\n\r\n    char_setup\r\n        call meth to set up name (P_tools class)\r\n        call method to set up sex\r\n\r\n    inventory\r\n        method to set items to the player\r\n\r\n\r\nclass P_tools\r\n    all player related methods unclutter player class\r\n\r\n\r\ngui#### should (YES, IPC as better known) i have an intermediate gui script that holds all the variables? WORKING PROGRESS\r\n\r\nmain_gui reports(sets vars) to gui_var script and engine get all variables from gui var script\r\nthus main_gui imports gui_var and engine imports gui_var. gui can then call the classes of engine without moving any variables\r\nor changing the self parameter\r\n\r\n\r\n\r\nController:\r\n    Controller serves up pages(frames) that are raised to the top.\r\n    These are pre-build at the beginning\r\n    An update method is required that binds all tk.Vars to gameVar scrip (updated from player model)\r\n\r\n\r\nPages:\r\n    start page-\r\n        welcomes with start button that progresses to options toplevel\r\n\r\n    options-\r\n        sets game options in gui_variables.py.Options.  These will be game flags for certain activities\r\n        modal infobox detailing changes on conformation button press\r\n\r\n    player select-\r\n        spin box with player select. textvariable = num_of_players\r\n        button leads to player details playersetter method\r\n        playersetter-\r\n            num_of_players = IntVar() binds to 2 variables in gameVar -\r\n                1) gameVar.StartVariables.new_players that manipulates label in Toplevel\r\n                2) gameVar.StartVariables.player_rand that drives the index for the instances in the list during selection\r\n\r\n\r\n        PlayerInfo:\r\n            provides a  generic player name with a box to enter name and gender\r\n            button to confirm either moves to another player name/gender or starts game loop\r\n            Information required:\r\n                method to check num of players\r\n                link to game var to bind plays name/gender\r\n                call of method in engine to bind attribs to the correct player\r\n                possible yield loop that takes player instance\r\n                order:\r\n                    while new_players =>1\r\n                    box pops up.\r\n                    player inputs info\r\n                    button is pushed\r\n\r\n                        calls player method\r\n                        for each instance (in order) from Maxplayers\r\n                            fetches gui_variables and binds to player\r\n                            yields player\r\n\r\n                    calls next() method\r\n\r\n\r\nfor main play window the gui must have the gamevars ready linking to the instance in question. button will change the\r\ninstance associated\r\n\r\nmainloop class to define a method to send index to game_loop class.\r\n\r\ngame_Loop.py:\r\n\r\n    Game_loop.py main directive is to either source logic from other classes, provide one shot logic demanded by the\r\n    GUI and primarily to update gui_variables.py  that can be accessed by controller.py\r\n\r\n        Main class: PlayerSetup:\r\n            rand method:\r\n                usees random choice function from the random module.\r\n                picks a random player instance from the generated active_players list\r\n                send result to verbinding method.\r\n\r\n            varbinding method:\r\n                accepts parameter of a player instance\r\n                uses instance to bind all player attributes to gameVar\r\n\r\n\r\n    before MainLoop is called all tkVar need to be set up. this is handled by the controller by the method update_frame.\r\n    At the end of Playerinfo class method test, game_loop will use index to determine the correct player in gameVar.active_players.\r\n    indexed player will bind self to gameVar.player_atribs.x\r\n    controller.Main class binds self.x to StringVar()\r\n    Main.update_frame method binds all player attributes to tk Variables and the gameVar script\r\n    This update method must be called to refresh/concurrent the labels in the play area\r\n\r\n\r\n\r\n***************************************************************************************************\r\n******************************** ALGORITHM MAPPER **************************************\r\n***************************************************************************************************\r\n\r\n#######################################################################\r\n# Game start and options methods\r\n#######################################################################\r\ndeatails method for start page and game options\r\n\r\ncontroller.StartPg, class\r\n    Presents two options start or options\r\n    - start button will call controller.show_frame(PlayerSelect) so that number of players can be selected from the spinbox\r\n    - options button will call toplevel GameOptions class\r\n\r\nstart button\r\n    controller.show_frame(PlayerSelect)\r\n        See player rotation method detailed in independent section bellow\r\n\r\nGameOptions, toplevel\r\n    presents options that change gameVar.Options that act as flags for specific in game methods\r\n    Defaults are set in gameVar. Options for are:\r\n        gameVar.Options.cards_delt = self.inital_deal.get()     # number of each type of card to deal on start\r\n        gameVar.Options.win_lvl = self.maxlvl.get()             # level needed to win game\r\n        gameVar.Options.perm_death = self.permadeath.get()      # game death permanency\r\n        gameVar.Options.carry_weight = self.carry_weight.get()  # number of cards that can be placed in sack\r\n    'Ok' button calls method setopts(self)\r\n\r\n    setopts(self), method\r\n        Fetches all tk variables and binds to all gameVar variables.\r\n        creates a message variable with all f-string of all new values\r\n        messagebox.showinfo(title,contents) is called\r\n        messagebox.showinfo(\"Settings Changed!\", message) is called highlighting the changes\r\n\r\n    GameOptions.destroy(self), tk.method\r\n        toplevel with options is destroyed after acknowledging messagebox\r\n\r\ncontroller.StartPg\r\nplayer can now either re-enter options of press start\r\n\r\n#######################################################################\r\n# Name/gender, random player to start and deal starting set of cards\r\n#######################################################################\r\nDetails method for setting name/gender, random player to start and deal initial cards\r\n\r\nPlayerSelect(), class\r\n    creates spinbox with textvariable=self.Num_of_players bound to tk.IntVar()\r\n    and Confirm Button that calls self.playersetter method\r\n\r\n    playersetter, method\r\n        gameVar.StartVariables.new_players = self.Num_of_players.get()\r\n            pulls the number of selected players from the spinbox and binds to gameVar new_players\r\n            This is the number of players wanted in the current game.\r\n\r\n        gameVar.StartVariables.player_rand = self.Num_of_players.get()\r\n            Binds player_rand to Num_of_players also.\r\n\r\n        engine.select_players(), method\r\n            method is used to slice total available players with the number of players wanted then call deal_handler() to\r\n            provide cards to all players in session.\r\n\r\n            num_of_players = gameVar.StartVariables.new_players\r\n            actual players named session_players which is then stored in gameVar.\r\n                This is used to slice available_players list into a list of\r\n                gameVar.StartVariables.session_players = gameVar.StartVariables.players_available[:num_of_players]\r\n\r\n            deal_handler(\"start\"), method\r\n            Flexible method created to deal cards either at start, after death or specific cards (door/treasure).\r\n            player.unsorted = cards.card_sop.deal_cards(\"start\", gameVar.Options.cards_dealt)\r\n                Used to issue cards to all players. \"start\" parameter is used to define the the type of deal wanted.\r\n                This then loops over the players in session_players calling cards.card_sop.deal_cards() table.py\r\n\r\n                cards.card_sop.deal_cards(\"start\", gameVar.Options.cards_dealt)\r\n                    Calls Table class and the card method card_sop for the Dealer class (a table has-a Dealer) with the\r\n                    method deal_cards. The arguments \"start\" and ameVar.Options.cards_dealt specify the mode of deal\r\n                    through the branch and the number of each card to deal laid out by the game options respectively.\r\n                    Card selection fo each type is randomised through the use of Random module.\r\n                    Cards are stored in the variable starter_set and returned to caller and bound to player.unsorted.\r\n                    This is a list of cards that associates to the individual player\r\n\r\n        PlayerInfo(), toplevel\r\n            Complex script to create a arbitrary name tag with incrementation number, set the name and gender of\r\n            the player, generate a random player to start and structure a game loop that loops over session_players.\r\n\r\n                class had 2 class variables:\r\n                    counter = 1  #  player identity title number for arbitrary label\r\n                    indexing = 0 # index to access correct player instance in session_players list and ensures\r\n                    details are bound to the correct player instance.\r\n                    note a 3rd is used but located in gameVar (new_players) set by the playersetter method above.\r\n\r\n                Players enter their details and press \"confirm\" button that triggers initial_set (return button does\r\n                same thing).\r\n\r\n                    number = gameVar.StartVariables.new_players\r\n\r\n                initial_set, method\r\n                    Branch is created for checking the number of players in gameVar.StartVariables.new_players assigned\r\n                    to the variable name = number. Each time this method is called it reduces number by 1 ensuring that\r\n                    the final entry is the last to redraw the toplevel window. (number -= 1)\r\n\r\n                    PlayerInfo.counter += 1 is used to increase the number for the arbitrary player label\r\n\r\n                    gameVar.PlayerAtribs.player_name = self.instname.get()\r\n                    gameVar.PlayerAtribs.player_gender = self.instgender.get()\r\n                    Both bind the player attribs provided to the player name in gameVar\r\n                    engine.player_name_gender(PlayerInfo.indexing) is then called\r\n\r\n                    engine.player_name_gender(PlayerInfo.indexing), engine class method\r\n                        player = gameVar.StartVariables.session_players[playerindex]\r\n                            class indexing variable is used to pass to player_name_gender method to access the correct\r\n                            player in session_players.\r\n                            player is now a specific player instance\r\n\r\n                        player.char_setup() method is called to set and bind attrribs to players\r\n\r\n                        player.char_setup(), method\r\n                            calls P_tools.name() and xy = P_tools.name()\r\n                            return value of each is set as a player attribute\r\n                            if the return val is == to the dev mode other attribs will be attributed to the player\r\n\r\n                            P_tools.name()\r\n                                x = gameVar.PlayerAtribs.player_name\r\n                                returns name stored in gameVar with title method\r\n                                or dev mode name if criteria met\r\n\r\n                            P_tools.name()\r\n                            x = gameVar.PlayerAtribs.player_gender\r\n                            return x.title()\r\n\r\n                    PlayerInfo.indexing = PlayerInfo.indexing + 1 is increased for the next player when passed back into\r\n                    engine.player_name_gender(self, playerindex)    NOTE: index == playerindex as it becomes method argument\r\n                    PlayerInfo.destroy(self) is called to destroy the toplevel window\r\n                    gameVar.StartVariables.new_players = number changes the number new_players in gameVar to the new\r\n                    decreased number.\r\n\r\n                        Inner loop triggered if number not equal to 0 triggering toplevel to rebuild with the new\r\n                        arbitrary counter label increasing.\r\n\r\n                        When the condition runs that the number is == 0, the integer in new_players list has reached\r\n                        zero. This will destroy the toplevel PlayerInfo permanently and trigger the next sequence of\r\n                        events.\r\n\r\n                        engine.rand(), method\r\n                            method for selecting a player from the session_players to go first with the use of the\r\n                            random module - player = choice(gameVar.StartVariables.session_players).\r\n                            This method then calls varbinding(player), a method specifically for binding the player\r\n                            attributes to gameVar.\r\n                            Importantly gameVar active_player is named: gameVar.StartVariables.active_player = player\r\n                            used later in turn based assignment\r\n\r\n                            varbinding(player) method\r\n                                Binds all player attributes to gameVar.PlayerAtribs. Note this method can take in any\r\n                                player instance and bind to gameVar.PlayerAtribs.\r\n\r\n                        app.update_frame(), method\r\n                            part of controller.py class Main method that acts as the controller. Sets all tk.Vars with\r\n                            gameVar.PlayerAtribs. Act like a refresh for new bindings from varbinding that impacts upon\r\n                            MainLoop frame that calls controller.atrib. method also changes size of the Main window\r\n                            ready for gameplay.\r\n\r\n                        app.show_frame(MainLoop), method\r\n                            Raises MainLoop to the forefront\r\n\r\n#######################################################################\r\n# player rotation method, (initial start and game progression)\r\n#######################################################################\r\n\r\nSetting player rotation method and binding attributes. In previous section varbinding(player) and update_frame()\r\nset the player info to the random selected player. This is detailed in the player info to the left on the screen and\r\ngoes first in the game. End turn button should trigger events that lead to the next player and the update of the\r\nplayer info window.\r\n\r\n    end_turn, button method\r\n    On button press player turn ends and another players turn begins.\r\n        engine.player_order(gameVar.StartVariables.active_player) active_player bound in rand method above becomes\r\n        current_player. while play is true (to be set as conditional for gameVar.Options.win_lvl) creates loop for\r\n        players in game. With the use of itertools cycle is used to iterate over the session_players\r\n        player_gen = cycle(gameVar.StartVariables.session_players). next is called to yield next player and loop back\r\n        to the beginning of the list.\r\n\r\n        within the while loop there is a branch. current_player is compared to next(player_gen) that is called y.\r\n        If the conditional in not met  current_player == y next is called again until current_player is found == y.\r\n        When this happens there are 2 outcomes either the player is alive or the player is dead.\r\n\r\n        In the event of alive gameVar.active_player is updated to next(player_gen) thus next in line to play. varbinding\r\n        is called with the new player argument gameVar.active_player. The loop is then broken preventing endless recursion.\r\n\r\n        Death and its conditionals will be addressed later.\r\n\r\n        app.update_frame(), method\r\n        method again updates the player info to the left of the screen\r\n\r\n\r\n#######################################################################\r\n# sell method\r\n#######################################################################\r\n\r\nSell method uses code re-usability to the max with shortened functions that allow various usage buy numerous callers.\r\nThe end goal is to remove items from the player adding them to the burn pile and gaining profit from the sale.\r\n\r\n    Mainloop the sell (sell_list) button-\r\n        From controller.Mainloop the sell button calls sell_list.\r\n        sell_list first calls scrub_lists. This important as all linked lists ar appended and not built anew.\r\n        calls player from active_player in gameVar\r\n\r\n        Player has method called item_by_key. This takes 1 argument 'sell' defined as key on other end\r\n        (but could be anything specific from a game card)\r\n        item_by_key(self, key) generates a list from all cards in player.unsorted (a list of cards delt to the player during\r\n        controller.PlayerSelect.playersetter during player slice) that are specific in the fact they have in card dictionary\r\n        a key called 'sell'. Under list comprehension this generates a list of only sellable objects in the player deck.\r\n        this list is binded to gameVar.GameObjects.selected items.\r\n\r\n        Returning to controller, OwnedItems(window_title) Toplevel is now called with the arg \"Sellable Items\".\r\n        OwnedItems loops over objects in selected_items creating a list format each with a name,type,value and a checkbox.\r\n        ** consider adding info buttion that either raise the pic of the card or text description.\r\n        gameVar.GameObjects.check_but_intvar_gen.append(status) is also build per item and bound to checkbutton changing\r\n        independently with checkbutton activity.\r\n        The id of each card is appended to a new list in gameVar.GameObjects.check_but_card_ids.\r\n        This order is the same order as Checkbutton object in the other list.\r\n        The button is use to call sell method\r\n\r\n    sell button -\r\n    engine.zipper() # passes string arg for card_matcher (method acts as conduit)\r\n        Calls engine.zipper method (generic method for zipping 2 list together into a tuple)\r\n        gameVar.GameObjects.zipped_tup.clear() is called to ensure list is clear.\r\n        First step required is the conversion of the Checkbutton objects to the boolean value (0 or 1) from\r\n        gameVar.GameObjects.check_but_intvar_gen, a list of all tk Vars, associated to the check button, requiring .get method.\r\n        This creates new list of booleans called gameVar.GameObjects.check_but_boo consisting of the boolean values.\r\n        x, y = gameVar.GameObjects.check_but_card_ids, gameVar.GameObjects.check_but_boo\r\n        gameVar.GameObjects.zipped_tup = list(zip(x, y)) function is to zip cards independent ids to their bool.\r\n        This creates tuple pairs of (id,0/1) for each card in gameVar.GameObjects.selected items.\r\n        engine.card_matcher(action) is then called.\r\n\r\n    engine.card_matcher(action) CREATED FOR FLEXIBILITY OF INPUTS AND FORWARD PASS\r\n        creates loop for each card in gameVar.GameObjects.selected_items that iterates over cards then\r\n        creates an inner loop or tup in gameVar.GameObjects.zipped_tup for each card, NOTE:tup contains (card id, 0or1).\r\n        Conditional if tup[0] == card[\"id\"] and tup[1] filters the cards by matching ids (tup[0]) and only if the\r\n        tup[1] value is == 1 (True).\r\n        After qualification a branch is created calling the correct method associated to action parameter, in this case \"sell\"\r\n        the qualifying card is passed to sell_item(self, card).\r\n\r\n        sell_item(self, card)\r\n            player wallet is substituted with the card value and the card is popped form the\r\n            player unsorted list and cards.add_to_burn(x) is called.\r\n\r\n            cards.(self, discard) method -\r\n            x = self.unsorted.pop(self.unsorted.index(card)) # pops card from player unsorted deck\r\n            cards.add_to_burn(x) # popped item is used as arg\r\n                simple method that adds cards to the burn pile that have been remove from the game. note simple arg of the card\r\n                to be removed\r\n\r\n    OwnedItems.destroy(self)\r\n        destroys toplevel with sellable items listed\r\n\r\n    engine.scrub_lists()\r\n        Critical for appended lists.\r\n        calls scrub_list from engine resetting all appendable lists: selected_items, check_but_intvar_gen, check_but_boo,\r\n        check_but_card_ids and zipped_tup. This reset allows new creation when recalled or new player.\r\n\r\n    rebinding variables\r\n    engine.varbinding(gameVar.StartVariables.active_player)\r\n    app.update_frame()\r\n        updates the player info screen detailing changes to player wallet\r\n\r\n\r\n##########################################################################\r\n# Equipping method\r\n##########################################################################\r\n\r\nAccessed by either weapons or armour buttons.\r\nMainLoop, class\r\n    Armor, Main screen button - calls list_armor method\r\n\r\n    list_armor, method:\r\n        gameVar.GameObjects.message & app.update_message(\"show\") - Call simple message to the main window\r\n\r\n        engine.scrub_lists() - clears all lists ready for new item stack in the toplevel window.\r\n\r\n        player.inventory(\"type\", \"armor\") - searches player card list for cards that have a key of \"type\" and val of \"armor\".\r\n            Cards that meet this criteria are sent to gameVar.selected_items. Note that this meth take two params as it is looking for a\r\n            specific key val pair. Note cards have \"type\":\"armor\" arrangement in the card dict.\r\n\r\n        OwnedItems(\"Armor Owned\", \"armor\") - TopLevel call with params for title other for button layout specific to armor.\r\n\r\n    OwnedItems(title, set_but) - Toplevel, Window is built with title and specific set of buttons for armor cards found in the player.\r\n        Buttons include: sell (method as above), Equip (This focus), a check box and info (displays card) for each item.\r\n\r\n        equip - button method, ran on those items that have been checked.\r\n            calls common_set That calls a common set of methods found with many buttons.\r\n                engine.zipper(\"equip\"), method -  See sell meth for action (brief - takes selected_items list and bools\r\n                from checkbox to make. Calls card_matcher)\r\n\r\n                card_matcher(action), method - See sell , (brief - id matches cards with the unsorted. The tuples return\r\n                    True to yield cards that can be used). The action parameter defines what happens to the card next).\r\n\r\n                    method - For any card to be equipped it must be checked to ensure that it is suited\r\n                        to the player in respects of race, class and gender. This is required as some cards have restrictions\r\n                        who can use them. (This is an updated meth that does away with the a fractured 3 method approach).\r\n                        Uses dict of key vals to loop over player and card. First card is checked for any restrictions,\r\n                        if none exist the loop is exited resulting in the card being passed to the next method.\r\n                        If the card contains a restriction it is compared to the player. In the event the player does not\r\n                        qualify, the cards remains in the unsorted list unequipped. A flag is used to control passage.\r\n                        ############## small bug name can be r and still qualify if no gender set ####################### ADDED DEFAULT GENDER\r\n                        If qualified, card_designator(player, card) is called passing the card and player along.\r\n\r\n\r\n\r\n\r\n\r\nPREBUILD CONSIDERATIONS PLAN\r\nconsider changing card to fit ie equip:True then loop over for equipped items. good to detrmine bonuses, use re for\r\nstatus effects/qualifiers. name of equipped item for player info = verbinding can call meth that returns it or none\r\n\r\nneed to set up vars in Main\r\naccess to them\r\nseparate player list for equipped/curse/status effects\r\nmethod to select equipable items and populate selected_items\r\nway to screen items dependent on player ie for dewarfs only ect\r\n\r\nstepes needed:::\r\nway to screen cards race/gender... same for cursing??\r\n\r\nway to add to player or check if place is occupied already and remove player and add to sack\r\n\r\n\r\n##########################################################################\r\n# view method\r\n##########################################################################\r\ndone\r\n\r\n\r\n\r\n#######################################################################\r\n# remove items\r\n#######################################################################\r\ndone\r\naction =  engine,zipper(\"remove\")>\r\nrequires a search if player assets as no items will show in top level as they have been removed.\r\n\r\n\r\n\r\n#######################################################################\r\n# enhancers\r\n#######################################################################\r\nnot done\r\nmost likely card associated methods that are called at start of play to enrich/encumber player\r\n\r\n\r\n#######################################################################\r\n# door\r\n#######################################################################\r\ndoor button triggers the advancement through the game by placing cards on the table. Two options are then present: the\r\ncard is either a non fighting cards that requires resolving ie curse on player ect or, a monster card that needs to be\r\nfought to progress forward.\r\n\r\nDoor button > door method\r\n     self.b1.config(state=\"disabled\"), disables end_turn to prevent early escape\r\n     gameVar.CardDraw.num_of_kicks == 0, condition to enforce play order (non fight= 2nd door kick, fight = end)\r\n     door_card = engine.deal_handler(\"door\", call=1) method that excepts return object(this will be card for pic)\r\n     call is for the card designator to handle cards in different way dependent upon how many times the door has been kicked.\r\n        deal_handler(self, option, call=1), method (option =start, door or treasure, call=conduit pass)\r\n           When kicking the door the option will always be \"door\".\r\n            door_card = cards.card_sop.deal_cards(\"door\", 1), method, (type of card wanted, deck volume checker)\r\n                Runs the Table class that has a dealer() method that returns specific cards.\r\n                calls self.card_designator(door_card, call=call), method (sends new door card, sends call)\r\n            card_designator(self, card, call=1, num=0), method,\r\n                sorts the new card dependent on its type. If monster, and call is 1 (denoting first kick of door- eval to True)\r\n                adds to cards.in_play.append(card) ready for fight. else is used when call=0 denoting door kick is 2nd attempt\r\n                card in this case is added to the player hand.\r\n                curse cards on first attempt curse the player (method to run card to follow), 2nd attempt card goes in sack\r\n                all other cards go to sack. num is not used in this section with explanation left to winning fights and\r\n                gaining treasure. Final elif card.get(\"category\") == \"door\" block catches cards that have no effect\r\n                directly and do not fit under the monster or curse. call is used to define how many times door has been pushed.\r\n        engine.card_type(), method, checks to see if monster has been added to the in_play stack. If returns true, buttons:\r\n        door, weapons, armor and sell are all disabled to prevent miss use. Buttons fight and run are enabled.\r\n        Importantly door disabled prevents further use and a second call on the door. reset is done by ending turn.\r\n\r\n    Both engine.card_type() and else statement result in incrementation of num_of_kicks by one.\r\n\r\n    With a card that is not a monster card on first instance, a second push of door is allowed. In this instance\r\n    gameVar.CardDraw.num_of_kicks == 1 evaluates correctly disabling door button for further use.\r\n    engine.deal_handler(\"door\", call=0) is called again with the parameter call set to 0 (False)\r\n        engine.deal_handler(\"door\", call=0), method\r\n            like before gets door card in turn calling card_designator again with the new call parameter of 0\r\n            card_designator(self, card, call=0), method\r\n                now triggers all else statements for the desired card type. In all instances this places the card in the\r\n                player sack and not on the table.\r\n\r\n\r\n#######################################################################\r\n# fight\r\n#######################################################################\r\nfight button becomes available when a monster is on the table within the in_play list. any additions to this list will\r\nforce the player to battle monsters in a first in last out order until no monsters are left. This order is also apparent\r\nwith the run button discussed later.\r\n\r\n\r\n\r\n#######################################################################\r\n# run\r\n#######################################################################\r\nmethod looks up a players ability to run - as a bool 0 = false so no run and all other numbers = true.\r\nIf true this number represents the roll required to escape\r\n\r\n\r\n#######################################################################\r\n# curses\r\n#######################################################################\r\nconsider curses that have effect and those that dont.\r\n    dont > back to burn pile\r\n    do > detrmine location of activity ( armor, weapon?) needs link to card that is effected (id) and storage\r\n    somewhere in player model. card active in correct situation then deactivation meth required\r\n\r\ncard_designator(self, card, call=1): look under curses to add meth\r\n\r\n\r\n#######################################################################\r\n# enhancers method\r\n#######################################################################\r\nenchantment to stay on lost weapons!\r\n\r\n\r\n\r\n#######################################################################\r\n# interfere method\r\n#######################################################################\r\n\r\n\r\n\r\n#######################################################################\r\n# help\r\n#######################################################################\r\n\r\n\r\n\r\n#######################################################################\r\n# pay to go up level\r\n#######################################################################\r\n\r\n****************************************************************************************************\r\n**************************************** planned changes *************************************\r\n****************************************************************************************************\r\n\r\ngame_loop.py\r\n* Splitting up this module into more defined classes will be needed.
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/docs/algorthum_mapper b/Munchkin/docs/algorthum_mapper
--- a/Munchkin/docs/algorthum_mapper	
+++ b/Munchkin/docs/algorthum_mapper	
@@ -9,10 +9,11 @@
 
 ****************************************************************************************************
 **************************************** GAME GENERAL ************************************
-****************************************************************************************************
+****************************************************************************************************,
+
 
 ######################################################
-# SCRIP DEPENDENCIES
+# SCRIPT DEPENDENCIES
 ######################################################
 
 controller.py: provides front end logic and building blocks for GUI
@@ -715,5 +716,8 @@
 **************************************** planned changes *************************************
 ****************************************************************************************************
 
+Consider ownership of action handling ie who is responsable for what in the programme ie what is responsible
+for sorting cards or game flow?
+
 game_loop.py
 * Splitting up this module into more defined classes will be needed.
\ No newline at end of file
Index: Munchkin/bin/players/playermodel.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nClass to build model players and assign new attributes associated with cards through gameplay.\r\n\r\nConsiderations:\r\n    Player model\r\n    Death\r\n    New build\r\n    save -- most likely shelve objects\r\n    stats access\r\n\r\n\"\"\"\r\n\r\n\r\nfrom Munchkin.bin.all_cards.table import Table # most likely not used here (pos for cross talk bypassing circular\r\n# import but may require for adding to player inventory and stats (note same card in engine will return here)\r\nfrom Munchkin.bin.all_cards.treasure_cards.treasurecards import Treasure\r\n\r\nfrom Munchkin.bin.players.playersetup import P_tools\r\nimport bin.GUI.gui_variables as gameVar\r\nfrom bin.all_cards.table import cards\r\nfrom bin.all_cards.door_cards.doorcards import MonTools\r\nfrom bin.all_cards.treasure_cards.treasurecards import T_tools\r\nfrom  itertools import cycle\r\n\r\n\r\n\r\n\r\n\"\"\"adding items to player\"\"\"\r\n################### CHECKER (works)\r\n# cards = Handler()\r\n# x = cards.card.grabber() # to be called further up stream for sorting\r\n# print(\"RETURNED VALUE:\", x)\r\n#####################\r\n\r\n\"\"\"This is the player class. It will have all setting to configure players and modify attributes that are set to that\r\nplayer. It will inherit from moncurse and treasure so that a player can add items to their attributes and modify\r\nattributes based on action outcomes.\"\"\"\r\n\r\n\r\n##########################################################################\r\n# Player attributes and methods\r\n##########################################################################\r\n\r\n\r\n\r\n#####################################################################\r\n# MAIN PLAYER CLASS\r\n#####################################################################\r\n\r\nclass Player(MonTools, T_tools): # inherits off card methods\r\n    \"\"\"Main player class\"\"\"\r\n\r\n    def __init__(self, ref):\r\n        self.ref = ref # simple form to keep track of players\r\n        self.name = \"\"\r\n        self.gender = \"male\" # default required..dont think it works like this...\r\n        self.level = 1 # win lvl 10, make changeable so edit score to win\r\n        self.bonus = 0\r\n        self.wallet = 0\r\n        self.race = \"human\" # string eval to True so will show\r\n        self.race2 = \"\"\r\n        self.race_unlock = False # DEFAULT = False method by halfbread triggers this a True state (method to be added)\r\n        self.klass = \"No class\"\r\n        self.klass2 = \"\"\r\n        self.klass_unlock = False # method by supermunchkin triggers this a True state\r\n        self.big = \"\" # can carry only 1 big item\r\n        self.big2 = []\r\n        self.big_unlock = False\r\n        self.weapons = {\"L_hand\": \"\", \"R_hand\": \"\", \"two_hand\": \"\"}\r\n        self.weapon_count = 2  # 1 per hand, can add to with cheat. adding +=, removal -=.\r\n        self.armor = {\"headgear\": \"\", \"armor\": \"\", \"knees\": \"\", \"footgear\": \"\",\r\n                      \"necklace\": \"\", \"ring\": \"\", \"ring2\": \"\"} # fill with card\r\n        self.sack = [] # 5 max, pos editable later in an options\r\n        self.active_cards = [] # cards that elicit an effect ie supermunch armor enhancers ect\r\n        self.hireling = []\r\n        # self.unsorted = [] # Old! list of all cards that are used to by sorting\r\n        self.alive = True\r\n        self.longevity = 0 # counts cycles alive, if 0 player misses go\r\n        self.cheat = 0 # set to false\r\n        self.cheat_card = 0 # card the player is cheating with\r\n        self.active_effects = [] # list of all cards that effect player (curses ect)\r\n        self.passive_effects = [] # list of all passive effects to be applied at player turn start\r\n        self.curse_allowed = True #switched off with tin hat ect\r\n        self.run = 4 # ability to run, manipulable. note elf must change this. !!! use as bool and escape value!\r\n        self.run_away = True # locks ability toi run or not dependent on some monsters\r\n\r\n    def __repr__(self):\r\n        \"\"\"developer aid\"\"\"\r\n        return f\"\\nPLAYER REF:{self.ref}\\nName:{self.name}\\ngender:{self.gender}\\nLevel:{self.level}\" \\\r\n               f\"\\nBonus:{self.bonus}\\nSack:{self.wallet}\\n\"\r\n\r\n    # def __str__(self):\r\n    #     \"\"\"developer aid\"\"\"\r\n    #     return f\"\\nPLAYER INFO:\\nName:{self.name}\\ngender:{self.gender}\\nLevel:{self.level}\" \\\r\n    #            f\"\\nBonus:{self.bonus}\\n\"\r\n\r\n    def update_bindings(self, carried):\r\n        \"\"\"just gets whats attached to the player\"\"\"\r\n\r\n        category = [self.weapons, self.armor]  # locations to search\r\n        for sub_cat in category:  # is the dict as a whole\r\n            for key in sub_cat:\r\n                if isinstance(sub_cat[key], dict) and key == carried:\r\n                    # gameVar.GameObjects.message = f'{sub_cat.get(key).get(\"name\")} has been bound to {key}'\r\n                    return sub_cat.get(key).get(\"name\")\r\n\r\n    def char_setup(self):\r\n        # complete, prints to be removed\r\n        \"\"\"sets up name and gender in gameVar and player instance when called\"\"\"\r\n        na = P_tools.name() # method to set name\r\n        self.name = na  # makes change to player\r\n        xy = P_tools.gender()\r\n        self.gender = xy\r\n\r\n        if self.name == \"The_Creator\": # ................................................................... dev mode\r\n            self.gender = \"bob\"\r\n            self.bonus = 200\r\n            self.wallet = 20000\r\n            gameVar.PlayerAtribs.player_gender = self.gender\r\n            gameVar.GameObjects.message2 = f\"{self.name} is in play, a god among mer mortals!\"\r\n\r\n        print(f\"Your name is {self.name.title()} and you are {self.gender.title()}.\")\r\n\r\n    def inventory(self, key, cardtype): # called from GUI on button press\r\n        \"\"\"Returns list of dict from player sack cards that have a specific key and specific value.\r\n        (ie sub_type == armour). returns all sub_types with the val of armor\"\"\"\r\n        gameVar.GameObjects.selected_items = [obj for obj in self.sack if obj[key] == cardtype]\r\n\r\n    def item_by_key(self, key):# generalised meth for key search\r\n        \"\"\"Returns list of cards form player sack list that contain the key x. (ie \"sell\").\r\n        This is generalised meth for key search \"\"\"\r\n        gameVar.GameObjects.selected_items = [obj for obj in self.sack if obj.get(key)]\r\n\r\n    def sell_item(self, card): # called by player.sell_item so self bound to player\r\n        \"\"\"Call from zipper to sell items, remove cards, reset gameVars and call to add to burn pile\"\"\"\r\n        self.wallet += card[\"sell\"] #adds worth of card to player\r\n        gameVar.GameObjects.message = f\"Selling sack {card['name']}, Card added to burn pile. Depth: {len(cards.burn_pile)}\"\r\n        x = self.sack.pop(self.sack.index(card)) # removes card from player sack deck\r\n        cards.add_to_burn(x)# adds card to burn pile on table\r\n        gameVar.GameObjects.message = f\"Selling sack {card['name']}, \" \\\r\n                                      f\"\\nCard added to burn pile. Depth: {len(cards.burn_pile)}\"\r\n        # print(\"tup list: \", gameVar.GameObjects.zipped_tup)\r\n\r\n    def sum_of_bonuses(self): # pos multi usage and use as player item searcher. limited by equipped_items as caller\r\n        \"\"\" Adds up all bonuses and bind to player in weapons and armour\"\"\"\r\n        tot_bonus = 0\r\n        locations = [self.weapons, self.armor] #locations to search\r\n        for obj in locations: # looks at each object in list\r\n            for sub_menu in obj:\r\n                if isinstance(obj[sub_menu], dict): #checks submenu for card attachment in the form of a dict\r\n                    # print(obj.get(sub_menu, \"No sub menu\").get(\"bonus\", \"No bonus found\"))\r\n                    tot_bonus += obj.get(sub_menu, \"\").get(\"bonus\", \"Problem getting bonus\")\r\n                    continue\r\n        if self.name == \"The_Creator\":\r\n            tot_bonus = 200 + tot_bonus\r\n        self.bonus = tot_bonus\r\n\r\n    def equipped_items(self, action, my_cards=None, card_id=None): # in use by gui list_equipped meth\r\n        \"\"\"Shows all items that have been equipped to the player. If remove, Sorts through equipped items,\r\n        removing items that have been selected\"\"\"\r\n        locations = [self.weapons, self.armor]  # locations to search\r\n        for obj in locations:  # looks at each object in list. obj is the dict of all the poss locations as seen in player attrbs\r\n            for sub_menu in obj:  # sub_menu is the keys which link to the card is placed in: armor = {}\r\n                if isinstance(obj[sub_menu], dict):  # checks submenu for card attachment in the form of a dict\r\n                    card = obj.get(sub_menu) # x is the card object\r\n                    if action == \"list_equipped\":\r\n                        gameVar.GameObjects.selected_items.append(card) #adds cards to selected_items list in gameVar\r\n                        continue\r\n                    elif action == \"removal\":\r\n                        if card[\"id\"] == my_cards[\"id\"]:\r\n                            self.sack.append(card) # adds card back to player inventory\r\n                            obj[sub_menu] = \"\" # resets player atrib location\r\n                            self.sum_of_bonuses() # recalculates bonuses\r\n                            self.weapon_count += card.get(\"hold_weight\", 0) # adds the cards carry_weight for available hands, if available.\r\n                            continue\r\n                    elif action == \"curse\": # not tested\r\n                        print(\"In equipped items remove cured item\")\r\n                        pass\r\n\r\n    def equip_armor(self, card):\r\n        \"\"\" Equips armor to the player\"\"\"\r\n        location = self.armor\r\n        print(\"in armor\")\r\n        for sub_type in location.keys():\r\n            if card[\"sub_type\"] == sub_type:  # matches card[\"sub_type] to list\r\n                occupied = isinstance(self.armor[sub_type], dict)\r\n                if not occupied:\r\n                    x = self.sack.pop(self.sack.index(card))  # removes cards from sack list\r\n                    self.armor[sub_type] = x  # adds to player's attribs\r\n                    break\r\n                elif occupied:\r\n                    card_removed = self.armor.pop(sub_type)  # removing card from player's attrib\r\n                    self.sack.append(card_removed)\r\n                    x = self.sack.pop(self.sack.index(card))  # removes cards from sack list\r\n                    self.armor[sub_type] = x  # binds now card to player attribute\r\n                    break\r\n        gameVar.GameObjects.message = f\"Equipping {card['name']}\"\r\n        self.sum_of_bonuses()\r\n\r\n    def equip_weapon(self, card):\r\n        \"\"\"New simplified model. Checks L/R hands to see if full, equipping if not.\r\n        Two hand items will not work when other hands full. \"\"\"\r\n        if self.weapon_count > 0:\r\n            if card[\"sub_type\"] == \"1hand\" and not isinstance(self.weapons[\"L_hand\"], dict): # not equipped\r\n                added_card = self.sack.pop(self.sack.index(card))\r\n                self.weapons[\"L_hand\"] = added_card\r\n                self.weapon_count -= card.get(\"hold_weight\")\r\n                gameVar.GameObjects.message = f\"Equipping {card['name']} to left hand\"\r\n            elif card[\"sub_type\"] == \"1hand\" and not isinstance(self.weapons[\"R_hand\"], dict): # not equipped\r\n                gameVar.GameObjects.message = f\"Equipping {card['name']} to right hand\"\r\n                added_card = self.sack.pop(self.sack.index(card))\r\n                self.weapons[\"R_hand\"] = added_card\r\n                self.weapon_count -= card.get(\"hold_weight\")\r\n            elif card[\"sub_type\"] == \"2hand\" and not isinstance(self.weapons[\"two_hand\"], dict):\r\n                if isinstance(self.weapons[\"L_hand\"], dict) or isinstance(self.weapons[\"R_hand\"], dict):\r\n                    gameVar.GameObjects.message = \"You can not equip this item while you have items in your other hands\"\r\n                elif not isinstance(self.weapons[\"L_hand\"], dict) and not isinstance(self.weapons[\"R_hand\"], dict):\r\n                    gameVar.GameObjects.message = f\"Equipping {card['name']} to both hands\"\r\n                    added_card = self.sack.pop(self.sack.index(card))\r\n                    self.weapons[\"two_hand\"] = added_card\r\n                    self.weapon_count -= card.get(\"hold_weight\")\r\n            else: # cheat card section\r\n                pass\r\n        else:\r\n            gameVar.GameObjects.message = \"You are at max capacity. Remove some weapons to attach others!\"\r\n        print(\"capacity count\", self.weapon_count)\r\n        self.sum_of_bonuses()\r\n\r\n    def card_meths(self, card, calltype=None, action=None): # calltype = method or static, action on or off,\r\n        \"\"\"link to card methods for active effect on player\r\n        action =add, contitions or remove\"\"\"\r\n        print(f\"In player card_meth. Calltype: {calltype},, Action {action}\") # info on meth used and status\r\n        \"\"\"will use add/remove suited to door cards, loose cases and curse canceling\"\"\"\r\n        for key, val in MonTools.method_types.items(): # look up meth\r\n            if key == card.get(calltype): # calltype either 'method for general, and 'static' for const effects while in use\r\n                print(f\"the key is {key}\")\r\n                val(self, action) # action is on or off\r\n\r\n\r\n\"\"\"\r\ncard meth to handle curse, monsters ect. must handle both a static action and methods associated to add and remove.\r\ncalls required from; player select card, door kick for static ie no run, and loose scenario  \r\n\r\n\r\n\"\"\"\r\n\r\n\r\np1 = Player(1) #passes reference (ref)\r\np2 = Player(2)\r\np3 = Player(3)\r\np4 = Player(4)\r\np5 = Player(5)\r\np6 = Player(6)\r\np7 = Player(7)\r\np8 = Player(8)\r\np9 = Player(9)\r\np10 = Player(10)\r\n# p1.get_treasure()\r\n\r\n\r\n\r\nif __name__ == '__main__':\r\n    p1 = Player(1)\r\n    print(p1)\r\n    # p1.get_treasure() # duplicate val is print state from Handler class method (note is same: GOOD)\r\n    # p1.char_setup() # calls player name/gender setup, to be called after player number select\r\n    # p1.inventory() # shows inventory of new built char\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Munchkin/bin/players/playermodel.py b/Munchkin/bin/players/playermodel.py
--- a/Munchkin/bin/players/playermodel.py	
+++ b/Munchkin/bin/players/playermodel.py	
@@ -1,10 +1,13 @@
 """
 Class to build model players and assign new attributes associated with cards through gameplay.
 
+Consider what the player class is responsible for...
+
 Considerations:
     Player model
-    Death
-    New build
+    player setup name & gender
+    Death and reset
+    accessing player and changing player resources
     save -- most likely shelve objects
     stats access
 
@@ -15,40 +18,23 @@
 # import but may require for adding to player inventory and stats (note same card in engine will return here)
 from Munchkin.bin.all_cards.treasure_cards.treasurecards import Treasure
 
-from Munchkin.bin.players.playersetup import P_tools
+from Munchkin.bin.players.playersetup import P_tools # OF LITTLE USE. Methods name/gender moved to this script.
 import bin.GUI.gui_variables as gameVar
 from bin.all_cards.table import cards
 from bin.all_cards.door_cards.doorcards import MonTools
 from bin.all_cards.treasure_cards.treasurecards import T_tools
-from  itertools import cycle
+from itertools import cycle
 
-
-
-
-"""adding items to player"""
-################### CHECKER (works)
-# cards = Handler()
-# x = cards.card.grabber() # to be called further up stream for sorting
-# print("RETURNED VALUE:", x)
-#####################
-
 """This is the player class. It will have all setting to configure players and modify attributes that are set to that
 player. It will inherit from moncurse and treasure so that a player can add items to their attributes and modify
 attributes based on action outcomes."""
 
-
-##########################################################################
-# Player attributes and methods
-##########################################################################
-
-
-
 #####################################################################
 # MAIN PLAYER CLASS
 #####################################################################
 
-class Player(MonTools, T_tools): # inherits off card methods
-    """Main player class"""
+class Player(MonTools, T_tools):
+    """Main player class, inherits off card methods making changes to the player."""
 
     def __init__(self, ref):
         self.ref = ref # simple form to keep track of players
@@ -94,9 +80,23 @@
     #     return f"\nPLAYER INFO:\nName:{self.name}\ngender:{self.gender}\nLevel:{self.level}" \
     #            f"\nBonus:{self.bonus}\n"
 
+    @classmethod
+    def gender(cls):
+        """Sets gender"""
+        x = gameVar.PlayerAtribs.player_gender # grabs string stored in in game var
+        return x
+
+    @classmethod
+    def name(cls):
+        """Sets name"""
+        x = gameVar.PlayerAtribs.player_name
+        if x == "rory":  # ......................................................................... dev mode
+            y = "The_Creator"
+            return y
+        return x
+
     def update_bindings(self, carried):
         """just gets whats attached to the player"""
-
         category = [self.weapons, self.armor]  # locations to search
         for sub_cat in category:  # is the dict as a whole
             for key in sub_cat:
@@ -107,9 +107,9 @@
     def char_setup(self):
         # complete, prints to be removed
         """sets up name and gender in gameVar and player instance when called"""
-        na = P_tools.name() # method to set name
+        na = Player.name() # method to set name
         self.name = na  # makes change to player
-        xy = P_tools.gender()
+        xy = Player.gender()
         self.gender = xy
 
         if self.name == "The_Creator": # ................................................................... dev mode
diff --git a/Munchkin/bin/engine/game_logic.py b/Munchkin/old/game_logic.py
rename from Munchkin/bin/engine/game_logic.py
rename to Munchkin/old/game_logic.py
diff --git a/Munchkin/bin/GUI/gui_interface.py b/Munchkin/old/gui_interface.py
rename from Munchkin/bin/GUI/gui_interface.py
rename to Munchkin/old/gui_interface.py
