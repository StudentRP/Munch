MUNCHKIN

contents:
    GAME GENERAL
        SCRIP DEPENDENCIES
    PLAY CYCLE
        START
        GAME LOOP
        END TURN
    CLASSES METHODS AND LOGIC
    ALGORITHM MAPPER
    PLANNED CHANGES

****************************************************************************************************
**************************************** GAME GENERAL ************************************
****************************************************************************************************,


######################################################
# SCRIPT DEPENDENCIES
######################################################

view.py: provides front end logic and building blocks for GUI

variables_library.py (referred to as library): acts as a IPC script that view.py can interact with and controller.py
can change without creating conflicting imports and convoluted return statements.
This create a clear uncomplicated area that values may be seen, like game options, or stored without obfuscation.

controller.py (referred to as engine): location of all the backend logic that called from the GUI, generic card methods
for sorting, player rotation, control of play and anything else that sits on top of the basic script logic.
This script imports table.py giving access to both doorcards.py & treasurercards.py and playermodel.py.

table.py: is modeled on a playing table and contains classes that relate to a dealer, dice and table. dealer will fetch
cards from both doorcards.py & treasurercards.py returning the card back to the caller (usually engine).
During a fight or when cards are discarded they go to the table. Recovery of cards from the burn pile is controlled
by dealer.

playermodel.py: with set number of instances to prevent card shortage, this class creates the fundamental player.
Methods in this class are indicative of those that cause change to the players individual info or relate to the player
some way. This calls inherits from  doorcards.MonCur so that method like curses can effect the player in question and
treasurecards.T_tools for methods associated to enchanted items. playersetup.py is also imported using the P-tools class.
this however has little functionality and may be absorbed into the player model.

treasurecards.py: contains all cards for the treasure deck. This is a list of nested ditcionaries containing all
information relevent to any of the cards in question. treasurecards.py inherits from T_tools that contains a dictioanry of all
methods associated to a card as a value to the called key received from a card in or used during play.



**********************************************************************************************
****************************** play cycle *******************************
**********************************************************************************************

##################################################
START
##################################################
start gui (links to methods below)
Select number of players
menu options:
    ### game options: number of cards in backpack, lvl to win, starting deal card number, permadeath.
    ### start
Name of each player and gender
Deal cards, 4 of each (changable in possible options)
Random player index

END RESULT: new list of player instances each with names, genders and set of cards.
            random player selected from list and push to game loop
            ### menu added

################################################
GAME LOOP:
################################################

Check to see if player is alive (True), skip if False
Player inventory actions, (gui selection process) = INVENTORY Method, Full access, (sell, equipment, use)
Player initiates Door card to be drawn (on button press)

Card is placed on table(visible) (outcomes A | B)
condition check outcomes
info on outcome

 A: MONSTER: Menu Options (inspect, inventory, ask for help, fight, run, interfere)
    INSPECT OPTION:
        inspect all visible cards on table (players, monster)

    INVENTORY OPTION:
        player item select use item/s (implement effect) INVENTORY Method, Restricted access, NO equip!

    HELP OPTION:
        player ask others for aid, help(condition: gold/treasure)

    INTERFERE option:
        other player interference, selecting items to use for or against

    FIGHT OPTION:
        fight monster/s (first in list or selected...)
        If monster has a static method (const effect) this need to be activated before any actions.
        if additional players want to interfere/help action the methods


        FIGHT OUTCOME:
            Constant outcome:
                any player specific objects used during fight removed from inventory (spent)
                spent cards moved to Table burn_pile
            Win specific:
                any assisting players help condition met (if treasure distribute according to terms, gold transfer)
                treasure distributed
                level increase +n dependent on monster


            Death/BADSTUFF:
                if Death:
                    # check win condition death if True remove player from player list
                    player alive flag set to false
                    death method for player atrib stripping
                    branch for dead players to be reset and cards re-delt
                    END PLAYER TURN
                If BADSTUFF:
                    referer to Monster card as associated methods (require processor function)


            END FIGHT
            Remove monster specific static methods

    RUN OPTION:
       check run attempt condition true or false (cant run from same monmster unless item allows)
       other player/s interference option
       if run true remove card from table list (add to burn pile list)
       run attempt from each monster on the table (alternate between run and fight)
       if Fail set run condition to False (removes/greys_out run option button for current monster)
       END FIGHT IF RUN SUCCESSFUL
       RETURN TO FIGHT IF UNSUCCESSFUL

 B:
    NON FIGHTING CARD
        condition to check type of card
            if not curse card
                move card player sack
                look for trouble (draw card from hand)
                GO TO FIGHT Method called
            else: cursed:
                apply status
                draw a face down card


END FIGHT / END TURN CLEAN UP
    check player level if win END Game function
    check player sack max
    option to access pack Method equipping, selling, use
    menu: (inspect table, end turn)
    inspect table (all player visible cards)
    end turn button

#####################################################
END TURN
#####################################################
 Next player
 condition check alive
    if alive == False and premdeath == False
        reset condition
        END TURN

######################################################


****************************************************************************************************
**************************************** CLASSES METHODS AND LOGIC ************************************
****************************************************************************************************


Player class:
class for specific setup
initialisation
    player attributes
        self.ref = ref # simple form to keep track of players ( MAY CHANGE TO self.__str__() )
        self.name = None # to be set when called
        self.sex = None
        self.level = 1 # win lvl 10, make changeable so edit score to win
        self.bonus = 0
        self.wallet = 0
        self.race = {'r1': True, 'r2': False} # string eval to True so will show
        self.klass = {'c1': True, 'c2': False}
        self.weapons = {"L_hand": None, "R_hand": None, "big": None, "special_1": None, "special_2": False}
        self.armor = {"headgear": None, "armor": None, "armor1": False, "armor2": False, "footgear": None,
                      "special_1": None, "special_2": False, "special_3": False}
        self.sack = [] # volume to be monitored
        self.visible_cards = [] # cards visible on the table that have value
        self.hireling = []
        self.undefined = [] # unclassified objects for all the things i want but dont know it
        self.alive = True
        self.longevity = 1 # counts cycles alive, if 0 player misses go

    char_setup
        call meth to set up name (P_tools class)
        call method to set up sex

    inventory
        method to set items to the player


class P_tools
    all player related methods unclutter player class


gui#### should (YES, IPC as better known) i have an intermediate gui script that holds all the variables? WORKING PROGRESS

main_gui reports(sets vars) to gui_var script and engine get all variables from gui var script
thus main_gui imports gui_var and engine imports gui_var. gui can then call the classes of engine without moving any variables
or changing the self parameter



Controller:
    Controller serves up pages(frames) that are raised to the top.
    These are pre-build at the beginning
    An update method is required that binds all tk.Vars to library scrip (updated from player model)


Pages:
    start page-
        welcomes with start button that progresses to options toplevel

    options-
        sets game options in variables_library.py.Options.  These will be game flags for certain activities
        modal infobox detailing changes on conformation button press

    player select-
        spin box with player select. textvariable = num_of_players
        button leads to player details playersetter method
        playersetter-
            num_of_players = IntVar() binds to 2 variables in library -
                1) library.StartVariables.new_players that manipulates label in Toplevel
                2) library.StartVariables.player_rand that drives the index for the instances in the list during selection


        PlayerInfo:
            provides a  generic player name with a box to enter name and gender
            button to confirm either moves to another player name/gender or starts game loop
            Information required:
                method to check num of players
                link to game var to bind plays name/gender
                call of method in engine to bind attribs to the correct player
                possible yield loop that takes player instance
                order:
                    while new_players =>1
                    box pops up.
                    player inputs info
                    button is pushed

                        calls player method
                        for each instance (in order) from Maxplayers
                            fetches variable_library and binds to player
                            yields player

                    calls next() method


for main play window the gui must have the librarys ready linking to the instance in question. button will change the
instance associated

mainloop class to define a method to send index to game_loop class.

controller.py:

    controller.py main directive is to either source logic from other classes, provide one shot logic demanded by the
    GUI and primarily to update variables_library.py  that can be accessed by view.py

        Main class: PlayerSetup:
            set_random_player method:
                usees random choice function from the random module.
                picks a random player instance from the generated active_players list
                send result to verbinding method.

            player_attrib_ipc_updater method:
                accepts parameter of a player instance
                uses instance to bind all player attributes to library


    before MainLoop is called all tkVar need to be set up. this is handled by the controller by the method update_atrib_frame.
    At the end of Playerinfo class method test, game_loop will use index to determine the correct player in library.active_players.
    indexed player will bind self to library.player_atribs.x
    controller.Main class binds self.x to StringVar()
    Main.update_atrib_frame method binds all player attributes to tk Variables and the library script
    This update method must be called to refresh/concurrent the labels in the play area



***************************************************************************************************
******************************** ALGORITHM MAPPER **************************************
***************************************************************************************************

#######################################################################
# Game start and options methods
#######################################################################
Detailed method for start page and game options

controller.StartPg, class
    Presents two options start or options
    - start button will call controller.show_frame(PlayerSelect) so that number of players can be selected from the spinbox
    - options button will call toplevel GameOptions class

start button
    controller.show_frame(PlayerSelect)
        See player rotation method detailed in independent section bellow

GameOptions, toplevel
    presents options that change library.Options that act as flags for specific in game methods
    Defaults are set in library. Options for are:
        library.Options.cards_delt = self.inital_deal.get()     # number of each type of card to deal on start
        library.Options.win_lvl = self.maxlvl.get()             # level needed to win game
        library.Options.perm_death = self.permadeath.get()      # game death permanency
        library.Options.carry_weight = self.carry_weight.get()  # number of cards that can be placed in sack
    'Ok' button calls method setopts(self)

    setopts(self), method
        Fetches all tk variables and binds to all library variables.
        creates a message variable with all f-string of all new values
        messagebox.showinfo(title,contents) is called
        messagebox.showinfo("Settings Changed!", message) is called highlighting the changes

    GameOptions.destroy(self), tk.method
        toplevel with options is destroyed after acknowledging messagebox
+
controller.StartPg
player can now either re-enter options of press start

#######################################################################
# Name/gender, random player to start and deal starting set of cards
#######################################################################
Details method for setting a players name/gender, dealing each player a starter set of cards, setting random player to
start and binding that player to the active_player variable for a reference in the game scope for player attrib access.

PlayerSelect(), class (views.py)
    creates spinbox with textvariable=self.Num_of_players bound to tk.IntVar()
    and Confirm Button that calls self.playersetter method

    playersetter(),  Button handler
        library.StartVariables.new_players = self.Num_of_players.get()
            pulls the number of selected players from the spinbox and binds within variable_library.py under StartVariables
            new_players. This is the number of players wanted in the current game.

        library.StartVariables.player_rand = self.Num_of_players.get()
            Also uses the spinbox var for later indexing

        engine.active_player_creation(), method
            method is used to call Player.factory building player instances and placing them into a list of sesion_players.
            deal_handler() is then called which deals cards to each player in the game session.



            deal_handler("start"), method
            Flexible method created to deal cards either at start, after death or specific cards (door/treasure).
            player.unsorted = cards.card_sop.deal_cards("start", library.Options.cards_dealt)
                Used to issue cards to all players. "start" parameter is used to define the the type of deal wanted.
                This then loops over the players in session_players calling cards.card_sop.deal_cards() table.py

                cards.card_sop.deal_cards("start", library.Options.cards_dealt)
                    Calls Table class and the card method card_sop for the Dealer class (a table has-a Dealer) with the
                    method deal_cards. The arguments "start" and ameVar.Options.cards_dealt specify the mode of deal
                    through the branch and the number of each card to deal laid out by the game options respectively.
                    Card selection fo each type is randomised through the use of Random module.
                    Cards are stored in the variable starter_set and returned to caller and bound to player.unsorted.
                    This is a list of cards that associates to the individual player

        PlayerInfo(), toplevel
            Complex script to create a arbitrary name tag with incrementation number, set the name and gender of
            the player, generate a random player to start and structure a game loop that loops over session_players.

                class had 2 class variables:
                    counter = 1  #  player identity title number for arbitrary label
                    indexing = 0 # index to access correct player instance in session_players list and ensures
                    details are bound to the correct player instance.
                    note a 3rd is used but located in library (new_players) set by the playersetter method above.

                Players enter their details and press "confirm" button that triggers initial_set (return button does
                same thing).

                    number = library.StartVariables.new_players

                initial_set, method
                    Branch is created for checking the number of players in library.StartVariables.new_players assigned
                    to the variable name = number. Each time this method is called it reduces number by 1 ensuring that
                    the final entry is the last to redraw the toplevel window. (number -= 1)

                    PlayerInfo.counter += 1 is used to increase the number for the arbitrary player label

                    library.PlayerAtribs.player_name = self.instname.get()
                    library.PlayerAtribs.player_gender = self.instgender.get()
                    Both bind the player attribs provided to the player name in library
                    engine.player_name_gender(PlayerInfo.indexing) is then called

                    engine.player_name_gender(PlayerInfo.indexing), engine class method
                        player = library.StartVariables.session_players[playerindex]
                            class indexing variable is used to pass to player_name_gender method to access the correct
                            player in session_players.
                            player is now a specific player instance

                        player.char_setup() method is called to set and bind attrribs to players

                        player.char_setup(), method
                            calls P_tools.name() and xy = P_tools.name()
                            return value of each is set as a player attribute
                            if the return val is == to the dev mode other attribs will be attributed to the player

                            P_tools.name()
                                x = library.PlayerAtribs.player_name
                                returns name stored in library with title method
                                or dev mode name if criteria met

                            P_tools.name()
                            x = library.PlayerAtribs.player_gender
                            return x.title()

                    PlayerInfo.indexing = PlayerInfo.indexing + 1 is increased for the next player when passed back into
                    engine.player_name_gender(self, playerindex)    NOTE: index == playerindex as it becomes method argument
                    PlayerInfo.destroy(self) is called to destroy the toplevel window
                    library.StartVariables.new_players = number changes the number new_players in library to the new
                    decreased number.

                        Inner loop triggered if number not equal to 0 triggering toplevel to rebuild with the new
                        arbitrary counter label increasing.

                        When the condition runs that the number is == 0, the integer in new_players list has reached
                        zero. This will destroy the toplevel PlayerInfo permanently and trigger the next sequence of
                        events.

                        engine.set_random_player(), method
                            method for selecting a player from the session_players to go first with the use of the
                            random module - player = choice(library.StartVariables.session_players).
                            This method then calls player_attrib_ipc_updater(player), a method specifically for binding the player
                            attributes to library.
                            Importantly library active_player is named: library.StartVariables.active_player = player
                            used later in turn based assignment

                            player_attrib_ipc_updater(player) method
                                Binds all player attributes to library.PlayerAtribs. Note this method can take in any
                                player instance and bind to library.PlayerAtribs.

                        app.update_atrib_frame(), method
                            part of view.py class Main method that acts as the controller. Sets all tk.Vars with
                            library.PlayerAtribs. Act like a refresh for new bindings from player_attrib_ipc_updater that impacts upon
                            MainLoop frame that calls controller.atrib. method also changes size of the Main window
                            ready for gameplay.

                        app.show_frame(MainLoop), method
                            Raises MainLoop to the forefront

#######################################################################
# player rotation method, (initial start and game progression)
#######################################################################

Setting player rotation method and binding attributes. In previous section player_attrib_ipc_updater(player) and update_atrib_frame()
set the player info to the random selected player. This is detailed in the player info to the left on the game screen and
goes first in the game. End turn button should trigger events that lead to the next player and the update of the
player info window.

    end_turn, button method
    On button press player turn ends and another players turn begins.
        engine.player_order(library.StartVariables.active_player) active_player bound in set_random_player method above becomes
        current_player. while play is true (to be set as conditional for library.Options.win_lvl) creates loop for
        players in game. With the use of itertools cycle is used to iterate over the session_players
        player_gen = cycle(library.StartVariables.session_players). next is called to yield next player and loop back
        to the beginning of the list.

        within the while loop there is a branch. current_player is compared to next(player_gen) that is called y.
        If the conditional in not met  current_player == y next is called again until current_player is found == y.
        When this happens there are 2 outcomes either the player is alive or the player is dead.

        In the event of alive library.active_player is updated to next(player_gen) thus next in line to play. player_attrib_ipc_updater
        is called with the new player argument library.active_player. The loop is then broken preventing endless recursion.

        Death and its conditionals will be addressed later.

        app.update_atrib_frame(), method
        method again updates the player info to the left of the screen


#######################################################################
# sell method
#######################################################################

Sell method uses code re-usability to the max with shortened functions that allow various usage buy numerous callers.
The end goal is to remove items from the player adding them to the burn pile and gaining profit from the sale.

    Mainloop the sell (sell_list) button-
        From controller.Mainloop the sell button calls sell_list.
        sell_list first calls scrub_lists. This important as all linked lists ar appended and not built anew.
        calls player from active_player in library

        Player has method called item_by_key. This takes 1 argument 'sell' defined as key on other end
        (but could be anything specific from a game card)
        item_by_key(self, key) generates a list from all cards in player.unsorted (a list of cards delt to the player during
        controller.PlayerSelect.playersetter during player slice) that are specific in the fact they have in card dictionary
        a key called 'sell'. Under list comprehension this generates a list of only sellable objects in the player deck.
        this list is binded to library.GameObjects.selected items.

        Returning to controller, OwnedItems(window_title) Toplevel is now called with the arg "Sellable Items".
        OwnedItems loops over objects in selected_items creating a list format each with a name,type,value and a checkbox.
        ** consider adding info buttion that either raise the pic of the card or text description.
        library.GameObjects.check_but_intvar_gen.append(status) is also build per item and bound to checkbutton changing
        independently with checkbutton activity.
        The id of each card is appended to a new list in library.GameObjects.check_but_card_ids.
        This order is the same order as Checkbutton object in the other list.
        The button is use to call sell method

    sell button -
    engine.zipper() # passes string arg for card_matcher (method acts as conduit)
        Calls engine.zipper method (generic method for zipping 2 list together into a tuple)
        library.GameObjects.zipped_tup.clear() is called to ensure list is clear.
        First step required is the conversion of the Checkbutton objects to the boolean value (0 or 1) from
        library.GameObjects.check_but_intvar_gen, a list of all tk Vars, associated to the check button, requiring .get method.
        This creates new list of booleans called library.GameObjects.check_but_boo consisting of the boolean values.
        x, y = library.GameObjects.check_but_card_ids, library.GameObjects.check_but_boo
        library.GameObjects.zipped_tup = list(zip(x, y)) function is to zip cards independent ids to their bool.
        This creates tuple pairs of (id,0/1) for each card in library.GameObjects.selected items.
        engine.card_matcher(action) is then called.

    engine.card_matcher(action) CREATED FOR FLEXIBILITY OF INPUTS AND FORWARD PASS
        creates loop for each card in library.GameObjects.selected_items that iterates over cards then
        creates an inner loop or tup in library.GameObjects.zipped_tup for each card, NOTE:tup contains (card id, 0or1).
        Conditional if tup[0] == card["id"] and tup[1] filters the cards by matching ids (tup[0]) and only if the
        tup[1] value is == 1 (True).
        After qualification a branch is created calling the correct method associated to action parameter, in this case "sell"
        the qualifying card is passed to sell_item(self, card).

        sell_item(self, card)
            player wallet is substituted with the card value and the card is popped form the
            player unsorted list and cards.add_to_burn(x) is called.

            cards.(self, discard) method -
            x = self.unsorted.pop(self.unsorted.index(card)) # pops card from player unsorted deck
            cards.add_to_burn(x) # popped item is used as arg
                simple method that adds cards to the burn pile that have been remove from the game. note simple arg of the card
                to be removed

    OwnedItems.destroy(self)
        destroys toplevel with sellable items listed

    engine.scrub_lists()
        Critical for appended lists.
        calls scrub_list from engine resetting all appendable lists: selected_items, check_but_intvar_gen, check_but_boo,
        check_but_card_ids and zipped_tup. This reset allows new creation when recalled or new player.

    rebinding variables
    engine.player_attrib_ipc_updater(library.StartVariables.active_player)
    app.update_atrib_frame()
        updates the player info screen detailing changes to player wallet


##########################################################################
# Equipping method
##########################################################################

Accessed by either weapons or armour buttons.
MainLoop, class
    Armor, Main screen button - calls list_armor method

    list_armor, method:
        library.GameObjects.message & app.update_message("show") - Call simple message to the main window

        engine.scrub_lists() - clears all lists ready for new item stack in the toplevel window.

        player.inventory("type", "armor") - searches player card list for cards that have a key of "type" and val of "armor".
            Cards that meet this criteria are sent to library.selected_items. Note that this meth take two params as it is looking for a
            specific key val pair. Note cards have "type":"armor" arrangement in the card dict.

        OwnedItems("Armor Owned", "armor") - TopLevel call with params for title other for button layout specific to armor.

    OwnedItems(title, set_but) - Toplevel, Window is built with title and specific set of buttons for armor cards found in the player.
        Buttons include: sell (method as above), Equip (This focus), a check box and info (displays card) for each item.

        equip - button method, ran on those items that have been checked.
            calls common_set That calls a common set of methods found with many buttons.
                engine.zipper("equip"), method -  See sell meth for action (brief - takes selected_items list and bools
                from checkbox to make. Calls card_matcher)

                card_matcher(action), method - See sell , (brief - id matches cards with the unsorted. The tuples return
                    True to yield cards that can be used). The action parameter defines what happens to the card next).

                    method - For any card to be equipped it must be checked to ensure that it is suited
                        to the player in respects of race, class and gender. This is required as some cards have restrictions
                        who can use them. (This is an updated meth that does away with the a fractured 3 method approach).
                        Uses dict of key vals to loop over player and card. First card is checked for any restrictions,
                        if none exist the loop is exited resulting in the card being passed to the next method.
                        If the card contains a restriction it is compared to the player. In the event the player does not
                        qualify, the cards remains in the unsorted list unequipped. A flag is used to control passage.
                        ############## small bug name can be r and still qualify if no gender set ####################### ADDED DEFAULT GENDER
                        If qualified, door_card_designator(player, card) is called passing the card and player along.





PREBUILD CONSIDERATIONS PLAN
consider changing card to fit ie equip:True then loop over for equipped items. good to dete,rmine bonuses, use re for
status effects/qualifiers. name of equipped item for player info = verbinding can call meth that returns it or none

need to set up vars in Main
access to them
separate player list for equipped/curse/status effects
method to select equipperble items and populate selected_items
way to screen items dependent on player ie for dwarfs only ect

steps needed:::
way to screen cards race/gender... same for cursing??

way to add to player or check if place is occupied already and remove player and add to sack


##########################################################################
# view method
##########################################################################
done



#######################################################################
# remove items
#######################################################################
done
action =  engine,zipper("remove")>
requires a search if player assets as no items will show in top level as they have been removed.



#######################################################################
# enhancers
#######################################################################
not done
most likely card associated methods that are called at start of play to enrich/encumber player


#######################################################################
# door
#######################################################################
Door button triggers the advancement through the game by placing cards on the table. 3 types of card can be door cards.
The three types include: monster, curse or other. In the case of a non-fighting card the player may have the option to
loot the room (another kick of the door that send a card strait to the players hand, not shown on table) or look for trouble
(fight a monster from their hand). On the first kick of the door and a monster or curse card is returned, static methods
are activated (static = conditions determined from the card that must be in place before a fight ie cant outrun, or
instant curse action)

Curses come in 3 flavours, one_shot, time dependent (lasts certain amount of time usually a turn) and permanent until a
condition is met. More on curses under curse section. Their action is strictly kicking (1st turn) a door and player
intervention. This means activation can only happen in theses circumstances.


Door button > door method
     self.end_turn_button.config(state="disabled"), disables end_turn to prevent incorrect usage.

     door_card = engine.deal_handler("door", door_attempts=library.CardDraw.door_attempts)
        Is one of the main method and excepts a return object. The card returned is dependent on the string parameter used.
        In this case the parameter 'door' is used to retrieve a door card. This is the value to the key 'category' within the card's dict.
        door_attempts as a parameter exerts control over where the card ends up and in the current class defines how the
        card is viewed. The returned card is used for the picture on canvas and trigger the card method.

        deal_handler(self, option, deal_amount=0)
           This method is used to define what call is made to the dealer by the option parameter.
           'door' now re-defined as option controls the type of card to get from the deck. As a default cardnum will always be 1
           returning only 1 door card from the dealer.

            door_card = cards.card_sop.deal_cards(option, cardnum=1)
                Runs the Table class that has a dealer() method that returns a door cards. Note, dealer will check the pack first
                and if insufficient cards are present it will em,pty and sort the burn_pile to refresh the card decks.

        engine.door_card_designator(door_card, door_attempts=door_attempts)
            Method first checks door_attempts as this will define where the card is placed. Consider a monster, 1st
            kick would be placed on table while 2nd would be placed in hand.
            Branch statements there after defines the fate of the card dependent upon the card type ('door', 'curse', other).
            else block catches the cards that do not fall into the monster/curse scenarios.
            The final else block relates to the outer branch for door_attempts providing a generic catch that places
            a card in the player hand. ##################################################### (TO BE UPDATED WITH A LOOT_ROOM OR LOOK FOR TROUBLE).

        Further branches in the door method control message broadcasting, button disabling,

    Both engine.card_type() and else statement result in incrementation of num_of_kicks by one.

    With a card that is not a monster card on first instance, a second push of door is allowed. In this instance
    library.CardDraw.num_of_kicks == 1 evaluates correctly disabling door button for further use.
    engine.deal_handler("door", call=0) is called again with the parameter call set to 0 (False)
        engine.deal_handler("door", call=0), method
            like before gets door card in turn calling door_card_designator again with the new call parameter of 0
            door_card_designator(self, card, call=0), method
                now triggers all else statements for the desired card type. In all instances this places the card in the
                player sack and not on the table.


#######################################################################
# fight
#######################################################################
fight button becomes available when a monster is on the table within the in_play list. any additions to this list will
force the player to battle monsters in a first in last out order until no monsters are left. This order is also apparent
with the run button discussed later.



#######################################################################
# run
#######################################################################
method looks up a players ability to run - as a bool 0 = false so no run and all other numbers = true.
If true this number represents the roll required to escape


#######################################################################
# curses
#######################################################################
Consider that there are 3 kind of curses, 1 that effects the player in a single instance like a one_shot. Theses cards
would have an effect and an action instantly, ie loose head_gear. Cards of this type would be returned to burn_pile after
action complete or not.

The second type is the continued effect. Theses cards will effect a player attribute until removed ie -1 to run away.
When called the method is triggered (if valid for the player) and its effect implemented. Removal of the cures must trigger
the curse card's remove method to ensure attributes are returned to normal. Theses cards will be stored under
player.active_curses and NOT returned back to burn pile until a condition to do so is met. This ensures a record of the curse
is kept and access to the removal method is possible.

The 3rd type would be a single turn activity that last a single cycle of play.

Cruse cards can be iterated over to find the one the player wants to remove when in the active_cures list of a player.

consider curses that have effect and those that dont.
    dont > back to burn pile
    do > determine location of activity ( armor, weapon?) needs link to card that is effected (id) and storage
    somewhere in player model. card active in correct situation then deactivation meth required

door_card_designator(self, card, call=1): look under curses to add meth

WHERE I AM NOW...
meth needed to determine if player susceptible to curse. IDEA= all cards that promote and effect can have key word/s that are added to player lexacl or dict with meths.
cures would check against this list for resistant method
ie: lexical would be filled with class bonus words and other bonuses like tinhat. These would be looked up by curse and if non compatible would reject cures.


#######################################################################
# enhancers method
#######################################################################
enchantment to stay on lost weapons!

# may be not a requirement. method can be run by card when used to attach to item and run a remove meth when chosen
(ie with on or off param for adding/removing)




#######################################################################
# interfere method
#######################################################################



#######################################################################
# help
#######################################################################



#######################################################################
# pay to go up level
#######################################################################

****************************************************************************************************
**************************************** planned changes *************************************
****************************************************************************************************

Consider ownership of action handling ie who is responsible for what in the programme ie what is responsible
for sorting cards or game flow?

controller.py
* Splitting up this module into more defined classes will be needed.



########## NOTES FOR CHANGE ###
change table system to display monsters as list of list with dicts eg:  [ [{monster card},{monster enhancers}],[{monster},{wandering monster] ]

This gives each monster on the table the player has to fight a way to enhance, run monster specific methods and provide a way to run from specific monsters.
Basically this provides and environment so that each monster can become independent.

The thought with this is the idea that if a single monster is placed on the table the fight can continue normally.
However, when more than one is present and in the case where players want to intervene, a selection toplevel window would be required.
The top level would require a tick box, to select monster/player to use a card against, names of the objects, and  a button to handel the events.
Weather zipper can be used for this is unknown...

Top level would be used when: selecting a monster to fight, adding an item to the proceeding fight, (note when fight button pushed all interference ceases),
seleting which one to run from, to use a crd against, and all things that require clarity in a target.

Q:: how to run a monster conditions method (method that is ran when facing a specific monster on the table?
    * need auto method on single monster, check required in many cases.
        # check required on run, fight, use
    * to switch off is another monster is added to the table. or to switch on when:
        * assured only one monster on the field of battle, or, suitable selection is made to define which monster is to be challenged.
    * switch on when another monster is chosen.



