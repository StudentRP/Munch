MUNCHKIN

contents:
    GAME GENERAL
        SCRIP DEPENDENCIES
    PLAY CYCLE
        START
        GAME LOOP
        END TURN
    CLASSES METHODS AND LOGIC
    ALGORITHM MAPPER
    PLANNED CHANGES

****************************************************************************************************
**************************************** GAME GENERAL ************************************
****************************************************************************************************,


######################################################
# SCRIPT DEPENDENCIES
######################################################

view.py: provides front end logic and building blocks for GUI

variables_library.py (referred to as library): acts as a IPC script that view.py can interact with and controller.py
can change without creating conflicting imports and convoluted return statements.
This create a clear uncomplicated area that values may be seen, like game options, or stored without obfuscation.

controller.py (referred to as engine): location of all the backend logic that called from the GUI, generic card methods
for sorting, player rotation, control of play and anything else that sits on top of the basic script logic.
This script imports table.py giving access to both doorcards.py & treasurercards.py and playermodel.py.

table.py: is modeled on a playing table and contains classes that relate to a dealer, dice and table. dealer will fetch
cards from both doorcards.py & treasurercards.py returning the card back to the caller (usually engine).
During a fight or when cards are discarded they go to the table. Recovery of cards from the burn pile is controlled
by dealer.

playermodel.py: with set number of instances to prevent card shortage, this class creates the fundamental player.
Methods in this class are indicative of those that cause change to the players individual info or relate to the player
some way. This calls inherits from  doorcards.MonCur so that method like curses can effect the player in question and
treasurecards.T_tools for methods associated to enchanted items. playersetup.py is also imported using the P-tools class.
this however has little functionality and may be absorbed into the player model.

treasurecards.py: contains all cards for the treasure deck. This is a list of nested ditcionaries containing all
information relevent to any of the cards in question. treasurecards.py inherits from T_tools that contains a dictioanry of all
methods associated to a card as a value to the called key received from a card in or used during play.



**********************************************************************************************
****************************** play cycle *******************************
**********************************************************************************************

##################################################
START
##################################################
start gui (links to methods below)
Select number of players
menu options:
    ### game options: number of cards in backpack, lvl to win, starting deal card number, permadeath.
    ### start
Name of each player and gender
Deal cards, 4 of each (changable in possible options)
Random player index

END RESULT: new list of player instances each with names, genders and set of cards.
            random player selected from list and push to game loop
            ### menu added

################################################
GAME LOOP:
################################################

Check to see if player is alive (True), skip if False
Player inventory actions, (gui selection process) = INVENTORY Method, Full access, (sell, equipment, use)
Player initiates Door card to be drawn (on button press)

Card is placed on table(visible) (outcomes A | B)
condition check outcomes
info on outcome

 A: MONSTER: Menu Options (inspect, inventory, ask for help, fight, run, interfere)
    INSPECT OPTION:
        inspect all visible cards on table (players, monster)

    INVENTORY OPTION:
        player item select use item/s (implement effect) INVENTORY Method, Restricted access, NO equip!

    HELP OPTION:
        player ask others for aid, help(condition: gold/treasure)

    INTERFERE option:
        other player interference, selecting items to use for or against

    FIGHT OPTION:
        fight monster/s (first in list or selected...)
        If monster has a static method (const effect) this need to be activated before any actions.
        if additional players want to interfere/help action the methods


        FIGHT OUTCOME:
            Constant outcome:
                any player specific objects used during fight removed from inventory (spent)
                spent cards moved to Table burn_pile
            Win specific:
                any assisting players help condition met (if treasure distribute according to terms, gold transfer)
                treasure distributed
                level increase +n dependent on monster


            Death/BADSTUFF:
                if Death:
                    # check win condition death if True remove player from player list
                    player alive flag set to false
                    death method for player atrib stripping
                    branch for dead players to be reset and cards re-delt
                    END PLAYER TURN
                If BADSTUFF:
                    referer to Monster card as associated methods (require processor function)


            END FIGHT
            Remove monster specific static methods

    RUN OPTION:
       check run attempt condition true or false (cant run from same monmster unless item allows)
       other player/s interference option
       if run true remove card from table list (add to burn pile list)
       run attempt from each monster on the table (alternate between run and fight)
       if Fail set run condition to False (removes/greys_out run option button for current monster)
       END FIGHT IF RUN SUCCESSFUL
       RETURN TO FIGHT IF UNSUCCESSFUL

 B:
    NON FIGHTING CARD
        condition to check type of card
            if not curse card
                move card player sack
                look for trouble (draw card from hand)
                GO TO FIGHT Method called
            else: cursed:
                apply status
                draw a face down card


END FIGHT / END TURN CLEAN UP
    check player level if win END Game function
    check player sack max
    option to access pack Method equipping, selling, use
    menu: (inspect table, end turn)
    inspect table (all player visible cards)
    end turn button

#####################################################
END TURN
#####################################################
 Next player
 condition check alive
    if alive == False and premdeath == False
        reset condition
        END TURN

######################################################


****************************************************************************************************
**************************************** CLASSES METHODS AND LOGIC ************************************
****************************************************************************************************


Player class:
class for specific setup
initialisation
    player attributes
        self.ref = ref # simple form to keep track of players ( MAY CHANGE TO self.__str__() )
        self.name = None # to be set when called
        self.sex = None
        self.level = 1 # win lvl 10, make changeable so edit score to win
        self.bonus = 0
        self.wallet = 0
        self.race = {'r1': True, 'r2': False} # string eval to True so will show
        self.klass = {'c1': True, 'c2': False}
        self.weapons = {"L_hand": None, "R_hand": None, "big": None, "special_1": None, "special_2": False}
        self.armor = {"headgear": None, "armor": None, "armor1": False, "armor2": False, "footgear": None,
                      "special_1": None, "special_2": False, "special_3": False}
        self.sack = [] # volume to be monitored
        self.visible_cards = [] # cards visible on the table that have value
        self.hireling = []
        self.undefined = [] # unclassified objects for all the things i want but dont know it
        self.alive = True
        self.longevity = 1 # counts cycles alive, if 0 player misses go

    char_setup
        call meth to set up name (P_tools class)
        call method to set up sex

    inventory
        method to set items to the player


class P_tools
    all player related methods unclutter player class


gui#### should (YES, IPC as better known) i have an intermediate gui script that holds all the variables? WORKING PROGRESS

main_gui reports(sets vars) to gui_var script and engine get all variables from gui var script
thus main_gui imports gui_var and engine imports gui_var. gui can then call the classes of engine without moving any variables
or changing the self parameter



Controller:
    Controller serves up pages(frames) that are raised to the top.
    These are pre-build at the beginning
    An update method is required that binds all tk.Vars to library scrip (updated from player model)


Pages:
    start page-
        welcomes with start button that progresses to options toplevel

    options-
        sets game options in variables_library.py.Options.  These will be game flags for certain activities
        modal infobox detailing changes on conformation button press

    player select-
        spin box with player select. textvariable = num_of_players
        button leads to player details player_set_up method
        player_set_up-
            num_of_players = IntVar() binds to 2 variables in library -
                1) library.StartVariables.new_players that manipulates label in Toplevel
                2) library.StartVariables.player_rand that drives the index for the instances in the list during selection


        PlayerInfo:
            provides a  generic player name with a box to enter name and gender
            button to confirm either moves to another player name/gender or starts game loop
            Information required:
                method to check num of players
                link to game var to bind plays name/gender
                call of method in engine to bind attribs to the correct player
                possible yield loop that takes player instance
                order:
                    while new_players =>1
                    box pops up.
                    player inputs info
                    button is pushed

                        calls player method
                        for each instance (in order) from Maxplayers
                            fetches variable_library and binds to player
                            yields player

                    calls next() method


for main play window the gui must have the librarys ready linking to the instance in question. button will change the
instance associated

mainloop class to define a method to send index to game_loop class.

controller.py:

    controller.py main directive is to either source logic from other classes, provide one shot logic demanded by the
    GUI and primarily to update variables_library.py  that can be accessed by view.py

        Main class: PlayerSetup:
            set_random_player method:
                usees random choice function from the random module.
                picks a random player instance from the generated active_players list
                send result to verbinding method.

            player_attrib_ipc_updater method:
                accepts parameter of a player instance
                uses instance to bind all player attributes to library


    before MainLoop is called all tkVar need to be set up. this is handled by the controller by the method update_atrib_frame.
    At the end of Playerinfo class method test, game_loop will use index to determine the correct player in library.active_players.
    indexed player will bind self to library.player_atribs.x
    controller.Main class binds self.x to StringVar()
    Main.update_atrib_frame method binds all player attributes to tk Variables and the library script
    This update method must be called to refresh/concurrent the labels in the play area



***************************************************************************************************
******************************** ALGORITHM MAPPER **************************************
***************************************************************************************************

#######################################################################
# Game start and options methods
#######################################################################
Initial start up protocol

controller.StartPg, class
    Presents two Buttons: Start or Options
    - Start button will rase PlayerSelect frame. Number of players may then be selected. GO TO >> PlayerSelect class >>
    - Options button will call Toplevel event GameOptions class. GO TO >> GameOptions class

Start button
    controller.show_frame(PlayerSelect)
        See player rotation method detailed in independent section bellow

#######################################################################
# GAME OPTIONS class
#######################################################################

GameOptions, toplevel event
    presents options that change library.Options that act as flags for specific in game methods
    Defaults are set in library. Options for are:
        library.Options.cards_delt = self.inital_deal.get()     # number of each type of card to deal on start
        library.Options.win_lvl = self.maxlvl.get()             # level needed to win game
        library.Options.perm_death = self.permadeath.get()      # game death permanency
        library.Options.carry_weight = self.carry_weight.get()  # number of cards that can be placed in sack
    'Ok' button calls method setopts(self)

    setopts(self), method
        Fetches all tk variables and binds to all library variables.
        creates a message variable with all f-string of all new values
        messagebox.showinfo(title,contents) is called
        messagebox.showinfo("Settings Changed!", message) is called highlighting the changes

    GameOptions.destroy(self), tk.method
        toplevel with options is destroyed after acknowledging messagebox
+
controller.StartPg
player can now either re-enter options of press start

#######################################################################
# Name/gender, Random player start and Deal starting set of cards
#######################################################################
Details method for setting a players name/gender, dealing each player a starter set of cards, setting random player to
start and binding that player to the active_player variable for a reference in the game scope for player attrib access.

Variables used in variables_library.py library class:
 - library.StartVariables.new_players # num of people in play
 - library.StartVariables.player_rand
 - library.GameObjects.session_players # holds all player instances

Other variables used:
 - self.Num_of_players = tk.IntVar() # store spinbox number of players.
 - playerinst = library.GameObjects.active_player # not used during start (default=None)
 - starter_set # list of cards provided to a player
 - instname # holds a player name temporarily
 - instgender # holds a player gender temporarily

PlayerSelect(), class (views.py)
    spinbox field num of players
    Confirm button GO TO >> player_set_up() >>

    player_set_up(),  Button handler
        BINDS:
        library.StartVariables.new_players = self.Num_of_players.get(). spinbox val used
        library.StartVariables.player_rand = self.Num_of_players.get(). spinbox val used

        CAllS:
        engine.active_player_creation(), method
            Iterates range(library.StartVariables.new_players) calling: player = Player.factory() GO TO >>

                Player.factory() class method: playermodel.py
                        returns Player() to caller creating caller instance of Player

                Iteration adds each player instance to session_players list within the variables_library script.
                (NOTE generic player at this point)

            deal_handler(option='start') >> GO TO >> controller.py PlayerSetUp >> deal_handler()
               # Flexible method: options = start, door, treasure, resurrect scenarios and deal amount int.

                deal_handler(self, option, deal_amount=0), method
                    Branch == option=start
                        Iteration library.GameObjects.session_players
                        player.sack = cards.card_sop.deal_cards(option, deal_amount=library.Options.cards_dealt) >> GO TO >> deal_cards

                 cards.card_sop.deal_cards(option, library.Options.cards_dealt), option=start
                    Persestant method checks card availability
                    Calls Table class and the card method card_sop for the Dealer class (a table has-a Dealer) with the
                    method deal_cards. The arguments "start" and library.Options.cards_dealt specify a branch and the
                    number of each card to deal set within by game options.
                    A starter_set list is compiled from random cards from both monster and treasure. and returned to player.sack
                    player.sack = << RETURN starter_set << END
                    Each player instance now has a sack of cards containing both monster and treasure type cards to the
                    amount defined within game options.

            SUMMARY: Player instances added to session_players and cards added to player.sack. integer created for new_players & player_rand.

        PlayerInfo() class Toplevel called in view >> GO TO >>

        PlayerInfo(),
            Section function is to bind names and genders to the instances within season_players,
            Complex script to create a arbitrary name tag with incrementation number, set the name and gender of
            the player, generate a random player to start and structure a game loop that loops over session_players.
            GUI binds names to library and player class atakes those names and binds tp a player instance.
            Components: instname entry, instgender selector, Confirm button > initial_set handler.

                class had 2 class variables:
                    counter = 1  #  player identity title number for arbitrary label
                    indexing = 0 # index to access correct player instance in session_players list and ensures
                    details are bound to the correct player instance.
                    note a 3rd is used but located in library (new_players) set by the player_set_up method above.

                Players enter their details and press "confirm" button that triggers initial_set (return button does
                same thing).

                    number = library.StartVariables.new_players

                initial_set, method
                    Branch is created for checking the number of players in library.StartVariables.new_players assigned
                    to the variable name = number. Each time this method is called it reduces number by 1 ensuring that
                    the final entry is the last to redraw the toplevel window. (number -= 1)

                    PlayerInfo.counter += 1 is used to increase the number for the arbitrary player label

                    library.PlayerAtribs.player_name = self.instname.get()
                    library.PlayerAtribs.player_gender = self.instgender.get()
                    Both bind the player attribs provided to the player name in library
                    engine.player_name_gender(PlayerInfo.indexing) is then called

                    engine.player_name_gender(PlayerInfo.indexing), engine class method
                        player = library.StartVariables.session_players[playerindex]
                            class indexing variable is used to pass to player_name_gender method to access the correct
                            player in session_players.
                            player is now a specific player instance

                        player.char_setup() method is called to set and bind attrribs to players

                        player.char_setup(), method
                            calls P_tools.name() and xy = P_tools.name()
                            return value of each is set as a player attribute
                            if the return val is == to the dev mode other attribs will be attributed to the player

                            P_tools.name()
                                x = library.PlayerAtribs.player_name
                                returns name stored in library with title method
                                or dev mode name if criteria met

                            P_tools.name()
                            x = library.PlayerAtribs.player_gender
                            return x.title()

                    PlayerInfo.indexing = PlayerInfo.indexing + 1 is increased for the next player when passed back into
                    engine.player_name_gender(self, playerindex)    NOTE: index == playerindex as it becomes method argument
                    PlayerInfo.destroy(self) is called to destroy the toplevel window
                    library.StartVariables.new_players = number changes the number new_players in library to the new
                    decreased number.

                        Inner loop triggered if number not equal to 0 triggering toplevel to rebuild with the new
                        arbitrary counter label increasing.

                        When the condition runs that the number is == 0, the integer in new_players list has reached
                        zero. This will destroy the toplevel PlayerInfo permanently and trigger the next sequence of
                        events.

                        engine.set_random_player(), method
                            method for selecting a player from the session_players to go first with the use of the
                            random module - player = choice(library.StartVariables.session_players).
                            This method then calls player_attrib_ipc_updater(player), a method specifically for binding the player
                            attributes to library.
                            Importantly library active_player is named: library.StartVariables.active_player = player
                            used later in turn based assignment

                            player_attrib_ipc_updater(player) method
                                Binds all player attributes to library.PlayerAtribs. Note this method can take in any
                                player instance and bind to library.PlayerAtribs.

                        app.update_attrib_frame(), method
                            part of view.py class Main method that acts as the controller. Sets all tk.Vars with
                            library.PlayerAttribs. Act like a refresh for new bindings from player_attrib_ipc_updater that impacts upon
                            MainLoop frame that calls controller.attrib. method also changes size of the Main window
                            ready for gameplay.

                        app.show_frame(MainLoop), method
                            Raises MainLoop to the forefront

#######################################################################
# player rotation method, (initial start and game progression)
#######################################################################

Setting player rotation method and binding attributes. In previous section player_attrib_ipc_updater(player) and update_atrib_frame()
set the player info to the random selected player. This is detailed in the player info to the left on the game screen and
goes first in the game. End turn button should trigger events that lead to the next player and the update of the
player info window.

    end_turn, button method
    On button press player turn ends and another players turn begins.
        engine.player_order(library.StartVariables.active_player) active_player bound in set_random_player method above becomes
        current_player. while play is true (to be set as conditional for library.Options.win_lvl) creates loop for
        players in game. With the use of itertools cycle is used to iterate over the session_players
        player_gen = cycle(library.StartVariables.session_players). next is called to yield next player and loop back
        to the beginning of the list.

        within the while loop there is a branch. current_player is compared to next(player_gen) that is called y.
        If the conditional in not met  current_player == y next is called again until current_player is found == y.
        When this happens there are 2 outcomes either the player is alive or the player is dead.

        In the event of alive library.active_player is updated to next(player_gen) thus next in line to play. player_attrib_ipc_updater
        is called with the new player argument library.active_player. The loop is then broken preventing endless recursion.

        Death and its conditionals will be addressed later.

        app.update_attrib_frame(), method
        method again updates the player info to the left of the screen


#######################################################################
# sell method
#######################################################################

Sell method uses code re-usability to the max with shortened functions that allow various usage buy numerous callers.
The end goal is to remove items from the player adding them to the burn pile and gaining profit from the sale.

    Mainloop the sell (sell_list) button-
        From controller.Mainloop the sell button calls sell_list.
        sell_list first calls scrub_lists. This important as all linked lists ar appended and not built anew.
        calls player from active_player in library

        Player has method called item_by_key. This takes 1 argument 'sell' defined as key on other end
        (but could be anything specific from a game card)
        item_by_key(self, key) generates a list from all cards in player.unsorted (a list of cards delt to the player during
        controller.PlayerSelect.player_set_up during player creation) that are specific in the fact they have in card dictionary
        a key called 'sell'. Under list comprehension this generates a list of only sellable objects in the player deck.
        this list is then assigned to library.GameObjects.selected items.

        Returning to controller, OwnedItems(window_title, action) Toplevel is now called with the args "Sellable Items", 'sell'.
        OwnedItems loops over objects in selected_items creating a list format each with a name,type,value and a checkbox.
        library.GameObjects.checkbut_intvar_obj.append(status) is also build per item and bound to checkbutton changing
        independently with checkbutton activity.
        The id of each card is appended to a new list in library.GameObjects.check_but_card_ids.
        This order is the same order as Checkbutton object in the other list.
        The button is use to call sell method

    sell button -
    engine.zipper() # passes string arg for card_matcher (method acts as conduit)
        Calls engine.zipper method (generic method for zipping 2 list together into a tuple)
        library.GameObjects.zipped_tup.clear() is called to ensure list is clear.
        First step required is the conversion of the Checkbutton objects to the boolean value (0 or 1) from
        library.GameObjects.checkbut_intvar_obj, a list of all tk Vars, associated to the check button, requiring .get method.
        This creates new list of booleans called library.GameObjects.check_but_boo consisting of the boolean values.
        x, y = library.GameObjects.check_but_card_ids, library.GameObjects.check_but_boo
        library.GameObjects.zipped_tup = list(zip(x, y)) function is to zip cards independent ids to their bool.
        This creates tuple pairs of (id,0/1) for each card in library.GameObjects.selected items.
        engine.card_matcher(action) is then called.

    engine.card_matcher(action) CREATED FOR FLEXIBILITY OF INPUTS AND FORWARD PASS
        creates loop for each card in library.GameObjects.selected_items that iterates over cards then
        creates an inner loop or tup in library.GameObjects.zipped_tup for each card, NOTE:tup contains (card id, 0or1).
        Conditional if tup[0] == card["id"] and tup[1] filters the cards by matching ids (tup[0]) and only if the
        tup[1] value is == 1 (True).
        After qualification a branch is created calling the correct method associated to action parameter, in this case "sell"
        the qualifying card is passed to sell_item(self, card).

        sell_item(self, card)
            player wallet is substituted with the card value and the card is popped form the
            player unsorted list and cards.add_to_burn(x) is called.

            cards.(self, discard) method -
            x = self.unsorted.pop(self.unsorted.index(card)) # pops card from player unsorted deck
            cards.add_to_burn(x) # popped item is used as arg
                simple method that adds cards to the burn pile that have been remove from the game. note simple arg of the card
                to be removed

    OwnedItems.destroy(self)
        destroys toplevel with sellable items listed

    engine.scrub_lists()
        Critical for appended lists.
        calls scrub_list from engine resetting all appendable lists: selected_items, checkbut_intvar_obj, check_but_boo,
        check_but_card_ids and zipped_tup. This reset allows new creation when recalled or new player.

    rebinding variables
    engine.player_attrib_ipc_updater(library.StartVariables.active_player)
    app.update_atrib_frame()
        updates the player info screen detailing changes to player wallet


##########################################################################
# Equipping method
##########################################################################

Accessed by either weapons or armour buttons.
MainLoop, class
    Armor, Main screen button - calls list_armor method

    list_armor, method:
        library.GameObjects.message & app.broadcast_message("show") - Call simple message to the main window

        engine.scrub_lists() - clears all lists ready for new item stack in the toplevel window.

        player.inventory("type", "armor") - searches player card list for cards that have a key of "type" and val of "armor".
            Cards that meet this criteria are sent to library.selected_items. Note that this meth take two params as it is looking for a
            specific key val pair. Note cards have "type":"armor" arrangement in the card dict.

        OwnedItems("Armor Owned", "armor") - TopLevel call with params for title other for button layout specific to armor.

    OwnedItems(title, set_but) - Toplevel, Window is built with title and specific set of buttons for armor cards found in the player.
        Buttons include: sell (method as above), Equip (This focus), a check box and info (displays card) for each item.

        equip - button method, ran on those items that have been checked.
            calls common_set That calls a common set of methods found with many buttons.
                engine.zipper("equip"), method -  See sell meth for action (brief - takes selected_items list and bools
                from checkbox to make. Calls card_matcher)

                card_matcher(action), method - See sell , (brief - id matches cards with the unsorted. The tuples return
                    True to yield cards that can be used). The action parameter defines what happens to the card next).

                    method - For any card to be equipped it must be checked to ensure that it is suited
                        to the player in respects of race, class and gender. This is required as some cards have restrictions
                        who can use them. (This is an updated meth that does away with the a fractured 3 method approach).
                        Uses dict of key vals to loop over player and card. First card is checked for any restrictions,
                        if none exist the loop is exited resulting in the card being passed to the next method.
                        If the card contains a restriction it is compared to the player. In the event the player does not
                        qualify, the cards remains in the unsorted list unequipped. A flag is used to control passage.
                        ############## small bug name can be r and still qualify if no gender set ####################### ADDED DEFAULT GENDER
                        If qualified, door_card_designator(player, card) is called passing the card and player along.



PREBUILD CONSIDERATIONS PLAN
consider changing card to fit ie equip:True then loop over for equipped items. good to dete,rmine bonuses, use re for
status effects/qualifiers. name of equipped item for player info = verbinding can call meth that returns it or none

need to set up vars in Main
access to them
separate player list for equipped/curse/status effects
method to select equipperble items and populate selected_items
way to screen items dependent on player ie for dwarfs only ect

steps needed:::
way to screen cards race/gender... same for cursing??

way to add to player or check if place is occupied already and remove player and add to sack


##########################################################################
# view method
##########################################################################
done



#######################################################################
# remove items
#######################################################################
done
action =  engine,zipper("remove")>
requires a search if player assets as no items will show in top level as they have been removed.



#######################################################################
# enhancers
#######################################################################
not done
most likely card associated methods that are called at start of play to enrich/encumber player



#######################################################################
# door
#######################################################################
Door button triggers the advancement through the game by placing cards on the table and actioning any static methods is may
have to influence play. 3 types of card can be door cards.
The three types include: monster, curse or other. In the case of a non-fighting card the player may have the option to
loot the room (another kick of the door that send a card strait to the players hand, not shown on table) or look for trouble
(fight a monster from their hand).

On the first kick of the door, and a monster or curse card is returned, a static method is ran on the card to implement
any effects it may have on the player ready for the fight.
Curses come in 3 flavours, one_shot, time dependent (lasts certain amount of time usually a turn) and permanent until a
condition is met. More on curses under curse section. In this section we are only interested in their action when kicking
(1st turn) a door and how this effects the player.

Hitting the door button initiates a cascade of events that leads to:
    - certain buttons being disabled
    - static methods of cards activated
    - card being delt to the table
    - card being displayed
    - broadcast system update


Door button > door method
     self.end_turn_button.config(state="disabled"), disables end_turn to prevent incorrect usage.

     door_card = engine.deal_handler("door", deal_amount=default)
        Is one of the main method and excepts a return object. The card returned is dependent on the string parameter used.
        In this case the parameter 'door' is used to retrieve a door card. This is the value to the key 'category' within the card's dict.
        door_attempts as a parameter exerts control over where the card ends up and in the current class defines how the
        card is viewed. The returned card is used for the picture on canvas and trigger the card method.

        deal_handler(self, option, deal_amount=1):
            # option = 'start', 'door', 'treasure', 'resurrect'
            # deal_amount = default=1, set for treasure cards to deal back to player/s
               This method is used to define what call is made to the dealer by the option parameter.
               a 'door' param, now re-defined as option controls the type of card to get from the deck. As a default deal_amount will always be 1
               returning only 1 door card from the dealer.

                door_card = cards.card_sop.deal_cards(option, deal_amount) #  REQUIRES ALL PARAMS TO BE PASSED BY CALLER
                    Runs the Table class that has-a dealer() method that returns a door cards. Note, dealer will check the pack first
                    and if insufficient cards are present it will empty and sort the burn_pile to refresh the card decks. !MAY BE CHANGE TO A FIRST IN FIRST OUT ALGORITHM!
                    A card is returned to the caller back to door_card variable.

     engine.door_card_designator(door_card, door_attempts=library.CardDraw.door_attempts_remaining)
        # door_card is the returned card above
        # door_attempts determines how many times the door has been kicked  and the gui changes to be made.
            Method first checks door_attempts as this will define where the card is placed. Consider a monster, 1st
            kick would be placed on table while 2nd would be placed in hand.
            Branch statements there after defines the fate of the card dependent upon the card type ('door', 'curse', other).
            else block catches the cards that do not fall into the monster/curse scenarios placing in the player sack.
            The final else block relates to the outer branch for door_attempts providing a generic catch that places
            a card in the player hand. ##################################################### (TO BE UPDATED WITH A LOOT_ROOM OR LOOK FOR TROUBLE METHODS).
            HANDS BACK TO GUI COMPONENT

     Branch: library.CardDraw.door_attempts_remaining FIRST KICK
        Processes the card to display it on the canvas.
        Conditional check for mon/curs to update broadcast
        If monster a cascade of events relating to button states will ensue main one being the deactivation of the door preventing
        further use on the current players turn.

     Branch: library.CardDraw.door_attempts_remaining == 0:
        Will never be reached if kick button deactivated. Only works if first kick was NOT a monster.
        Cascade events to not show the card on canvas and disable door for further use and enable end_turn state change.

    library.CardDraw.door_attempts_remaining = 0
        Always run but does not make difference when first kick is monster.
        Importance is in the card that is not the monster allowing second kick to proceed.

    Tools.fluid_player_info()
           Updates any changes to the player made by the the door_card ready for the next scenario.

Remember: After this method ends static card methods have been enabled, card is on the table or in hand, button sates have changed


#######################################################################
# fight
#######################################################################
fight button becomes available when a monster is on the table within the in_play list. any additions to this list will
force the player to battle monsters in a first in last out order until no monsters are left. This order is also apparent
with the run button discussed later.



#######################################################################
# run
#######################################################################
method looks up a players ability to run - as a bool 0 = false so no run and all other numbers = true.
If true this number represents the roll required to escape


#######################################################################
# card activation
#######################################################################
Card activation is a massive part of the game so a dynamic system is required. cards are required to be activated when:
# first put on table be it monster or curse
# used in interferance, wondering monster, enhancer
# when equipped as enhancer
# results of win/looses in fights
# change must be specific to a player

Method must:
    # take in any number of cards and methods and states
    # activate card method
    # change player state/ include remove items
    # elicit change from and enchantment within a player
    # in some cases return a cred for further processing

Generic method calls:
    # player.card_meths(card, static='on') 3 important parts: 1) player is the active player during the game
        2) Card/s must be the first argument/s 3) keywords must be used to define a method and a state.

Method:
        card_meths(self, *args, **kwargs)
            Loops over kwargs generating retrieving the keys and values (method : state).
            The first arg should be the card in which u wish to activate with the method and state
            Cards are packed in a tuple thus indexing is used to address the correct card.
            Method should retrieve a list of methods as its value from the card and iterated over. This is so a card
            can have more than one method associated to a key.
            The method from the list is checked against the keys of method_types found in either the doorcards.py or
            treasure.py scripts.
            matches calls the first class object with params : method_call(self, state, args[1:])
            This places the player in direct association to the methods associated to the cards and thus changing
            player states. state will tell the method to switch on or off and args[1:] passes all but the first card to
            the method if required. This is important for wondering monsters!

Typical monster method:
        def test_meth(self, *args):
            print('In test meth expecting level change to 500')
            if "on" in args:
                print('lvl changed')
                self.level = 500
            else:
                self.level = -500

    # args in this cas uses args[0] as state control, all others will be cards.
    # self.level gives direct access to the player state information.

Notes: from within doorcards.py or treasure.py scripts cards can not be sent to the burn or put into play. Them must therefore
    be return back to the caller in controller class for further processing. As a relic of the proces of iteration through the
    listed_meths a none type can be returned. This is screened out by a return check. before returned cards are processed.
    any object returned to the caller is in the form of a list object. The first arg of this is a string that is used to
    determine the fate of the cards. This process is also used to deal with the initial fires card, args[0].

Look_up kwargs calls:
    static='on' # turns the static method on. 'off' will have the opposite effect..
    method_bs='on' # Runs the bad stuff after a fight







#######################################################################
# curses
#######################################################################
Consider that there are 3 kind of curses, 1 that effects the player in a single instance like a one_shot. Theses cards
would have an effect and an action instantly, ie loose head_gear. Cards of this type would be returned to burn_pile after
action complete or not.

The second type is the continued effect. Theses cards will effect a player attribute until removed ie -1 to run away.
When called the method is triggered (if valid for the player) and its effect implemented. Removal of the cures must trigger
the curse card's remove method to ensure attributes are returned to normal. Theses cards will be stored under
player.active_curses and NOT returned back to burn pile until a condition to do so is met. This ensures a record of the curse
is kept and access to the removal method is possible.

The 3rd type would be a single turn activity that last a single cycle of play.

Cruse cards can be iterated over to find the one the player wants to remove when in the active_cures list of a player.

consider curses that have effect and those that dont.
    dont > back to burn pile
    do > determine location of activity ( armor, weapon?) needs link to card that is effected (id) and storage
    somewhere in player model. card active in correct situation then deactivation meth required

door_card_designator(self, card, call=1): look under curses to add meth

WHERE I AM NOW...
meth needed to determine if player susceptible to curse. IDEA= all cards that promote and effect can have key word/s that are added to player lexical or dict with meths.
cures would check against this list for resistant method
ie: lexical would be filled with class bonus words and other bonuses like tinhat. These would be looked up by curse and if non compatible would reject cures.


#######################################################################
# enhancers method
#######################################################################
enchantment to stay on lost weapons!

# may be not a requirement. method can be run by card when used to attach to item and run a remove meth when chosen
(ie with on or off param for adding/removing)




#######################################################################
# interfere method
#######################################################################
Method requiring an antagonist (first selection), a target and an action for the card.

This method is triggered when the interfere button is pressed. The method, linked to the main play window, when
clicked calls the app.wait_window(RadioSelector('Player Select')). This is an important step as calling the window directly
will allow the main window to remain in operation and index a list that is not assigned (not good!). Once the player is
selected and the list are build a self.destroy() on the toplevel window RadioSelector allows the main window to proceed.

Now that an antagonist can be identified we need to look through the cards that are relevant. Once a card is chosen another
wait_window must be used to identify the target. This list contains both monsters and all players. Having selected a target
the card must be either placed iun the relevant card_set on the table or actioned against the person (curses, ect)

library.Interfere.card_storage is used to stor any cards in from the antagonist ready for card_meths


#######################################################################
# help
#######################################################################
Now uses the RadioSelector to help a player. NOT SET UP


#######################################################################
# pay to go up level
#######################################################################

****************************************************************************************************
**************************************** planned changes *************************************
****************************************************************************************************

Consider ownership of action handling ie who is responsible for what in the programme ie what is responsible
for sorting cards or game flow?

controller.py
* Splitting up this module into more defined classes will be needed.



########## NOTES FOR CHANGE ###
change table system to display monsters as list of list with dicts eg:  [ [{monster card},{monster enhancers}],[{monster},{wandering monster] ] DONE

This gives each monster on the table the player has to fight a way to enhance, run monster specific methods and provide a way to run from specific monsters.
Basically this provides and environment so that each monster can become independent.

The thought with this is the idea that if a single monster is placed on the table the fight can continue normally.
However, when more than one is present and in the case where players want to intervene, a selection toplevel window would be required.
The top level would require a tick box, to select monster/player to use a card against, names of the objects, and  a button to handel the events.
Weather zipper can be used for this is unknown...

Top level would be used when: selecting a monster to fight, adding an item to the proceeding fight, (note when fight button pushed all interference ceases),
seleting which one to run from, to use a crd against, and all things that require clarity in a target. Also used to selct player to interfere and where to use hteir item. MOST OF IT DONE

Q:: how to run a monster conditions method (method that is ran when facing a specific monster on the table?
    * need auto method on single monster, check required in many cases.
        # check required on run, fight, use
    * to switch off is another monster is added to the table. or to switch on when:
        * assured only one monster on the field of battle, or, suitable selection is made to define which monster is to be challenged.
    * switch on when another monster is chosen.


 change bonus system to be on card methods which add or remove from player directly, loose calc method for it!.
 Monsters run 3 methods types: static, method, method_bs. static can
 search through player enhancers (placed on there by armour methods ect) to see if special event ie fire armour 2+
 bonus.



