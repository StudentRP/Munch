,Game logic algorithmic determination

##################################################
START
##################################################
start gui (links to methods below)
Select number of players
menu options:
    ### game options: number of cards in backpack, lvl to win, starting deal card number, permadeath.
    ### start
Name of each player and gender
Deal cards, 4 of each (changable in possible options)
Random player index

END RESULT: new list of player instances each with names, genders and set of cards.
            random player selected from list and push to game loop
            ### menu added

################################################
GAME LOOP:
################################################

Check to see if player is alive (True), skip if False
Player inventory actions, (gui selection process) = INVENTORY Method, Full access, (sell, equipment, use)
Player initiates Door card to be drawn (on button press)

Card is placed on table(visible) (outcomes A | B)
condition check outcomes
info on outcome

 A: MONSTER: Menu Options (inspect, inventory, ask for help, fight, run, interfere)
    INSPECT OPTION:
        inspect all visible cards on table (players, monster)

    INVENTORY OPTION:
        player item select use item/s (implement effect) INVENTORY Method, Restricted access, NO equip!

    HELP OPTION:
        player ask others for aid, help(condition: gold/treasure)

    INTERFERE option:
        other player interference, selecting items to use for or against

    FIGHT OPTION:
        fight monster/s (first in list)

        FIGHT OUTCOME:
            Constant outcome:
                any player specific objects used during fight removed from inventory (spent)
                spent cards moved to Table burn_pile
            Win specific:
                any assisting players help condition met (if treasure distribute according to terms, gold transfer)
                treasure distributed
                level increase +1 per monster
                END FIGHT

            Death/BADSTUFF:
                if Death:
                    # check win condition death if True remove player from player list
                    player alive flag set to false
                    death method for player atrib stripping
                    branch for dead players to be reset and cards re-delt
                    END PLAYER TURN
                If BADSTUFF:
                    referer to Monster card as associated methods (require processor function)
                    END FIGHT
    RUN OPTION:
       check run attempt condition true or false (cant run from same monmster unless item allows)
       other player/s interference option
       if run true remove card from table list (add to burn pile list)
       run attempt from each monster on the table (alternate between run and fight)
       if Fail set run condition to False (removes/greys_out run option button for current monster)
       END FIGHT IF RUN SUCCESSFUL
       RETURN TO FIGHT IF UNSUCCESSFUL

 B:
    NON FIGHTING CARD
        condition to check type of card
            if not curse card
                move card player sack
                look for trouble (draw card from hand)
                GO TO FIGHT Method called
            else: cursed:
                apply status
                draw a face down card


END FIGHT / END TURN CLEAN UP
    check player level if win END Game function
    check player sack max
    option to access pack Method equipping, selling, use
    menu: (inspect table, end turn)
    inspect table (all player visible cards)
    end turn button

#####################################################
END TURN
#####################################################
 Next player
 condition check alive
    if True
        reset condition
        END TURN


######################################################
# classes and methods
######################################################

Player class:
class for specific setup
initialisation
    player attributes
        self.ref = ref # simple form to keep track of players
        self.name = None # to be set when called
        self.sex = None
        self.level = 1 # win lvl 10, make changeable so edit score to win
        self.bonus = 0
        self.wallet = 0
        self.race = {'r1': True, 'r2': False} # string eval to True so will show
        self.klass = {'c1': True, 'c2': False}
        self.weapons = {"L_hand": None, "R_hand": None, "big": None, "special_1": None, "special_2": False}
        self.armor = {"headgear": None, "armor": None, "armor1": False, "armor2": False, "footgear": None,
                      "special_1": None, "special_2": False, "special_3": False}
        self.sack = [] # volume to be monitored
        self.visible_cards = [] # cards visible on the table that have value
        self.hireling = []
        self.undefined = [] # unclassified objects for all the things i want but dont know it
        self.alive = True
        self.longevity = 1 # counts cycles alive, if 0 player misses go

    char_setup
        call meth to set up name (P_tools class)
        call method to set up sex

    inventory
        method to set items to the player


class P_tools
    all player related methods unclutter player class


gui#### should i have an intermediate gui script that holds all the variables? WORKING PROGRESS

main_gui reports(sets vars) to gui_var script and engine get all variables from gui var script
thus main_gui imports gui_var and engine imports gui_var. gui can then call the classes of engine without moving any variables
or changing the self parameter


######################################################
# GUI considerations
######################################################

Controller:
    Controller serves up pages(frames) that are raised to the top.
    These are pre-build at the beginning
    An update method is required that binds all tk.Vars to gameVar scrip (updated from player model)


Pages:
    start page-
        welcomes with start button that progresses to options frame (if included)

    options-
        sets game options. button leads to player select

    player select-
        spin box with player select. textvariable = num_of_players
        button leads to player details playersetter method
        playersetter-
            num_of_players =StringVar() binds to 2 variables in gameVar -
                1) gameVar.StartVariables.new_players that manipulates label in Toplevel
                2) gameVar.StartVariables.player_rand that drives the index for the instances in the list during selection


        PlayerInfo:
            provides a  generic player name with a box to enter name and gender
            button to confirm either moves to another player name/gender or starts game loop
            Information required:
                method to check num of players
                link to game var to bind plays name/gender
                call of method in engine to bind attribs to the correct player
                possible yield loop that takes player instance
                order:
                    while new_players =>1
                    box pops up.
                    player inputs info
                    button is pushed

                        calls player method
                        for each instance (in order) from Maxplayers
                            fetches gui_variables and binds to player
                            yields player

                    calls next() method


for main play window the gui must have the gamevars ready linking to the instance in question. button will change the
instance associated

mainloop class to define a method to send index to game_loop class.

game_Loop.py
    Game_loop.py main directive is to either source logic from other classes, provide one shot logic demanded by the
    GUI and primarily to update gui_variables.py  that can be accessed by controller.py

        Main class: PlayerSetup:
            rand method:
                usees random choice function from the random module.
                picks a random player instance from the generated active_players list
                send result to verbinding method.

            varbinding method:
                accepts parameter of a player instance
                uses instance to bind all player attributes to gameVar

    before MainLoop is called all tkVar need to be set up. this is handled by the controller by the method update_frame.
    At the end of Playerinfo class method test, game_loop will use index to determine the correct player in gameVar.active_players.
    indexed player will bind self to gameVar.player_atribs.x
    controller.Main class binds self.x to StringVar()
    Main.update_frame method binds all player attributes to tk Variables and the gameVar script
    This update method must be called to refresh/concurrent the labels in the play area










